# 1 "c:\\users\\admin\\appdata\\local\\temp\\tmpfnroqq"
#include <Arduino.h>
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"


#ifdef CONTINUOUS_INTEGRATION

#pragma GCC diagnostic error "-Wall"

#else

#pragma GCC diagnostic warning "-Wall"

#endif





#ifdef PLUGIN_SET_GENERIC_ESP32

  #ifndef ESP32

    #define ESP32

  #endif

#endif
# 167 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
#include "ESPEasy-Globals.h"

#include "define_plugin_sets.h"



#include "_CPlugin_Helper.h"





boolean Blynk_get(const String& command, byte controllerIndex,float *data = NULL );
int firstEnabledBlynkController();
void setup();
void RTOS_TaskServers( void * parameter );
void RTOS_TaskSerial( void * parameter );
void RTOS_Task10ps( void * parameter );
int firstEnabledMQTTController();
bool getControllerProtocolDisplayName(byte ProtocolIndex, byte parameterIdx, String& protoDisplayName);
void updateLoopStats();
void updateLoopStats_30sec(byte loglevel);
float getCPUload();
int getLoopCountPerSec();
void loop();
bool checkConnectionsEstablished();
void runPeriodicalMQTT();
String getMQTT_state();
void updateMQTTclient_connected();
void run50TimesPerSecond();
void run10TimesPerSecond();
void runOncePerSecond();
void logTimerStatistics();
void runEach30Seconds();
void SensorSendTask(byte TaskIndex);
void backgroundtasks();
String doExecuteCommand(const char * cmd, struct EventStruct *event, const char* line);
String return_command_success();
String return_command_failed();
String return_not_connected();
String return_result(struct EventStruct *event, const String& result);
String return_see_serial(struct EventStruct *event);
void ExecuteCommand(byte source, const char *Line);
void printDirectory(File dir, int numTabs);
void sendData(struct EventStruct *event);
boolean validUserVar(struct EventStruct *event);
void callback(char* c_topic, byte* b_payload, unsigned int length);
bool MQTTConnect(int controller_idx);
bool MQTTCheck(int controller_idx);
void SendStatus(byte source, String status);
boolean MQTTpublish(int controller_idx, const char* topic, const char* payload, boolean retained);
void scheduleNextMQTTdelayQueue();
void processMQTTdelayQueue();
void MQTTStatus(String& status);
String getBearing(int degrees);
float CelsiusToFahrenheit(float celsius);
int m_secToBeaufort(float m_per_sec);
String centimeterToImperialLength(float cm);
String millimeterToImperialLength(float mm);
float minutesToDay(int minutes);
String minutesToDayHour(int minutes);
String minutesToHourMinute(int minutes);
String minutesToDayHourMinute(int minutes);
String secondsToDayHourMinuteSecond(int seconds);
String format_msec_duration(long duration);
unsigned long float2ul(float f);
float ul2float(unsigned long ul);
void logStatistics(byte loglevel, bool clearLog);
String FileError(int line, const char * fname);
void flashCount();
String flashGuard();
String BuildFixes();
void fileSystemCheck();
String SaveSettings(void);
String LoadSettings();
byte disablePlugin(byte bootFailedCount);
byte disableController(byte bootFailedCount);
byte disableNotification(byte bootFailedCount);
bool getSettingsParameters(SettingsType settingsType, int index, int& max_index, int& offset, int& max_size, int& struct_size);
int getMaxFilePos(SettingsType settingsType);
int getFileSize(SettingsType settingsType);
bool getAndLogSettingsParameters(bool read, SettingsType settingsType, int index, int& offset, int& max_size);
bool getSettingsParameters(SettingsType settingsType, int index, int& offset, int& max_size);
String SaveTaskSettings(byte TaskIndex);
String LoadTaskSettings(byte TaskIndex);
String SaveCustomTaskSettings(int TaskIndex, byte* memAddress, int datasize);
String ClearCustomTaskSettings(int TaskIndex);
String LoadCustomTaskSettings(int TaskIndex, byte* memAddress, int datasize);
String SaveControllerSettings(int ControllerIndex, ControllerSettingsStruct& controller_settings);
String LoadControllerSettings(int ControllerIndex, ControllerSettingsStruct& controller_settings);
String ClearCustomControllerSettings(int ControllerIndex);
String SaveCustomControllerSettings(int ControllerIndex,byte* memAddress, int datasize);
String LoadCustomControllerSettings(int ControllerIndex,byte* memAddress, int datasize);
String SaveNotificationSettings(int NotificationIndex, byte* memAddress, int datasize);
String LoadNotificationSettings(int NotificationIndex, byte* memAddress, int datasize);
String InitFile(const char* fname, int datasize);
String SaveToFile(char* fname, int index, byte* memAddress, int datasize);
String ClearInFile(char* fname, int index, int datasize);
String LoadFromFile(char* fname, int offset, byte* memAddress, int datasize);
String getSettingsFileIndexRangeError(bool read, SettingsType settingsType, int index);
String getSettingsFileDatasizeError(bool read, SettingsType settingsType, int index, int datasize, int max_size);
String LoadFromFile(SettingsType settingsType, int index, char* fname, byte* memAddress, int datasize);
String SaveToFile(SettingsType settingsType, int index, char* fname, byte* memAddress, int datasize);
String ClearInFile(SettingsType settingsType, int index, char* fname);
int SpiffsSectors();
String getPartitionType(byte pType, byte pSubType);
String getPartitionTableHeader(const String& itemSep, const String& lineEnd);
String getPartitionTable(byte pType, const String& itemSep, const String& lineEnd);
void processConnect();
void processDisconnect();
void processGotIP();
void processConnectAPmode();
void processDisconnectAPmode();
void processDisableAPmode();
void processScanDone();
void resetWiFi();
void WifiScanAsync();
bool WifiIsAP(WiFiMode_t wifimode);
bool WifiIsSTA(WiFiMode_t wifimode);
void setSTA(bool enable);
void setAP(bool enable);
void setAPinternal(bool enable);
void setWifiMode(WiFiMode_t wifimode);
String WifiGetAPssid();
String WifiGetHostname();
bool useStaticIP();
bool WiFiConnected();
void WiFiConnectRelaxed();
bool prepareWiFi();
const char* getLastWiFiSettingsSSID();
const char* getLastWiFiSettingsPassphrase();
bool selectNextWiFiSettings();
bool selectValidWiFiSettings();
bool wifiSettingsValid(const char* ssid, const char* pass);
bool wifiConnectTimeoutReached();
void setupStaticIPconfig();
bool tryConnectWiFi();
void WifiDisconnect();
void WifiScan();
String formatScanResult(int i, const String& separator);
String SDKwifiStatusToString(uint8_t sdk_wifistatus);
String ArduinoWifiStatusToString(uint8_t arduino_corelib_wifistatus);
String ESPeasyWifiStatusToString();
void logConnectionStatus();
void WifiCheck();
bool getSubnetRange(IPAddress& low, IPAddress& high);
String getLastDisconnectReason();
void hardwareInit();
void checkResetFactoryPin();
bool I2C_read_bytes(uint8_t i2caddr, I2Cdata_bytes& data);
bool I2C_read_words(uint8_t i2caddr, I2Cdata_words& data);
void I2C_wakeup(uint8_t i2caddr);
bool I2C_write8(uint8_t i2caddr, byte value);
bool I2C_write8_reg(uint8_t i2caddr, byte reg, byte value);
bool I2C_write16_reg(uint8_t i2caddr, byte reg, uint16_t value);
bool I2C_write16_LE_reg(uint8_t i2caddr, byte reg, uint16_t value);
uint8_t I2C_read8_reg(uint8_t i2caddr, byte reg, bool * is_ok);
uint16_t I2C_read16_reg(uint8_t i2caddr, byte reg);
int32_t I2C_read24_reg(uint8_t i2caddr, byte reg);
int32_t I2C_read32_reg(uint8_t i2caddr, byte reg);
uint16_t I2C_read16_LE_reg(uint8_t i2caddr, byte reg);
int16_t I2C_readS16_reg(uint8_t i2caddr, byte reg);
int16_t I2C_readS16_LE_reg(uint8_t i2caddr, byte reg);
void tcpCleanup();
bool isDeepSleepEnabled();
bool readyForSleep();
void deepSleep(int delay);
void deepSleepStart(int delay);
boolean remoteConfig(struct EventStruct *event, const String& string);
int8_t getTaskIndexByName(String TaskNameSearch);
void setPinState(byte plugin, byte index, byte mode, uint16_t value);
boolean getPinState(byte plugin, byte index, byte *mode, uint16_t *value);
boolean hasPinState(byte plugin, byte index);
bool getBitFromUL(uint32_t number, byte bitnr);
void setBitToUL(uint32_t& number, byte bitnr, bool value);
String getPinStateJSON(boolean search, byte plugin, byte index, String& log, uint16_t noSearchValue);
void statusLED(boolean traffic);
void delayBackground(unsigned long delay);
void parseCommandString(struct EventStruct *event, const String& string);
void taskClear(byte taskIndex, boolean save);
String checkTaskSettings(byte taskIndex);
byte getDeviceIndex(byte Number);
String getPluginNameFromDeviceIndex(byte deviceIndex);
byte getProtocolIndex(byte Number);
byte getNotificationProtocolIndex(byte Number);
boolean GetArgv(const char *string, char *argv, unsigned int argc);
boolean GetArgv(const char *string, char *argv, unsigned int argv_size, unsigned int argc);
void dump (uint32_t addr);
uint32_t progMemMD5check();
String getTaskDeviceName(byte TaskIndex);
void ResetFactory(void);
void emergencyReset();
unsigned long FreeMem(void);
String getLastBootCauseString();
String getResetReasonString(byte icore);
String getResetReasonString();
uint32_t getFlashRealSizeInBytes();
String getSystemBuildString();
String getPluginDescriptionString();
String getSystemLibraryString();
String getLWIPversion();
boolean isFloat(const String& tBuf);
boolean isValidFloat(float f);
boolean isInt(const String& tBuf);
bool validIntFromString(const String& tBuf, int& result);
bool validFloatFromString(const String& tBuf, float& result);
String getNumerical(const String& tBuf, bool mustBeInteger);
boolean isNumerical(const String& tBuf, bool mustBeInteger);
float timeStringToSeconds(String tBuf);
void initLog();
String getLogLevelDisplayString(byte index, int& logLevel);
void addToLog(byte loglevel, const String& string);
void addToLog(byte logLevel, const __FlashStringHelper* flashString);
bool SerialAvailableForWrite();
void disableSerialLog();
void setLogLevelFor(byte destination, byte logLevel);
void updateLogLevelCache();
bool loglevelActiveFor(byte logLevel);
boolean loglevelActiveFor(byte destination, byte logLevel);
boolean loglevelActive(byte logLevel, byte logLevelSettings);
void addToLog(byte logLevel, const char *line);
void process_serialLogBuffer();
void delayedReboot(int rebootDelay);
void reboot();
boolean saveToRTC();
void initRTC();
boolean readFromRTC();
boolean saveUserVarToRTC();
boolean readUserVarFromRTC();
uint32_t getChecksum(byte* buffer, size_t size);
String parseTemplate(String &tmpString, byte lineSize);
int push(float value);
float pop();
float apply_operator(char op, float first, float second);
float apply_unary_operator(char op, float first);
int RPNCalculate(char* token);
int op_preced(const char c);
bool op_left_assoc(const char c);
unsigned int op_arg_count(const char c);
int Calculate(const char *input, float* result);
int CalculateParam(char *TmpStr);
void checkRuleSets();
void rulesProcessing(String& event);
String rulesProcessingFile(String fileName, String& event);
void parseCompleteNonCommentLine(

    String& line,

    String& event,

    String& log,

    bool& match,

    bool& codeBlock,

    bool& isCommand,

    bool condition[],

    bool ifBranche[],

    byte& ifBlock,

    byte& fakeIfBlock);
void processMatchedRule(

  String& lcAction, String& action, String& event, String& log,

  bool& match,

  bool& codeBlock,

  bool& isCommand,

  bool condition[],

  bool ifBranche[],

  byte& ifBlock,

  byte& fakeIfBlock);
boolean ruleMatch(String& event, String& rule);
boolean conditionMatchExtended(String& check);
boolean conditionMatch(const String& check);
void rulesTimers();
void createRuleEvents(byte TaskIndex);
void SendValueLogger(byte TaskIndex);
void checkRAMtoLog(void);
void checkRAM(const __FlashStringHelper* flashString, int a );
void checkRAM(const __FlashStringHelper* flashString, String &a );
void checkRAM(String &flashString, String &a );
void checkRAM( const __FlashStringHelper* flashString);
void checkRAM( String &a );
void tone_espEasy(uint8_t _pin, unsigned int frequency, unsigned long duration);
void play_rtttl(uint8_t _pin, const char *p );
void ArduinoOTAInit();
int calc_CRC16(const String& text);
int calc_CRC16(const char *ptr, int count);
float compute_dew_point_temp(float temperature, float humidity_percentage);
float compute_humidity_from_dewpoint(float temperature, float dew_temperature);
void syslog(byte logLevel, const char *message);
void checkUDP();
void SendUDPCommand(byte destUnit, char* data, byte dataLength);
void sendUDP(byte unit, byte* data, byte size);
void refreshNodeList();
void sendSysInfoUDP(byte repeats);
void SSDP_schema(WiFiClient &client);
bool SSDP_begin();
void SSDP_send(byte method);
void SSDP_update();
bool WiFiConnected(uint32_t timeout_ms);
bool hostReachable(const IPAddress& ip);
bool hostReachable(const String& hostname);
bool beginWiFiUDP_randomPort(WiFiUDP& udp);
void setTimer(unsigned long timerType, unsigned long id, unsigned long msecFromNow);
void setNewTimerAt(unsigned long id, unsigned long timer);
unsigned long getMixedId(unsigned long timerType, unsigned long id);
void handle_schedule();
void setIntervalTimer(unsigned long id);
void setIntervalTimerAt(unsigned long id, unsigned long newtimer);
void setIntervalTimerOverride(unsigned long id, unsigned long msecFromNow);
void scheduleNextDelayQueue(unsigned long id, unsigned long nextTime);
void setIntervalTimer(unsigned long id, unsigned long lasttimer);
void process_interval_timer(unsigned long id, unsigned long lasttimer);
unsigned long createPluginTaskTimerId(byte plugin, int Par1);
void setPluginTaskTimer(unsigned long timer, byte plugin, short taskIndex, int Par1, int Par2, int Par3, int Par4, int Par5);
void process_plugin_task_timer(unsigned long id);
void schedule_task_device_timer_at_init(unsigned long task_index);
void schedule_all_task_device_timers();
void schedule_all_tasks_using_MQTT_controller();
void schedule_task_device_timer(unsigned long task_index, unsigned long runAt);
void process_task_device_timer(unsigned long task_index, unsigned long lasttimer);
void schedule_plugin_task_event_timer(byte DeviceIndex, byte Function, struct EventStruct* event);
void schedule_controller_event_timer(byte ProtocolIndex, byte Function, struct EventStruct* event);
void schedule_notification_event_timer(byte NotificationProtocolIndex, byte Function, struct EventStruct* event);
void schedule_command_timer(const char * cmd, struct EventStruct *event, const char* line);
void schedule_event_timer(PluginPtrType ptr_type, byte Index, byte Function, struct EventStruct* event);
unsigned long createSystemEventMixedId(PluginPtrType ptr_type, uint16_t crc16);
unsigned long createSystemEventMixedId(PluginPtrType ptr_type, byte Index, byte Function);
void process_system_event_queue();
void serial();
unsigned long str2int(char *string);
bool string2float(const String& string, float& floatvalue);
boolean str2ip(const String& string, byte* IP);
boolean str2ip(const char *string, byte* IP);
String formatIP(const IPAddress& ip);
String formatMAC(const uint8_t* mac);
String formatToHex(unsigned long value, const String& prefix);
String formatToHex(unsigned long value);
String formatHumanReadable(unsigned long value, unsigned long factor);
String formatHumanReadable(unsigned long value, unsigned long factor, int NrDecimals);
String formatToHex_decimal(unsigned long value);
String formatToHex_decimal(unsigned long value, unsigned long factor);
String toString(float value, byte decimals);
String toString(WiFiMode_t mode);
String toString(bool value);
String doFormatUserVar(byte TaskIndex, byte rel_index, bool mustCheck, bool& isvalid);
String formatUserVarNoCheck(byte TaskIndex, byte rel_index);
String formatUserVar(byte TaskIndex, byte rel_index, bool& isvalid);
String formatUserVarNoCheck(struct EventStruct *event, byte rel_index);
String formatUserVar(struct EventStruct *event, byte rel_index, bool& isvalid);
String wrap_String(const String& string, const String& wrap);
String to_json_object_value(const String& object, const String& value);
String stripWrappingChar(const String& text, char wrappingChar);
bool stringWrappedWithChar(const String& text, char wrappingChar);
bool isQuoteChar(char c);
bool isParameterSeparatorChar(char c);
String stripQuotes(const String& text);
String parseString(const String& string, byte indexFind, bool toEndOfString, bool toLowerCase);
String parseString(const String& string, byte indexFind);
String parseStringKeepCase(const String& string, byte indexFind);
String parseStringToEnd(const String& string, byte indexFind);
String parseStringToEndKeepCase(const String& string, byte indexFind);
int getParamStartPos(const String& string, byte indexFind);
void htmlEscape(String & html);
void parseControllerVariables(String& s, struct EventStruct *event, boolean useURLencode);
void repl(const String& key, const String& val, String& s, boolean useURLencode);
void parseSpecialCharacters(String& s, boolean useURLencode);
void parseSystemVariables(String& s, boolean useURLencode);
String getReplacementString(const String& format, String& s);
void replSunRiseTimeString(const String& format, String& s, boolean useURLencode);
void replSunSetTimeString(const String& format, String& s, boolean useURLencode);
void parseEventVariables(String& s, struct EventStruct *event, boolean useURLencode);
bool getConvertArgument(const String& marker, const String& s, float& argument, int& startIndex, int& endIndex);
bool getConvertArgument2(const String& marker, const String& s, float& arg1, float& arg2, int& startIndex, int& endIndex);
bool getConvertArgumentString(const String& marker, const String& s, String& argumentString, int& startIndex, int& endIndex);
void parseStandardConversions(String& s, boolean useURLencode);
float sunDeclination(int doy);
float diurnalArc(float dec, float lat);
float equationOfTime(int doy);
int dayOfYear(int year, int month, int day);
void calcSunRiseAndSet();
timeStruct getSunRise(int secOffset);
timeStruct getSunSet(int secOffset);
timeStruct addSeconds(const timeStruct& ts, int seconds, bool toLocalTime);
void breakTime(unsigned long timeInput, struct timeStruct &tm);
void setTime(unsigned long t);
uint32_t getUnixTime();
int getSecOffset(const String& format);
String getSunriseTimeString(char delimiter);
String getSunsetTimeString(char delimiter);
String getSunriseTimeString(char delimiter, int secOffset);
String getSunsetTimeString(char delimiter, int secOffset);
unsigned long now();
int year(unsigned long t);
int weekday(unsigned long t);
int year();
byte month();
byte day();
byte hour();
byte minute();
byte second();
int weekday();
String weekday_str();
void initTime();
void checkTime();
unsigned long getNtpTime();
long timeDiff(const unsigned long prev, const unsigned long next);
long timePassedSince(unsigned long timestamp);
long usecPassedSince(unsigned long timestamp);
boolean timeOutReached(unsigned long timer);
boolean usecTimeOutReached(unsigned long timer);
void setNextTimeInterval(unsigned long& timer, const unsigned long step);
String timeLong2String(unsigned long lngTime);
String getDateString(const timeStruct& ts, char delimiter);
String getDateString(char delimiter);
String getDateString();
String getTimeString(const timeStruct& ts, char delimiter, bool am_pm, bool show_seconds);
String getTimeString(char delimiter, bool show_seconds );
String getTimeString_ampm(char delimiter, bool show_seconds );
String getTimeString();
String getTimeString_ampm();
String getDateTimeString(const timeStruct& ts, char dateDelimiter, char timeDelimiter, char dateTimeDelimiter, bool am_pm);
String getDateTimeString(char dateDelimiter, char timeDelimiter, char dateTimeDelimiter);
String getDateTimeString_ampm(char dateDelimiter, char timeDelimiter, char dateTimeDelimiter);
unsigned long string2TimeLong(const String &str);
boolean matchClockEvent(unsigned long clockEvent, unsigned long clockSet);
void getDefaultDst_flash_values(uint16_t& start, uint16_t& end);
void applyTimeZone(uint32_t curTime);
void setTimeZone(const TimeChangeRule& dstStart, const TimeChangeRule& stdStart, uint32_t curTime);
void logTimeZoneInfo();
uint32_t makeTime(const timeStruct &tm);
uint32_t calcTimeChangeForRule(const TimeChangeRule& r, int yr);
bool calcTimeChanges(int yr);
uint32_t toLocal(uint32_t utc);
bool utcIsDST(uint32_t utc);
bool locIsDST(uint32_t local);
void sendContentBlocking(String& data);
void sendHeaderBlocking(bool json);
boolean ipLessEqual(const IPAddress& ip, const IPAddress& high);
boolean ipInRange(const IPAddress& ip, const IPAddress& low, const IPAddress& high);
String describeAllowedIPrange();
bool getIPallowedRange(IPAddress& low, IPAddress& high);
boolean clientIPallowed();
void clearAccessBlock();
int getFormItemInt(const String &key, int defaultValue);
bool getCheckWebserverArg_int(const String &key, int& value);
bool isFormItemChecked(const String& id);
int getFormItemInt(const String& id);
float getFormItemFloat(const String& id);
bool isFormItem(const String& id);
void addHtmlError(String error);
void addHtml(const String html);
void WebServerInit();
void setWebserverRunning(bool state);
void getWebPageTemplateDefault(const String& tmplName, String& tmpl);
void getErrorNotifications();
void getWebPageTemplateVar(const String& varName );
void writeDefaultCSS(void);
void addHeader(boolean showMenu, String& str);
void addFooter(String& str);
void handle_root();
void handle_config();
void handle_controllers();
void html_TR_TD_highlight();
void html_TR_TD();
void html_BR();
void html_TR_TD_height(int height);
void html_TD();
void html_TD(int td_cnt);
void html_input(const String& displayStr, const String& intString, int size, const String& value);
void handle_notifications();
void handle_hardware();
void addFormPinStateSelect(const String& label, const String& id, int choice);
void addPinStateSelect(String name, int choice);
void addFormIPaccessControlSelect(const String& label, const String& id, int choice);
void addIPaccessControlSelect(String name, int choice);
void handle_devices();
void addDeviceSelect(String name, int choice);
void switchArray(byte value);
boolean arrayLessThan(const String& ptr_1, const String& ptr_2);
void sortDeviceArray();
void addFormPinSelect(const String& label, const String& id, int choice);
void addFormPinSelectI2C(const String& label, const String& id, int choice);
void addPinSelect(boolean forI2C, String name, int choice);
void addPinSelect(boolean forI2C, String name, int choice);
void addPinSelect(boolean forI2C, String name, int choice);
void renderHTMLForPinSelect(String options[], int optionValues[], boolean forI2C, String name, int choice, int count);
void addFormSelectorI2C(const String& id, int addressCount, const int addresses[], int selectedIndex);
void addFormSelector(const String& label, const String& id, int optionCount, const String options[], const int indices[], int selectedIndex);
void addFormSelector(const String& label, const String& id, int optionCount, const String options[], const int indices[], const String attr[], int selectedIndex, boolean reloadonchange);
void addSelector(const String& id, int optionCount, const String options[], const int indices[], const String attr[], int selectedIndex, boolean reloadonchange);
void addSelector_Head(const String& id, boolean reloadonchange);
void addSelector_Item(const String& option, int index, boolean selected, boolean disabled, const String& attr);
void addSelector_Foot();
void addUnit(const String& unit);
void addRowLabel(const String& label);
void addButton(const String &url, const String &label);
void addWideButton(const String &url, const String &label, const String &color);
void addSubmitButton();
void addSubmitButton(const String &value, const String &name);
void addCopyButton(const String &value, const String &delimiter, const String &name);
void addTableSeparator(const String& label, int colspan, int h_size);
void addTableSeparator(const String& label, int colspan, int h_size, const String& helpButton);
void addFormHeader(const String& header1, const String& header2);
void addFormHeader(const String& header);
void addFormSubHeader(const String& header);
void addFormNote(const String& text);
void addFormSeparator(int clspan);
void addCheckBox(const String& id, boolean checked);
void addFormCheckBox(const String& label, const String& id, boolean checked);
void addNumericBox(const String& id, int value, int min, int max);
void addNumericBox(const String& id, int value);
void addFormNumericBox(const String& label, const String& id, int value, int min, int max);
void addFormNumericBox(const String& label, const String& id, int value);
void addFloatNumberBox(const String& id, float value, float min, float max);
void addFormFloatNumberBox(const String& label, const String& id, float value, float min, float max);
void addTextBox(const String& id, const String& value, int maxlength);
void addFormTextBox(const String& label, const String& id, const String& value, int maxlength);
void addFormPasswordBox(const String& label, const String& id, const String& password, int maxlength);
void copyFormPassword(const String& id, char* pPassword, int maxlength);
void addFormIPBox(const String& label, const String& id, const byte ip[4]);
void addHelpButton(const String& url);
void addEnabled(boolean enabled);
void addTaskSelect(String name, int choice);
void addTaskValueSelect(String name, int choice, byte TaskIndex);
void handle_log();
void handle_log_JSON();
void handle_tools();
void handle_pinstates();
void handle_i2cscanner();
void handle_wifiscanner();
void handle_login();
void handle_control();
void stream_to_json_object_value(const String& object, const String& value);
String jsonBool(bool value);
void stream_next_json_object_value(const String& object, const String& value);
void stream_last_json_object_value(const String& object, const String& value);
void handle_json();
void handle_advanced();
void addFormDstSelect(bool isStart, uint16_t choice);
void addFormLogLevelSelect(const String& label, const String& id, int choice);
void addLogLevelSelect(String name, int choice);
void addFormLogFacilitySelect(const String& label, const String& id, int choice);
void addLogFacilitySelect(String name, int choice);
boolean isLoggedIn();
void handle_download();
void handle_upload();
void handle_upload_post();
void handleFileUpload();
bool loadFromFS(boolean spiffs, String path);
boolean handle_custom(String path);
void handle_filelist();
void handle_SDfilelist();
void handleNotFound();
void handle_setup();
void handle_rules();
void handle_sysinfo();
void addSysVar_html(const String& input);
void handle_sysvars();
String URLEncode(const char* msg);
String getControllerSymbol(byte index);
String getValueSymbol(byte index);
void handle_favicon();
void createSvgRectPath(unsigned int color, int xoffset, int yoffset, int size, int height, int range, float SVG_BAR_WIDTH);
void createSvgTextElement(const String& text, float textXoffset, float textYoffset);
unsigned int getSettingsTypeColor(SettingsType settingsType);
void write_SVG_image_header(int width, int height);
void getConfig_dat_file_layout();
void getStorageTableSVG(SettingsType settingsType);
int getPartionCount(byte pType);
void getPartitionTableSVG(byte pType, unsigned int partitionColor);
boolean CPlugin_001(byte function, struct EventStruct *event, String& string);
bool do_process_c001_delay_queue(int controller_number, const C001_queue_element& element, ControllerSettingsStruct& ControllerSettings);
boolean CPlugin_002(byte function, struct EventStruct *event, String& string);
boolean CPlugin_003(byte function, struct EventStruct *event, String& string);
bool do_process_c003_delay_queue(int controller_number, const C003_queue_element& element, ControllerSettingsStruct& ControllerSettings);
boolean CPlugin_004(byte function, struct EventStruct *event, String& string);
bool do_process_c004_delay_queue(int controller_number, const C004_queue_element& element, ControllerSettingsStruct& ControllerSettings);
boolean CPlugin_005(byte function, struct EventStruct *event, String& string);
boolean CPlugin_006(byte function, struct EventStruct *event, String& string);
boolean CPlugin_007(byte function, struct EventStruct *event, String& string);
bool do_process_c007_delay_queue(int controller_number, const C007_queue_element& element, ControllerSettingsStruct& ControllerSettings);
boolean CPlugin_008(byte function, struct EventStruct *event, String& string);
bool do_process_c008_delay_queue(int controller_number, const C008_queue_element& element, ControllerSettingsStruct& ControllerSettings);
boolean CPlugin_009(byte function, struct EventStruct *event, String& string);
bool do_process_c009_delay_queue(int controller_number, const C009_queue_element& element, ControllerSettingsStruct& ControllerSettings);
boolean CPlugin_010(byte function, struct EventStruct *event, String& string);
bool do_process_c010_delay_queue(int controller_number, const C010_queue_element& element, ControllerSettingsStruct& ControllerSettings);
boolean CPlugin_011(byte function, struct EventStruct *event, String& string);
bool do_process_c011_delay_queue(int controller_number, const C011_queue_element& element, ControllerSettingsStruct& ControllerSettings);
boolean Create_schedule_HTTP_C011(struct EventStruct *event);
void DeleteNotNeededValues(String &s, byte numberOfValuesWanted);
void ReplaceTokenByValue(String& s, struct EventStruct *event);
boolean CPlugin_012(byte function, struct EventStruct *event, String& string);
bool do_process_c012_delay_queue(int controller_number, const C012_queue_element& element, ControllerSettingsStruct& ControllerSettings);
boolean Blynk_get(const String& command, byte controllerIndex, float *data );
boolean CPlugin_013(byte function, struct EventStruct *event, String& string);
void C013_SendUDPTaskInfo(byte destUnit, byte sourceTaskIndex, byte destTaskIndex);
void C013_SendUDPTaskData(byte destUnit, byte sourceTaskIndex, byte destTaskIndex);
void C013_sendUDP(byte unit, byte* data, byte size);
void C013_Receive(struct EventStruct *event);
String humStatDomoticz(struct EventStruct *event, byte rel_index);
int mapRSSItoDomoticz();
int mapVccToDomoticz();
String formatUserVarDomoticz(struct EventStruct *event, byte rel_index);
String formatUserVarDomoticz(int value);
String formatDomoticzSensorType(struct EventStruct *event);
byte getValueCountFromSensorType(byte sensorType);
boolean NPlugin_001(byte function, struct EventStruct *event, String& string);
boolean NPlugin_001_send(const NotificationSettingsStruct& notificationsettings, const String& aSub, String& aMesg);
boolean NPlugin_001_Auth(WiFiClient& client, String user, String pass);
boolean NPlugin_001_MTA(WiFiClient& client, String aStr, const String &aWaitForPattern);
bool getNextMailAddress(const String& data, String& address, int index);
boolean NPlugin_002(byte function, struct EventStruct *event, String& string);
boolean Plugin_001_read_switch_state(struct EventStruct *event);
boolean Plugin_001(byte function, struct EventStruct *event, String& string);
void analogWriteESP32(int pin, int value);
byte P001_getSwitchType(struct EventStruct *event);
boolean Plugin_002(byte function, struct EventStruct *event, String& string);
boolean Plugin_003(byte function, struct EventStruct *event, String& string);
void Plugin_003_pulsecheck(byte Index);
void Plugin_003_pulse_interrupt1();
void Plugin_003_pulse_interrupt2();
void Plugin_003_pulse_interrupt3();
void Plugin_003_pulse_interrupt4();
void Plugin_003_pulse_interrupt5();
void Plugin_003_pulse_interrupt6();
void Plugin_003_pulse_interrupt7();
void Plugin_003_pulse_interrupt8();
bool Plugin_003_pulseinit(byte Par1, byte Index, byte Mode);
boolean Plugin_004(byte function, struct EventStruct * event, String& string);
void Plugin_004_get_addr(uint8_t addr[], byte TaskIndex);
byte Plugin_004_DS_scan(byte getDeviceROM, uint8_t* ROM);
void Plugin_004_DS_startConvertion(uint8_t ROM[8]);
boolean Plugin_004_DS_readTemp(uint8_t ROM[8], float * value);
int Plugin_004_DS_getResolution(uint8_t ROM[8]);
boolean Plugin_004_DS_setResolution(uint8_t ROM[8], byte res);
uint8_t Plugin_004_DS_reset();
void Plugin_004_DS_reset_search();
uint8_t Plugin_004_DS_search(uint8_t * newAddr);
uint8_t Plugin_004_DS_read(void);
void Plugin_004_DS_write(uint8_t ByteToWrite);
uint8_t Plugin_004_DS_read_bit(void);
void Plugin_004_DS_write_bit(uint8_t v);
boolean Plugin_004_DS_crc8(uint8_t * addr);
boolean Plugin_005(byte function, struct EventStruct *event, String& string);
void logError(struct EventStruct *event, String text);
boolean waitState(int state);
int Plugin_005_read_dht_dat(void);
boolean Plugin_006(byte function, struct EventStruct *event, String& string);
boolean Plugin_006_bmp085_begin();
uint16_t Plugin_006_bmp085_readRawTemperature(void);
uint32_t Plugin_006_bmp085_readRawPressure(void);
int32_t Plugin_006_bmp085_readPressure(void);
float Plugin_006_bmp085_readTemperature(void);
float Plugin_006_pressureElevation(float atmospheric, int altitude);
boolean Plugin_007(byte function, struct EventStruct *event, String& string);
boolean Plugin_008(byte function, struct EventStruct *event, String& string);
void Plugin_008_interrupt1();
void Plugin_008_interrupt2();
boolean Plugin_009(byte function, struct EventStruct *event, String& string);
int Plugin_009_Read(byte Par1);
boolean Plugin_009_Write(byte Par1, byte Par2);
void Plugin_009_Config(byte Par1, byte Par2);
boolean Plugin_010(byte function, struct EventStruct *event, String& string);
boolean Plugin_011(byte function, struct EventStruct *event, String& string);
int Plugin_011_Read(byte Par1, byte Par2);
void Plugin_011_Write(byte Par1, byte Par2);
boolean Plugin_012(byte function, struct EventStruct *event, String& string);
String P012_parseTemplate(String &tmpString, byte lineSize);
boolean Plugin_013(byte function, struct EventStruct *event, String& string);
float Plugin_013_read(unsigned int taskIndex);
boolean Plugin_014(byte function, struct EventStruct *event, String& string);
boolean Plugin_014_si7021_begin(uint8_t resolution);
uint8_t Plugin_014_si7021_checkCRC(uint16_t data, uint8_t check);
int8_t Plugin_014_si7021_readRegister(uint8_t * value);
int8_t Plugin_014_si7021_startConv(uint8_t datatype, uint8_t resolution);
int8_t Plugin_014_si7021_readValues(uint8_t resolution);
int8_t Plugin_014_si7021_setResolution(uint8_t res);
boolean plugin_015_begin();
boolean plugin_015_setPowerUp(void);
boolean plugin_015_setPowerDown(void);
boolean Plugin_015(byte function, struct EventStruct *event, String& string);
boolean Plugin_016(byte function, struct EventStruct *event, String& string);
boolean Plugin_017(byte function, struct EventStruct *event, String& string);
boolean Plugin_017_Init(int8_t resetPin);
uint32_t getFirmwareVersion(void);
void Plugin_017_powerDown(void);
byte Plugin_017_readPassiveTargetID(uint8_t cardbaudrate, uint8_t *uid, uint8_t *uidLength);
int8_t Plugin_017_writeCommand(const uint8_t *header, uint8_t hlen);
int16_t Plugin_017_readResponse(uint8_t buf[], uint8_t len);
int8_t Plugin_017_readAckFrame();
boolean Plugin_018(byte function, struct EventStruct *event, String& string);
boolean Plugin_019(byte function, struct EventStruct *event, String& string);
int Plugin_019_Read(byte Par1);
boolean Plugin_019_Write(byte Par1, byte Par2);
boolean Plugin_020(byte function, struct EventStruct *event, String& string);
boolean Plugin_021(byte function, struct EventStruct *event, String& string);
boolean Plugin_022(byte function, struct EventStruct *event, String& string);
void Plugin_022_writeRegister(int i2cAddress, int regAddress, byte data);
uint8_t Plugin_022_readRegister(int i2cAddress, int regAddress);
void Plugin_022_Off(int address, int pin);
void Plugin_022_On(int address, int pin);
void Plugin_022_Write(int address, int Par1, int Par2);
void Plugin_022_Frequency(int address, uint16_t freq);
void Plugin_022_initialize(int address);
boolean Plugin_023(byte function, struct EventStruct *event, String& string);
String P023_parseTemplate(String &tmpString, byte lineSize);
void Plugin_023_reset_display(struct Plugin_023_OLED_SettingStruct &oled);
void Plugin_023_StartUp_OLED(struct Plugin_023_OLED_SettingStruct &oled);
void Plugin_023_displayOn(struct Plugin_023_OLED_SettingStruct &oled);
void Plugin_023_displayOff(struct Plugin_023_OLED_SettingStruct &oled);
void Plugin_023_clear_display(struct Plugin_023_OLED_SettingStruct &oled);
void Plugin_023_SendChar(struct Plugin_023_OLED_SettingStruct &oled, unsigned char data);
void Plugin_023_sendcommand(byte address, unsigned char com);
void Plugin_023_setXY(struct Plugin_023_OLED_SettingStruct &oled, unsigned char row, unsigned char col);
void Plugin_023_sendStrXY(struct Plugin_023_OLED_SettingStruct &oled, const char *string, int X, int Y);
void Plugin_023_init_OLED(struct Plugin_023_OLED_SettingStruct &oled);
uint16_t readRegister024(uint8_t i2cAddress, uint8_t reg);
float readTemp024(uint8_t i2c_addr, uint8_t i2c_reg);
boolean Plugin_024(byte function, struct EventStruct *event, String& string);
uint16_t readRegister025(uint8_t i2cAddress, uint8_t reg);
boolean Plugin_025(byte function, struct EventStruct *event, String& string);
boolean Plugin_026(byte function, struct EventStruct *event, String& string);
uint8_t Plugin_027_i2c_addr(struct EventStruct *event);
uint8_t Plugin_027_device_index(const uint8_t i2caddr);
boolean Plugin_027(byte function, struct EventStruct *event, String& string);
void Plugin_027_wireWriteRegister (uint8_t i2caddr, uint8_t reg, uint16_t value);
void Plugin_027_wireReadRegister(uint8_t i2caddr, uint8_t reg, uint16_t *value);
void Plugin_027_setCalibration_32V_2A(uint8_t i2caddr);
void Plugin_027_setCalibration_32V_1A(uint8_t i2caddr);
void Plugin_027_setCalibration_16V_400mA(uint8_t i2caddr);
int16_t Plugin_027_getBusVoltage_raw(uint8_t i2caddr);
int16_t Plugin_027_getShuntVoltage_raw(uint8_t i2caddr);
int16_t Plugin_027_getCurrent_raw(uint8_t i2caddr);
float Plugin_027_getShuntVoltage_mV(uint8_t i2caddr);
float Plugin_027_getBusVoltage_V(uint8_t i2caddr);
float Plugin_027_getCurrent_mA(uint8_t i2caddr);
uint8_t Plugin_028_i2c_addr(struct EventStruct *event);
boolean Plugin_028(byte function, struct EventStruct *event, String& string);
bool Plugin_028_update_measurements(const uint8_t i2cAddress, float tempOffset, unsigned long task_index);
bool Plugin_028_check(uint8_t i2cAddress);
bool Plugin_028_begin(uint8_t i2cAddress);
void Plugin_028_readCoefficients(uint8_t i2cAddress);
bool Plugin_028_readUncompensatedData(uint8_t i2cAddress);
float Plugin_028_readTemperature(uint8_t i2cAddress);
float Plugin_028_readPressure(uint8_t i2cAddress);
float Plugin_028_readHumidity(uint8_t i2cAddress);
float Plugin_028_readAltitude(uint8_t i2cAddress, float seaLevel);
float Plugin_028_pressureElevation(float atmospheric, int altitude);
boolean Plugin_029(byte function, struct EventStruct *event, String& string);
boolean Plugin_030(byte function, struct EventStruct *event, String& string);
bool Plugin_030_check(uint8_t a);
bool Plugin_030_begin(uint8_t a);
void Plugin_030_readCoefficients(uint8_t idx);
float Plugin_030_readTemperature(uint8_t idx);
float Plugin_030_readPressure(uint8_t idx);
float Plugin_030_readAltitude(float seaLevel);
float Plugin_030_pressureElevation(float atmospheric, int altitude);
boolean Plugin_031(byte function, struct EventStruct *event, String& string);
float Plugin_031_readTemperature();
float Plugin_031_readRelHumidity(float tempC);
void Plugin_031_reset();
byte Plugin_031_readStatus();
void Plugin_031_sendCommand(const byte cmd);
void Plugin_031_awaitResult();
int Plugin_031_readData(const int bits);
boolean Plugin_032(byte function, struct EventStruct *event, String& string);
bool Plugin_032_begin(uint8_t a);
void Plugin_032_read_prom();
unsigned long Plugin_032_read_adc(unsigned char aCMD);
void Plugin_032_readout();
double Plugin_032_pressureElevation(double atmospheric, int altitude);
boolean Plugin_033(byte function, struct EventStruct *event, String& string);
boolean Plugin_034(byte function, struct EventStruct *event, String& string);
boolean Plugin_035(byte function, struct EventStruct *event, String& string);
void parseStringAndSendAirCon(const uint16_t irType, const String str);
void parseStringAndSendPronto(const String str, uint16_t repeats);
void parseStringAndSendGC(const String str);
uint16_t countValuesInStr(const String str, char sep);
boolean Plugin_036(byte function, struct EventStruct *event, String& string);
void P36_setContrast(uint8_t OLED_contrast);
String P36_parseTemplate(String &tmpString, byte lineSize);
void display_header();
void display_time();
void display_title(String& title);
void display_logo();
void display_indicator(int iframe, int frameCount);
void display_scroll(String outString[], String inString[], int nlines, int scrollspeed);
bool display_wifibars();
String getClientName();
void Plugin_037_try_connect();
void Plugin_037_update_connect_status();
boolean Plugin_037(byte function, struct EventStruct *event, String& string);
boolean MQTTSubscribe_037();
void mqttcallback_037(char* c_topic, byte* b_payload, unsigned int length);
boolean MQTTConnect_037();
boolean MQTTCheckSubscription_037(String Topic, String Subscription);
boolean Plugin_038(byte function, struct EventStruct *event, String& string);
boolean Plugin_039(byte function, struct EventStruct *event, String& string);
double readMax6675();
double readMax31855();
int Plugin_039_convert_two_complement(uint32_t value, int nr_bits);
boolean Plugin_040(byte function, struct EventStruct *event, String& string);
boolean Plugin_041(byte function, struct EventStruct *event, String& string);
void Plugin_041_update();
void resetAndBlack();
void pushToStrip(int ledId);
void timeToStrip(uint8_t hours, uint8_t minutes);
void pushM_ONE();
void pushM_TWO();
void pushM_THREE();
void pushM_FOUR();
void pushIT_IS();
void pushAFTER();
void pushQUATER();
void pushFOR();
void pushHALF();
void pushONE();
void pushTWO();
void pushTHREE();
void pushFOUR();
void pushFIVE1();
void pushFIVE2();
void pushSIX();
void pushSEVEN();
void pushEIGHT();
void pushNINE();
void pushTEN();
void pushTEN1();
void pushELEVEN();
void pushTWELVE();
void pushTWENTY();
void pushHOURE();
boolean Plugin_042(byte function, struct EventStruct *event, String& string);
void SetPixelsBlack();
void SetPixelToColor(int PixelIdx);
void type_Off();
void type_Static_Light();
void type_Simple_Candle();
void type_Advanced_Candle();
void type_Police();
void type_BlinkStrobe();
void type_ColorFader();
void HSVtoRGB(int hue, int sat, int val, int colors[3]);
void RGBtoHSV(byte r, byte g, byte b, double hsv[3]);
boolean Plugin_043(byte function, struct EventStruct *event, String& string);
boolean Plugin_044(byte function, struct EventStruct *event, String& string);
void blinkLED();
bool validP1char(char ch);
int FindCharInArrayRev(char array[], char c, int len);
unsigned int CRC16(unsigned int crc, unsigned char *buf, int len);
bool checkDatagram(int len);
boolean Plugin_045(byte function, struct EventStruct *event, String& string);
void _P045_trackMinMax(int16_t current, int16_t *min, int16_t *max);
void _P045_getMotion6(uint8_t devAddr, int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz);
void _P045_writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data);
boolean Plugin_046(byte function, struct EventStruct *event, String& string);
void Plugin_046_ISR_nSEL();
void Plugin_046_ISR_SCLK();
boolean Plugin_047(byte function, struct EventStruct *event, String& string);
float Plugin_047_readTemperature();
float Plugin_047_readLight();
unsigned int Plugin_047_readMoisture();
uint8_t Plugin_047_getVersion();
bool Plugin_047_setAddress(int addr);
boolean Plugin_048(byte function, struct EventStruct *event, String& string);
boolean Plugin_049_Check_and_ApplyFilter(unsigned int prevVal, unsigned int &newVal, uint32_t s, const int filterValue, String& log);
boolean Plugin_049(byte function, struct EventStruct *event, String& string);
byte _P049_calculateChecksum(byte *array);
size_t _P049_send_mhzCmd(byte CommandId);
boolean Plugin_050(byte function, struct EventStruct *event, String& string);
boolean Plugin_051(byte function, struct EventStruct *event, String& string);
boolean Plugin_052(byte function, struct EventStruct *event, String& string);
void Plugin_052_buildFrame(byte slaveAddress,
              byte functionCode,
              short startAddress,
              short numberOfRegisters,
              byte frame[8]);
int Plugin_052_sendCommand(byte command[]);
int Plugin_052_readErrorStatus(void);
int Plugin_052_readCo2(void);
float Plugin_052_readTemperature(void);
float Plugin_052_readRelativeHumidity(void);
int Plugin_052_readRelayStatus(void);
int Plugin_052_readTemperatureAdjustment(void);
void Plugin_052_setRelayStatus(int status);
int Plugin_052_readABCperiod(void);
unsigned int Plugin_052_ModRTU_CRC(byte buf[], int len, byte checkSum[2]);
int getBitOfInt(int reg, int pos);
void SerialRead16(uint16_t* value, uint16_t* checksum);
void SerialFlush();
boolean PacketAvailable(void);
boolean Plugin_053_process_data(struct EventStruct *event);
boolean Plugin_053(byte function, struct EventStruct *event, String& string);
boolean Plugin_054(byte function, struct EventStruct *event, String& string);
boolean Plugin_055(byte function, struct EventStruct *event, String& string);
void Plugin_055_WriteFIFO(char c);
char Plugin_055_ReadFIFO();
char Plugin_055_PeekFIFO();
boolean Plugin_055_IsEmptyFIFO();
void Plugin_055_AddStringFIFO(const String& param);
void Plugin_055_WriteChime(const String& name, const String& tokens);
byte Plugin_055_ReadChime(const String& name, String& tokens);
boolean Plugin_056(byte function, struct EventStruct *event, String& string);
boolean Plugin_056_hasTxPin(struct EventStruct *event);
String Plugin_056_ErrorToString(int error);
String Plugin_056_WorkingPeriodToString(int workingPeriod);
void Plugin_056_setWorkingPeriod(int minutes);
boolean Plugin_057(byte function, struct EventStruct *event, String& string);
boolean Plugin_058(byte function, struct EventStruct *event, String& string);
boolean Plugin_059(byte function, struct EventStruct *event, String& string);
uint16_t readMCP3221(byte addr);
boolean Plugin_060(byte function, struct EventStruct *event, String& string);
boolean Plugin_061(byte function, struct EventStruct *event, String& string);
void MCP23017_setReg(byte addr, byte reg, byte data);
byte MCP23017_getReg(byte addr, byte reg);
void MCP23017_KeyPadMatrixInit(byte addr);
byte MCP23017_KeyPadMatrixScan(byte addr);
void PCF8574_setReg(byte addr, byte data);
byte PCF8574_getReg(byte addr);
void PCF8574_KeyPadMatrixInit(byte addr);
byte PCF8574_KeyPadMatrixScan(byte addr);
void PCF8574_KeyPadDirectInit(byte addr);
byte PCF8574_KeyPadDirectScan(byte addr);
boolean Plugin_062(byte function, struct EventStruct *event, String& string);
uint16_t readTTP229(int16_t pinSCL, int16_t pinSDO);
boolean Plugin_063(byte function, struct EventStruct *event, String& string);
boolean Plugin_064(byte function, struct EventStruct *event, String& string);
boolean Plugin_065(byte function, struct EventStruct *event, String& string);
void Plugin_065_Play(uint16_t track);
void Plugin_065_SetVol(int8_t vol);
void Plugin_065_SetEQ(int8_t eq);
void Plugin_065_SendCmd(byte cmd, int16_t data);
boolean Plugin_066(byte function, struct EventStruct *event, String& string);
void VEML6040_setControlReg(byte data);
float VEML6040_GetValue(byte reg);
void VEML6040_Init(byte it);
float Plugin_066_CalcCCT(float R, float G, float B);
float Plugin_066_CalcAmbientLight(float G, byte it);
float Plugin_066_CalcRelW(float X, float W);
void initHX711(int16_t pinSCL, int16_t pinDOUT);
boolean isReadyHX711(int16_t pinSCL, int16_t pinDOUT);
int32_t readHX711(int16_t pinSCL, int16_t pinDOUT, uint8_t mode);
boolean Plugin_067(byte function, struct EventStruct *event, String& string);
boolean Plugin_068(byte function, struct EventStruct *event, String& string);
boolean Plugin_069(byte function, struct EventStruct *event, String& string);
boolean Plugin_070(byte function, struct EventStruct *event, String& string);
void Clock_update();
void calculateMarks();
void clearClock();
void timeToStrip(int hours, int minutes, int seconds);
boolean Plugin_071(byte function, struct EventStruct *event, String& string);
bool parity_check(unsigned input);
boolean Plugin_072(byte function, struct EventStruct *event, String& string);
boolean Plugin_073(byte function, struct EventStruct *event, String& string);
void p073_FillBufferWithTime(void);
void p073_FillBufferWithDate(void);
void p073_FillBufferWithNumber(String number);
void p073_FillBufferWithTemp(long temperature);
void p073_FillBufferWithDash(void);
void tm1637_i2cStart (void);
void tm1637_i2cStop (void);
void tm1637_i2cAck (void);
void tm1637_i2cWrite (uint8_t bytetoprint);
void tm1637_ClearDisplay (void);
void tm1637_SetPowerBrightness (uint8_t brightlvl, bool poweron);
void tm1637_InitDisplay(void);
void tm1637_ShowTime6(bool sep);
void tm1637_ShowDate6(bool sep);
void tm1637_ShowTemp6(bool sep);
void tm1637_ShowTimeTemp4(bool sep, byte bufoffset);
void tm1637_SwapDigitInBuffer();
void tm1637_ShowBuffer(byte digits);
void max7219_spiTransfer (byte opcode, byte data);
void max7219_ClearDisplay (void);
void max7219_SetPowerBrightness (uint8_t brightlvl, bool poweron);
void max7219_SetDigit(int dgtpos, byte dgtvalue, boolean showdot);
void max7219_InitDisplay(void);
void max7219_ShowTime(bool sep);
void max7219_ShowTemp(void);
void max7219_ShowDate(void);
void max7219_ShowBuffer(void);
uint8_t get_byte_CharTableTM1637(uint8_t index);
boolean Plugin_074(byte function, struct EventStruct *event, String& string);
boolean Plugin_075(byte function, struct EventStruct *event, String& string);
void sendCommand(const char *cmd, boolean SerialMode);
boolean Plugin_076(byte function, struct EventStruct *event, String& string);
void Plugin076_SaveMultipliers();
boolean Plugin_077(byte function, struct EventStruct *event, String& string);
void CseReceived(struct EventStruct *event);
boolean Plugin_078(byte function, struct EventStruct *event, String& string);
boolean Plugin_079(byte function, struct EventStruct *event, String& string);
boolean Plugin_080(byte function, struct EventStruct * event, String& string);
void Plugin_080_get_addr(uint8_t addr[], byte TaskIndex);
byte Plugin_080_DS_scan(byte getDeviceROM, uint8_t* ROM);
void Plugin_080_DS_startConvertion(uint8_t ROM[8]);
uint8_t Plugin_080_DS_reset();
void Plugin_080_DS_reset_search();
uint8_t Plugin_080_DS_search(uint8_t * newAddr);
uint8_t Plugin_080_DS_read(void);
void Plugin_080_DS_write(uint8_t ByteToWrite);
uint8_t Plugin_080_DS_read_bit(void);
boolean Plugin_080_DS_readiButton(byte addr[8]);
void Plugin_080_DS_write_bit(uint8_t v);
boolean Plugin_080_DS_crc8(uint8_t * addr);
boolean Plugin_220(byte function, struct EventStruct *event, String& string);
String getSerialNumber(int netAdr);
float* getPowerNow(int netAdr, int length_resp);
float* getCurrent(int netAdr,byte cmdget[], int length_resp);
float getEnergyMT(int netAdr,byte cmdget[], int length_resp);
void send(byte *cmd, int s, byte *response);
unsigned int crc16MODBUS(byte *s, int count);
void ReportStatus();
void CPluginInit(void);
byte CPluginCall(byte Function, struct EventStruct *event);
bool anyControllerEnabled();
byte findFirstEnabledControllerWithId(byte cpluginid);
void NPluginInit(void);
byte NPluginCall(byte Function, struct EventStruct *event);
void PluginInit(void);
int getPluginId(byte taskId);
void updateTaskPluginCache();
byte PluginCall(byte Function, struct EventStruct *event, String& str);
#line 183 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
int firstEnabledBlynkController() {

  for (byte i = 0; i < CONTROLLER_MAX; ++i) {

    byte ProtocolIndex = getProtocolIndex(Settings.Protocol[i]);

    if (Protocol[ProtocolIndex].Number == 12 && Settings.ControllerEnabled[i]) {

      return i;

    }

  }

  return -1;

}
# 213 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
void setup()

{

  WiFi.persistent(false);

  WiFi.setAutoReconnect(false);

  setWifiMode(WIFI_OFF);



  Plugin_id.resize(PLUGIN_MAX);

  Task_id_to_Plugin_id.resize(TASKS_MAX);



  checkRAM(F("setup"));

  #if defined(ESP32)

    for(byte x = 0; x < 16; x++)

      ledChannelPin[x] = -1;

  #endif



  lowestRAM = FreeMem();



  Serial.begin(115200);





  initLog();



#if defined(ESP32)

  WiFi.onEvent(WiFiEvent);

#else



  stationConnectedHandler = WiFi.onStationModeConnected(onConnected);

 stationDisconnectedHandler = WiFi.onStationModeDisconnected(onDisconnect);

 stationGotIpHandler = WiFi.onStationModeGotIP(onGotIP);

  APModeStationConnectedHandler = WiFi.onSoftAPModeStationConnected(onConnectedAPmode);

  APModeStationDisconnectedHandler = WiFi.onSoftAPModeStationDisconnected(onDisonnectedAPmode);

#endif



  if (SpiffsSectors() < 32)

  {

    Serial.println(F("\nNo (or too small) SPIFFS area..\nSystem Halted\nPlease reflash with 128k SPIFFS minimum!"));

    while (true)

      delay(1);

  }



  emergencyReset();



  String log = F("\n\n\rINIT : Booting version: ");

  log += BUILD_GIT;

  log += F(" (");

  log += getSystemLibraryString();

  log += F(")");

  addLog(LOG_LEVEL_INFO, log);
# 317 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
  if (readFromRTC())

  {

    RTC.bootFailedCount++;

    RTC.bootCounter++;

    readUserVarFromRTC();



    if (RTC.deepSleepState == 1)

    {

      log = F("INIT : Rebooted from deepsleep #");

      lastBootCause=BOOT_CAUSE_DEEP_SLEEP;

    }

    else

      log = F("INIT : Warm boot #");



    log += RTC.bootCounter;



  }



  else

  {

    initRTC();





    if (lastBootCause == BOOT_CAUSE_MANUAL_REBOOT)

      lastBootCause = BOOT_CAUSE_COLD_BOOT;

    log = F("INIT : Cold Boot");

  }

  log += F(" - Restart Reason: ");

  log += getResetReasonString();



  RTC.deepSleepState=0;

  saveToRTC();



  addLog(LOG_LEVEL_INFO, log);



  fileSystemCheck();

  progMemMD5check();

  LoadSettings();

  if (RTC.bootFailedCount > 10 && RTC.bootCounter > 10) {

    byte toDisable = RTC.bootFailedCount - 10;

    toDisable = disablePlugin(toDisable);

    if (toDisable != 0) {

      toDisable = disableController(toDisable);

    }

    if (toDisable != 0) {

      toDisable = disableNotification(toDisable);

    }

  }





  checkRuleSets();







  if (Settings.Version != VERSION || Settings.PID != ESP_PROJECT_PID)

  {



    Serial.print(F("\nPID:"));

    Serial.println(Settings.PID);

    Serial.print(F("Version:"));

    Serial.println(Settings.Version);

    Serial.println(F("INIT : Incorrect PID or version!"));

    delay(1000);

    ResetFactory();

  }



  if (Settings.UseSerial)

  {



    Serial.flush();

    Serial.begin(Settings.BaudRate);



  }



  if (Settings.Build != BUILD)

    BuildFixes();





  log = F("INIT : Free RAM:");

  log += FreeMem();

  addLog(LOG_LEVEL_INFO, log);



  if (Settings.UseSerial && Settings.SerialLogLevel >= LOG_LEVEL_DEBUG_MORE)

    Serial.setDebugOutput(true);



  checkRAM(F("hardwareInit"));

  hardwareInit();



  timermqtt_interval = 250;

  timerAwakeFromDeepSleep = millis();



  PluginInit();

  CPluginInit();

  NPluginInit();

  log = F("INFO : Plugins: ");

  log += deviceCount + 1;

  log += getPluginDescriptionString();

  log += F(" (");

  log += getSystemLibraryString();

  log += F(")");

  addLog(LOG_LEVEL_INFO, log);



  if (deviceCount + 1 >= PLUGIN_MAX) {

    addLog(LOG_LEVEL_ERROR, F("Programming error! - Increase PLUGIN_MAX"));

  }



  if (Settings.UseRules)

  {

    String event = F("System#Wake");

    rulesProcessing(event);

  }



  if (!selectValidWiFiSettings()) {

    wifiSetup = true;

  }
# 563 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
  WiFiConnectRelaxed();



  #ifdef FEATURE_REPORTING

  ReportStatus();

  #endif



  #ifdef FEATURE_ARDUINO_OTA

  ArduinoOTAInit();

  #endif





  if (Settings.UDPPort != 0)

    portUDP.begin(Settings.UDPPort);



  sendSysInfoUDP(3);



  if (Settings.UseNTP)

    initTime();



#if FEATURE_ADC_VCC

  vcc = ESP.getVcc() / 1000.0;

#endif



  if (Settings.UseRules)

  {

    String event = F("System#Boot");

    rulesProcessing(event);

  }



  writeDefaultCSS();



  UseRTOSMultitasking = Settings.UseRTOSMultitasking;

  #ifdef USE_RTOS_MULTITASKING

    if(UseRTOSMultitasking){

      log = F("RTOS : Launching tasks");

      addLog(LOG_LEVEL_INFO, log);

      xTaskCreatePinnedToCore(RTOS_TaskServers, "RTOS_TaskServers", 8192, NULL, 1, NULL, 1);

      xTaskCreatePinnedToCore(RTOS_TaskSerial, "RTOS_TaskSerial", 8192, NULL, 1, NULL, 1);

      xTaskCreatePinnedToCore(RTOS_Task10ps, "RTOS_Task10ps", 8192, NULL, 1, NULL, 1);

    }

  #endif
# 661 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
  setIntervalTimerOverride(TIMER_20MSEC, 5);

  setIntervalTimerOverride(TIMER_100MSEC, 66);

  setIntervalTimerOverride(TIMER_1SEC, 777);

  setIntervalTimerOverride(TIMER_30SEC, 1333);

  setIntervalTimerOverride(TIMER_MQTT, 88);

  setIntervalTimerOverride(TIMER_STATISTICS, 2222);

}



#ifdef USE_RTOS_MULTITASKING

void RTOS_TaskServers( void * parameter )

{

 while (true){

  delay(100);

  WebServer.handleClient();

  checkUDP();

 }

}



void RTOS_TaskSerial( void * parameter )

{

 while (true){

    delay(100);

    if (Settings.UseSerial)

    if (Serial.available())

      if (!PluginCall(PLUGIN_SERIAL_IN, 0, dummyString))

        serial();

 }

}



void RTOS_Task10ps( void * parameter )

{

 while (true){

    delay(100);

    run10TimesPerSecond();

 }

}

#endif



int firstEnabledMQTTController() {

  for (byte i = 0; i < CONTROLLER_MAX; ++i) {

    byte ProtocolIndex = getProtocolIndex(Settings.Protocol[i]);

    if (Protocol[ProtocolIndex].usesMQTT && Settings.ControllerEnabled[i]) {

      return i;

    }

  }

  return -1;

}



bool getControllerProtocolDisplayName(byte ProtocolIndex, byte parameterIdx, String& protoDisplayName) {

  EventStruct tmpEvent;

  tmpEvent.idx=parameterIdx;

  return CPlugin_ptr[ProtocolIndex](CPLUGIN_GET_PROTOCOL_DISPLAY_NAME, &tmpEvent, protoDisplayName);

}



void updateLoopStats() {

  ++loopCounter;

  ++loopCounter_full;

  if (lastLoopStart == 0) {

    lastLoopStart = micros();

    return;

  }

  const long usecSince = usecPassedSince(lastLoopStart);

  loop_usec_duration_total += usecSince;

  lastLoopStart = micros();

  if (usecSince <= 0 || usecSince > 10000000)

    return;

  if (shortestLoop > static_cast<unsigned long>(usecSince)) {

    shortestLoop = usecSince;

    loopCounterMax = 30 * 1000000 / usecSince;

  }

  if (longestLoop < static_cast<unsigned long>(usecSince))

    longestLoop = usecSince;

}



void updateLoopStats_30sec(byte loglevel) {

  loopCounterLast = loopCounter;

  loopCounter = 0;

  if (loopCounterLast > loopCounterMax)

    loopCounterMax = loopCounterLast;



  msecTimerHandler.updateIdleTimeStats();



  if (loglevelActiveFor(loglevel)) {

    String log = F("LoopStats: shortestLoop: ");

    log += shortestLoop;

    log += F(" longestLoop: ");

    log += longestLoop;

    log += F(" avgLoopDuration: ");

    log += loop_usec_duration_total / loopCounter_full;

    log += F(" loopCounterMax: ");

    log += loopCounterMax;

    log += F(" loopCounterLast: ");

    log += loopCounterLast;

    log += F(" countFindPluginId: ");

    log += countFindPluginId;

    addLog(loglevel, log);

  }

  countFindPluginId = 0;

  loop_usec_duration_total = 0;

  loopCounter_full = 1;

}



float getCPUload() {

  return 100.0 - msecTimerHandler.getIdleTimePct();

}



int getLoopCountPerSec() {

  return loopCounterLast / 30;

}
# 893 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
void loop()

{

  if(MainLoopCall_ptr)

      MainLoopCall_ptr();



  updateLoopStats();



  if (wifiSetupConnect)

  {



    WiFiConnectRelaxed();

    wifiSetupConnect = false;

  }

  if (wifiStatus != ESPEASY_WIFI_SERVICES_INITIALIZED) {

    if (wifiStatus >= ESPEASY_WIFI_CONNECTED) processConnect();

    if (wifiStatus >= ESPEASY_WIFI_GOT_IP) processGotIP();

    if (wifiStatus == ESPEASY_WIFI_DISCONNECTED) processDisconnect();

  } else if (!WiFiConnected()) {
# 937 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
  }

  if (!processedConnectAPmode) processConnectAPmode();

  if (!processedDisconnectAPmode) processDisconnectAPmode();

  if (!processedScanDone) processScanDone();



  bool firstLoopConnectionsEstablished = checkConnectionsEstablished() && firstLoop;

  if (firstLoopConnectionsEstablished) {

     firstLoop = false;

     timerAwakeFromDeepSleep = millis();





     RTC.bootFailedCount = 0;

     saveToRTC();

  }





  if ((firstLoopConnectionsEstablished || readyForSleep()) && isDeepSleepEnabled())

  {

      runPeriodicalMQTT();



      run50TimesPerSecond();

      run10TimesPerSecond();

      runEach30Seconds();

      runOncePerSecond();

  }



  else

  {

    handle_schedule();

  }



  backgroundtasks();



  if (readyForSleep()){

    if (Settings.UseRules)

    {

      String event = F("System#Sleep");

      rulesProcessing(event);

    }



    runPeriodicalMQTT();



    deepSleep(Settings.Delay);



  }

}



bool checkConnectionsEstablished() {

  if (wifiStatus != ESPEASY_WIFI_SERVICES_INITIALIZED) return false;

  if (firstEnabledMQTTController() >= 0) {



    return MQTTclient_connected;

  }

  return true;

}



void runPeriodicalMQTT() {



  if (!WiFiConnected(10)) {

    updateMQTTclient_connected();

    return;

  }



  int enabledMqttController = firstEnabledMQTTController();

  if (enabledMqttController >= 0) {

    if (!MQTTclient.loop()) {

      updateMQTTclient_connected();

      if (MQTTCheck(enabledMqttController)) {

        updateMQTTclient_connected();

      }

    }

  } else {

    if (MQTTclient.connected()) {

      MQTTclient.disconnect();

      updateMQTTclient_connected();

    }

  }

}



String getMQTT_state() {

  switch (MQTTclient.state()) {

    case MQTT_CONNECTION_TIMEOUT : return F("Connection timeout");

    case MQTT_CONNECTION_LOST : return F("Connection lost");

    case MQTT_CONNECT_FAILED : return F("Connect failed");

    case MQTT_DISCONNECTED : return F("Disconnected");

    case MQTT_CONNECTED : return F("Connected");

    case MQTT_CONNECT_BAD_PROTOCOL : return F("Connect bad protocol");

    case MQTT_CONNECT_BAD_CLIENT_ID : return F("Connect bad client_id");

    case MQTT_CONNECT_UNAVAILABLE : return F("Connect unavailable");

    case MQTT_CONNECT_BAD_CREDENTIALS: return F("Connect bad credentials");

    case MQTT_CONNECT_UNAUTHORIZED : return F("Connect unauthorized");

    default: return "";

  }

}



void updateMQTTclient_connected() {

  if (MQTTclient_connected != MQTTclient.connected()) {

    MQTTclient_connected = !MQTTclient_connected;

    if (!MQTTclient_connected) {

      if (loglevelActiveFor(LOG_LEVEL_ERROR)) {

        String connectionError = F("MQTT : Connection lost, state: ");

        connectionError += getMQTT_state();

        addLog(LOG_LEVEL_ERROR, connectionError);

      }

    } else {

      schedule_all_tasks_using_MQTT_controller();

    }

    if (Settings.UseRules) {

      String event = MQTTclient_connected ? F("MQTT#Connected") : F("MQTT#Disconnected");

      rulesProcessing(event);

    }

  }

  if (!MQTTclient_connected) {



    if (timermqtt_interval < 30000) {

      timermqtt_interval += 5000;

    }

  } else {

    timermqtt_interval = 250;

  }

  setIntervalTimer(TIMER_MQTT);

}
# 1191 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
void run50TimesPerSecond() {

  START_TIMER;

  PluginCall(PLUGIN_FIFTY_PER_SECOND, 0, dummyString);

  STOP_TIMER(PLUGIN_CALL_50PS);

}
# 1209 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
void run10TimesPerSecond() {

  {

    START_TIMER;

    PluginCall(PLUGIN_TEN_PER_SECOND, 0, dummyString);

    STOP_TIMER(PLUGIN_CALL_10PS);

  }

  {

    START_TIMER;

    PluginCall(PLUGIN_UNCONDITIONAL_POLL, 0, dummyString);

    STOP_TIMER(PLUGIN_CALL_10PSU);

  }

  if (Settings.UseRules && eventBuffer.length() > 0)

  {

    rulesProcessing(eventBuffer);

    eventBuffer = "";

  }

  #ifndef USE_RTOS_MULTITASKING

    WebServer.handleClient();

  #endif

}
# 1259 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
void runOncePerSecond()

{

  START_TIMER;

  updateLogLevelCache();

  dailyResetCounter++;

  if (dailyResetCounter > 86400)

  {

    RTC.flashDayCounter=0;

    saveToRTC();

    dailyResetCounter=0;

    String log = F("SYS  : Reset 24h counters");

    addLog(LOG_LEVEL_INFO, log);

  }



  if (Settings.ConnectionFailuresThreshold)

    if (connectionFailures > Settings.ConnectionFailuresThreshold)

      delayedReboot(60);



  if (cmd_within_mainloop != 0)

  {

    switch (cmd_within_mainloop)

    {

      case CMD_WIFI_DISCONNECT:

        {

          WifiDisconnect();

          break;

        }

      case CMD_REBOOT:

        {

          #if defined(ESP8266)

            ESP.reset();

          #endif

          #if defined(ESP32)

            ESP.restart();

          #endif

          break;

        }

    }

    cmd_within_mainloop = 0;

  }

  WifiCheck();





  if (Settings.UseNTP)

    checkTime();





  PluginCall(PLUGIN_ONCE_A_SECOND, 0, dummyString);





  if (Settings.UseRules)

    rulesTimers();





  if (SecuritySettings.Password[0] != 0)

  {

    if (WebLoggedIn)

      WebLoggedInTimer++;

    if (WebLoggedInTimer > 300)

      WebLoggedIn = false;

  }





  if (Settings.WDI2CAddress != 0)

  {

    Wire.beginTransmission(Settings.WDI2CAddress);

    Wire.write(0xA5);

    Wire.endTransmission();

  }
# 1433 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
  checkResetFactoryPin();

  STOP_TIMER(PLUGIN_CALL_1PS);

}



void logTimerStatistics() {

  byte loglevel = LOG_LEVEL_DEBUG;

  updateLoopStats_30sec(loglevel);

  logStatistics(loglevel, true);

  if (loglevelActiveFor(loglevel)) {

    String queueLog = F("Scheduler stats: (called/tasks/max_length/idle%) ");

    queueLog += msecTimerHandler.getQueueStats();

    addLog(loglevel, queueLog);

  }

}
# 1469 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
void runEach30Seconds()

{

   extern void checkRAMtoLog();

  checkRAMtoLog();

  wdcounter++;

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    String log;

    log.reserve(60);

    log = F("WD   : Uptime ");

    log += wdcounter / 2;

    log += F(" ConnectFailures ");

    log += connectionFailures;

    log += F(" FreeMem ");

    log += FreeMem();

    addLog(LOG_LEVEL_INFO, log);

  }

  sendSysInfoUDP(1);

  refreshNodeList();



  #if defined(ESP8266)

  if (Settings.UseSSDP)

    SSDP_update();

  #endif

#if FEATURE_ADC_VCC

  vcc = ESP.getVcc() / 1000.0;

#endif



  #ifdef FEATURE_REPORTING

  ReportStatus();

  #endif



}
# 1567 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
void SensorSendTask(byte TaskIndex)

{

  checkRAM(F("SensorSendTask"));

  if (Settings.TaskDeviceEnabled[TaskIndex])

  {

    byte varIndex = TaskIndex * VARS_PER_TASK;



    boolean success = false;

    byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);

    LoadTaskSettings(TaskIndex);



    struct EventStruct TempEvent;

    TempEvent.TaskIndex = TaskIndex;

    TempEvent.BaseVarIndex = varIndex;



    TempEvent.sensorType = Device[DeviceIndex].VType;



    float preValue[VARS_PER_TASK];

    for (byte varNr = 0; varNr < VARS_PER_TASK; varNr++)

      preValue[varNr] = UserVar[varIndex + varNr];



    if(Settings.TaskDeviceDataFeed[TaskIndex] == 0)

      success = PluginCall(PLUGIN_READ, &TempEvent, dummyString);

    else

      success = true;



    if (success)

    {

      START_TIMER;

      for (byte varNr = 0; varNr < VARS_PER_TASK; varNr++)

      {

        if (ExtraTaskSettings.TaskDeviceFormula[varNr][0] != 0)

        {

          String spreValue = String(preValue[varNr]);

          String formula = ExtraTaskSettings.TaskDeviceFormula[varNr];

          float value = UserVar[varIndex + varNr];

          float result = 0;

          String svalue = String(value);

          formula.replace(F("%pvalue%"), spreValue);

          formula.replace(F("%value%"), svalue);

          byte error = Calculate(formula.c_str(), &result);

          if (error == 0)

            UserVar[varIndex + varNr] = result;

        }

      }

      STOP_TIMER(COMPUTE_FORMULA_STATS);

      sendData(&TempEvent);

    }

  }

}
# 1677 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
bool runningBackgroundTasks=false;

void backgroundtasks()

{





  yield();
# 1713 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasy.ino"
  if (runningBackgroundTasks)

  {

    return;

  }

  runningBackgroundTasks=true;



  #if defined(ESP8266)

    tcpCleanup();

  #endif

  process_serialLogBuffer();

  if(!UseRTOSMultitasking){

    if (Settings.UseSerial)

      if (Serial.available())

        if (!PluginCall(PLUGIN_SERIAL_IN, 0, dummyString))

          serial();

    WebServer.handleClient();

    checkUDP();

  }





  if (dnsServerActive)

    dnsServer.processNextRequest();



  #ifdef FEATURE_ARDUINO_OTA

  if(Settings.ArduinoOTAEnable)

    ArduinoOTA.handle();





  while (ArduinoOTAtriggered)

  {

    yield();

    ArduinoOTA.handle();

  }



  #endif



  yield();



  statusLED(false);



  runningBackgroundTasks=false;

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Command.ino"


#include "Commands/Common.h"

#include "Commands/Blynk.h"

#include "Commands/Diagnostic.h"

#include "Commands/HTTP.h"

#include "Commands/i2c.h"

#include "Commands/MQTT.h"

#include "Commands/Networks.h"

#include "Commands/Notifications.h"

#include "Commands/RTC.h"

#include "Commands/Rules.h"

#include "Commands/SDCARD.h"

#include "Commands/Settings.h"

#include "Commands/System.h"

#include "Commands/Tasks.h"

#include "Commands/Time.h"

#include "Commands/Timer.h"

#include "Commands/UPD.h"

#include "Commands/wd.h"

#include "Commands/WiFi.h"
# 51 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Command.ino"
String doExecuteCommand(const char * cmd, struct EventStruct *event, const char* line)

{



  #define COMMAND_CASE(S, C) if (strcmp_P(cmd_lc, PSTR(S)) == 0) return (C(event, line));



 String tmpcmd;

 tmpcmd = cmd;

 tmpcmd.toLowerCase();

 String log = F("Command: ");

 log += tmpcmd;

 addLog(LOG_LEVEL_INFO, log);

 char cmd_lc[INPUT_COMMAND_SIZE];

 tmpcmd.toCharArray(cmd_lc, tmpcmd.length() + 1);

  switch (cmd_lc[0]) {

    case 'a': {

   COMMAND_CASE("accessinfo" , Command_AccessInfo_Ls);

      break;

    }

    case 'b': {

   COMMAND_CASE("background" , Command_Background);

    #ifdef USES_C012

   COMMAND_CASE("blynkget" , Command_Blynk_Get);

    #endif

   COMMAND_CASE("build" , Command_Settings_Build);

      break;

    }

    case 'c': {

   COMMAND_CASE("clearaccessblock" , Command_AccessInfo_Clear);

   COMMAND_CASE("clearrtcram" , Command_RTC_Clear);

   COMMAND_CASE("config" , Command_Task_RemoteConfig);

      break;

    }

    case 'd': {

   COMMAND_CASE("debug" , Command_Debug);

   COMMAND_CASE("deepsleep" , Command_System_deepSleep);

   COMMAND_CASE("delay" , Command_Delay);

   COMMAND_CASE("dns" , Command_DNS);

   COMMAND_CASE("dst" , Command_DST);

      break;

    }

    case 'e': {

   COMMAND_CASE("erase" , Command_WiFi_Erase);

   COMMAND_CASE("event" , Command_Rules_Events);

   COMMAND_CASE("executerules" , Command_Rules_Execute);

      break;

    }

    case 'g': {

   COMMAND_CASE("gateway" , Command_Gateway);

      break;

    }

    case 'i': {

   COMMAND_CASE("i2cscanner" , Command_i2c_Scanner);

   COMMAND_CASE("ip" , Command_IP);

      break;

    }

    case 'l': {

   COMMAND_CASE("load" , Command_Settings_Load);

   COMMAND_CASE("logentry" , Command_logentry);

   COMMAND_CASE("lowmem" , Command_Lowmem);

      break;

    }

    case 'm': {

   COMMAND_CASE("malloc" , Command_Malloc);

   COMMAND_CASE("meminfo" , Command_MemInfo);

    COMMAND_CASE("meminfodetail" , Command_MemInfo_detail);

   COMMAND_CASE("messagedelay" , Command_MQTT_messageDelay);

   COMMAND_CASE("mqttretainflag" , Command_MQTT_Retain);

      break;

    }

    case 'n': {

   COMMAND_CASE("name" , Command_Settings_Name);

   COMMAND_CASE("nosleep" , Command_System_NoSleep);

   COMMAND_CASE("notify" , Command_Notifications_Notify);

   COMMAND_CASE("ntphost" , Command_NTPHost);

      break;

    }

    case 'p': {

   COMMAND_CASE("password" , Command_Settings_Password);

   COMMAND_CASE("publish" , Command_MQTT_Publish);

      break;

    }

    case 'r': {

   COMMAND_CASE("reboot" , Command_System_Reboot);

   COMMAND_CASE("reset" , Command_Settings_Reset);

   COMMAND_CASE("resetflashwritecounter" , Command_RTC_resetFlashWriteCounter);

   COMMAND_CASE("restart" , Command_System_Restart);

   COMMAND_CASE("rules" , Command_Rules_UseRules);

      break;

    }

    case 's': {

   COMMAND_CASE("save" , Command_Settings_Save);

 #if FEATURE_SD

   COMMAND_CASE("sdcard" , Command_SD_LS);

   COMMAND_CASE("sdremove" , Command_SD_Remove);

 #endif

   COMMAND_CASE("sendto" , Command_UPD_SendTo);

   COMMAND_CASE("sendtohttp" , Command_HTTP_SendToHTTP);

   COMMAND_CASE("sendtoudp" , Command_UDP_SendToUPD);

   COMMAND_CASE("serialfloat" , Command_SerialFloat);

   COMMAND_CASE("settings" , Command_Settings_Print);

   COMMAND_CASE("subnet" , Command_Subnet);

   COMMAND_CASE("sysload" , Command_SysLoad);

      break;

    }

    case 't': {

   COMMAND_CASE("taskclear" , Command_Task_Clear);

   COMMAND_CASE("taskclearall" , Command_Task_ClearAll);

   COMMAND_CASE("taskrun" , Command_Task_Run);

   COMMAND_CASE("taskvalueset" , Command_Task_ValueSet);

   COMMAND_CASE("taskvaluesetandrun" , Command_Task_ValueSetAndRun);

   COMMAND_CASE("timerpause" , Command_Timer_Pause);

   COMMAND_CASE("timerresume" , Command_Timer_Resume);

   COMMAND_CASE("timerset" , Command_Timer_Set);

   COMMAND_CASE("timezone" , Command_TimeZone);

      break;

    }

    case 'u': {

   COMMAND_CASE("udpport" , Command_UDP_Port);

   COMMAND_CASE("udptest" , Command_UDP_Test);

   COMMAND_CASE("unit" , Command_Settings_Unit);

   COMMAND_CASE("usentp" , Command_useNTP);

      break;

    }

    case 'w': {

   COMMAND_CASE("wdconfig" , Command_WD_Config);

   COMMAND_CASE("wdread" , Command_WD_Read);

   COMMAND_CASE("wifiapmode" , Command_Wifi_APMode);

   COMMAND_CASE("wificonnect" , Command_Wifi_Connect);

   COMMAND_CASE("wifidisconnect" , Command_Wifi_Disconnect);

   COMMAND_CASE("wifikey" , Command_Wifi_Key);

   COMMAND_CASE("wifikey2" , Command_Wifi_Key2);

   COMMAND_CASE("wifimode" , Command_Wifi_Mode);

   COMMAND_CASE("wifiscan" , Command_Wifi_Scan);

   COMMAND_CASE("wifissid" , Command_Wifi_SSID);

   COMMAND_CASE("wifissid2" , Command_Wifi_SSID2);

   COMMAND_CASE("wifistamode" , Command_Wifi_STAMode);

      break;

    }

    default:

      break;

  }

  String errorUnknown = F("Command unknown: \"");

 errorUnknown += cmd_lc;

 errorUnknown += '\"';

 addLog(LOG_LEVEL_INFO, errorUnknown);

 return F("\nUnknown command!");



  #undef COMMAND_CASE

}





String return_command_success()

{

 return F("\nOk");

}

String return_command_failed()

{

 return F("\nFailed");

}

String return_not_connected()

{

 return F("Not connected to WiFi");

}



String return_result(struct EventStruct *event, const String& result)

{

 Serial.println(result);

 if (event->Source == VALUE_SOURCE_SERIAL) {

  return return_command_success();

 }

 return result;

}



String return_see_serial(struct EventStruct *event)

{

 if (event->Source == VALUE_SOURCE_SERIAL) {

  return return_command_success();

 }

 return F("Output sent to serial");

}



void ExecuteCommand(byte source, const char *Line)

{

 checkRAM(F("ExecuteCommand"));

 char TmpStr1[INPUT_COMMAND_SIZE];

 TmpStr1[0] = 0;

 char cmd[INPUT_COMMAND_SIZE];

 cmd[0] = 0;

 struct EventStruct TempEvent;





 TempEvent.Source = source;

 GetArgv(Line, cmd, 1);

  if (GetArgv(Line, TmpStr1, 2)) TempEvent.Par1 = CalculateParam(TmpStr1);

 if (GetArgv(Line, TmpStr1, 3)) TempEvent.Par2 = CalculateParam(TmpStr1);

 if (GetArgv(Line, TmpStr1, 4)) TempEvent.Par3 = CalculateParam(TmpStr1);

 if (GetArgv(Line, TmpStr1, 5)) TempEvent.Par4 = CalculateParam(TmpStr1);

 if (GetArgv(Line, TmpStr1, 6)) TempEvent.Par5 = CalculateParam(TmpStr1);



  if (source == VALUE_SOURCE_WEB_FRONTEND) {



    String status = doExecuteCommand((char*)&cmd[0], &TempEvent, Line);

    yield();

    SendStatus(source, status);

    yield();

  } else {



    schedule_command_timer((char*)&cmd[0], &TempEvent, Line);

  }

}



#ifdef FEATURE_SD

void printDirectory(File dir, int numTabs)

{

 while (true) {

  File entry = dir.openNextFile();

  if (!entry) {



   break;

  }

  for (uint8_t i = 0; i < numTabs; i++) {

   Serial.print('\t');

  }

  Serial.print(entry.name());

  if (entry.isDirectory()) {

   Serial.println("/");

   printDirectory(entry, numTabs + 1);

  } else {



   Serial.print("\t\t");

   Serial.println(entry.size(), DEC);

  }

  entry.close();

 }

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Controller.ino"






void sendData(struct EventStruct *event)

{

  START_TIMER;

  checkRAM(F("sendData"));

 LoadTaskSettings(event->TaskIndex);

  if (Settings.UseRules)

    createRuleEvents(event->TaskIndex);



  if (Settings.UseValueLogger && Settings.InitSPI && Settings.Pin_sd_cs >= 0)

    SendValueLogger(event->TaskIndex);
# 75 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Controller.ino"
  LoadTaskSettings(event->TaskIndex);



  for (byte x=0; x < CONTROLLER_MAX; x++)

  {

    event->ControllerIndex = x;

    event->idx = Settings.TaskDeviceID[x][event->TaskIndex];

    if (Settings.TaskDeviceSendData[event->ControllerIndex][event->TaskIndex] &&

        Settings.ControllerEnabled[event->ControllerIndex] &&

        Settings.Protocol[event->ControllerIndex])

    {

      event->ProtocolIndex = getProtocolIndex(Settings.Protocol[event->ControllerIndex]);

      if (validUserVar(event)) {

        CPlugin_ptr[event->ProtocolIndex](CPLUGIN_PROTOCOL_SEND, event, dummyString);

      } else {

        if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {

          String log = F("Invalid value detected for controller ");

          String controllerName;

          CPlugin_ptr[event->ProtocolIndex](CPLUGIN_GET_DEVICENAME, event, controllerName);

          log += controllerName;

          addLog(LOG_LEVEL_DEBUG, log);

        }

      }

    }

  }





  PluginCall(PLUGIN_EVENT_OUT, event, dummyString);

  lastSend = millis();

  STOP_TIMER(SEND_DATA_STATS);

}



boolean validUserVar(struct EventStruct *event) {

  byte valueCount = getValueCountFromSensorType(event->sensorType);

  for (int i = 0; i < valueCount; ++i) {

    const float f(UserVar[event->BaseVarIndex + i]);

    if (!isValidFloat(f)) return false;

  }

  return true;

}
# 163 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Controller.ino"
void callback(char* c_topic, byte* b_payload, unsigned int length) {



  char c_payload[384];



  statusLED(true);

  int enabledMqttController = firstEnabledMQTTController();

  if (enabledMqttController < 0) {

    addLog(LOG_LEVEL_ERROR, F("MQTT : No enabled MQTT controller"));

    return;

  }

  if ((length + 1) > sizeof(c_payload))

  {

    addLog(LOG_LEVEL_ERROR, F("MQTT : Ignored too big message"));

    return;

  }





  strncpy(c_payload,(char*)b_payload,length);

  c_payload[length] = 0;
# 239 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Controller.ino"
  struct EventStruct TempEvent;



  TempEvent.String1 = c_topic;

  TempEvent.String2 = c_payload;

  byte ProtocolIndex = getProtocolIndex(Settings.Protocol[enabledMqttController]);

  schedule_controller_event_timer(ProtocolIndex, CPLUGIN_PROTOCOL_RECV, &TempEvent);

}
# 263 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Controller.ino"
bool MQTTConnect(int controller_idx)

{

  ++mqtt_reconnect_count;

  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(controller_idx, ControllerSettings);

  if (!ControllerSettings.checkHostReachable(true))

    return false;

  if (MQTTclient.connected()) {

    MQTTclient.disconnect();

    updateMQTTclient_connected();

  }

  mqtt = WiFiClient();

  if (ControllerSettings.UseDNS) {

    MQTTclient.setServer(ControllerSettings.getHost().c_str(), ControllerSettings.Port);

  } else {

    MQTTclient.setServer(ControllerSettings.getIP(), ControllerSettings.Port);

  }

  MQTTclient.setCallback(callback);





  String clientid;

  if(Settings.MQTTUseUnitNameAsClientId){

    clientid = Settings.Name;

    if (Settings.Unit != 0) {

      clientid += F("_");

      clientid += Settings.Unit;

    }

  }

  else{

    clientid = F("ESPClient_");

    clientid += WiFi.macAddress();

  }
# 337 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Controller.ino"
  if (wifi_reconnects >= 1) {

    clientid += F("_");

    clientid += wifi_reconnects;

  }



  String LWTTopic = ControllerSettings.MQTTLwtTopic;

  if(LWTTopic.length() == 0)

  {

    LWTTopic = ControllerSettings.Subscribe;

    LWTTopic += F("/LWT");

  }

  LWTTopic.replace(F("/#"), F("/status"));

  parseSystemVariables(LWTTopic, false);



  String LWTMessageConnect = ControllerSettings.LWTMessageConnect;

  if(LWTMessageConnect.length() == 0){

    LWTMessageConnect = DEFAULT_MQTT_LWT_CONNECT_MESSAGE;

  }

  parseSystemVariables(LWTMessageConnect, false);



  String LWTMessageDisconnect = ControllerSettings.LWTMessageDisconnect;

  if(LWTMessageDisconnect.length() == 0){

    LWTMessageDisconnect = DEFAULT_MQTT_LWT_DISCONNECT_MESSAGE;

  }

  parseSystemVariables(LWTMessageDisconnect, false);



  boolean MQTTresult = false;

  uint8_t willQos = 0;

  boolean willRetain = true;



  if ((SecuritySettings.ControllerUser[controller_idx] != 0) && (SecuritySettings.ControllerPassword[controller_idx] != 0)) {

    MQTTresult = MQTTclient.connect(clientid.c_str(), SecuritySettings.ControllerUser[controller_idx], SecuritySettings.ControllerPassword[controller_idx],

                                    LWTTopic.c_str(), willQos, willRetain, LWTMessageDisconnect.c_str());

  } else {

    MQTTresult = MQTTclient.connect(clientid.c_str(), LWTTopic.c_str(), willQos, willRetain, LWTMessageDisconnect.c_str());

  }

  yield();



  if (!MQTTresult) {

    addLog(LOG_LEVEL_ERROR, F("MQTT : Failed to connect to broker"));

    return false;

  }

  MQTTclient_should_reconnect = false;

  String log = F("MQTT : Connected to broker with client ID: ");

  log += clientid;

  addLog(LOG_LEVEL_INFO, log);

  String subscribeTo = ControllerSettings.Subscribe;

  parseSystemVariables(subscribeTo, false);

  MQTTclient.subscribe(subscribeTo.c_str());

  log = F("Subscribed to: ");

  log += subscribeTo;

  addLog(LOG_LEVEL_INFO, log);



  if (MQTTclient.publish(LWTTopic.c_str(), LWTMessageConnect.c_str(), 1)) {

    updateMQTTclient_connected();

    statusLED(true);

    mqtt_reconnect_count = 0;

    return true;

  }

  return false;

}
# 469 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Controller.ino"
bool MQTTCheck(int controller_idx)

{

  if (!WiFiConnected(10)) {

    return false;

  }

  byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controller_idx]);

  if (Protocol[ProtocolIndex].usesMQTT)

  {

    if (MQTTclient_should_reconnect || !MQTTclient.connected())

    {

      if (MQTTclient_should_reconnect) {

        addLog(LOG_LEVEL_ERROR, F("MQTT : Intentional reconnect"));

      } else {

        connectionFailures += 2;

      }

      return MQTTConnect(controller_idx);

    } else if (connectionFailures) {

      connectionFailures--;

    }

  }



  return true;

}
# 527 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Controller.ino"
void SendStatus(byte source, String status)

{

  switch(source)

  {

    case VALUE_SOURCE_HTTP:

    case VALUE_SOURCE_WEB_FRONTEND:

      if (printToWeb)

        printWebString += status;

      break;

    case VALUE_SOURCE_MQTT:

      MQTTStatus(status);

      break;

    case VALUE_SOURCE_SERIAL:

      Serial.println(status);

      break;

  }

}



boolean MQTTpublish(int controller_idx, const char* topic, const char* payload, boolean retained)

{

  const bool success = MQTTDelayHandler.addToQueue(MQTT_queue_element(controller_idx, topic, payload, retained));

  scheduleNextMQTTdelayQueue();

  return success;

}



void scheduleNextMQTTdelayQueue() {

  scheduleNextDelayQueue(TIMER_MQTT_DELAY_QUEUE, MQTTDelayHandler.getNextScheduleTime());

}



void processMQTTdelayQueue() {

  START_TIMER;

  MQTT_queue_element element;

  if (!MQTTDelayHandler.getNext(element)) return;

  if (MQTTclient.publish(element._topic.c_str(), element._payload.c_str(), element._retained)) {

    setIntervalTimerOverride(TIMER_MQTT, 10);

    MQTTDelayHandler.markProcessed(true);

  } else {

    MQTTDelayHandler.markProcessed(false);

    if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {

      String log = F("MQTT : process MQTT queue not published, ");

      log += MQTTDelayHandler.sendQueue.size();

      log += F(" items left in queue");

      addLog(LOG_LEVEL_DEBUG, log);

    }

  }

  scheduleNextMQTTdelayQueue();

  STOP_TIMER(MQTT_DELAY_QUEUE);

}
# 631 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Controller.ino"
void MQTTStatus(String& status)

{

  ControllerSettingsStruct ControllerSettings;

  int enabledMqttController = firstEnabledMQTTController();

  if (enabledMqttController >= 0) {

    LoadControllerSettings(enabledMqttController, ControllerSettings);

    String pubname = ControllerSettings.Subscribe;

    pubname.replace(F("/#"), F("/status"));

    parseSystemVariables(pubname, false);

    MQTTpublish(enabledMqttController, pubname.c_str(), status.c_str(),Settings.MQTTRetainFlag);

  }

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Convert.ino"
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Convert.ino"
String getBearing(int degrees)

{

  const __FlashStringHelper* bearing[] = {

    F("N"),

    F("NNE"),

    F("NE"),

    F("ENE"),

    F("E"),

    F("ESE"),

    F("SE"),

    F("SSE"),

    F("S"),

    F("SSW"),

    F("SW"),

    F("WSW"),

    F("W"),

    F("WNW"),

    F("NW"),

    F("NNW")

  };

  int nr_directions = (int) (sizeof(bearing)/sizeof(bearing[0]));

  float stepsize = (360.0 / nr_directions);

  if (degrees < 0) { degrees += 360; }

  int bearing_idx=int((degrees + (stepsize / 2.0)) / stepsize) % nr_directions;

  if (bearing_idx < 0)

    return("");

  else

    return(bearing[bearing_idx]);

}



float CelsiusToFahrenheit(float celsius) {

  return celsius * (9.0 / 5.0) + 32;

}



int m_secToBeaufort(float m_per_sec) {

  if (m_per_sec < 0.3) return 0;

  if (m_per_sec < 1.6) return 1;

  if (m_per_sec < 3.4) return 2;

  if (m_per_sec < 5.5) return 3;

  if (m_per_sec < 8.0) return 4;

  if (m_per_sec < 10.8) return 5;

  if (m_per_sec < 13.9) return 6;

  if (m_per_sec < 17.2) return 7;

  if (m_per_sec < 20.8) return 8;

  if (m_per_sec < 24.5) return 9;

  if (m_per_sec < 28.5) return 10;

  if (m_per_sec < 32.6) return 11;

  return 12;

}



String centimeterToImperialLength(float cm) {

  return millimeterToImperialLength(cm * 10.0);

}



String millimeterToImperialLength(float mm) {

  float inches = mm / 25.4;

  int feet = inches /12;

  inches = inches - (feet * 12);

  String result;

  result.reserve(10);

  if (feet != 0) {

    result += feet;

    result += '\'';

  }

  result += toString(inches,1);

  result += '"';

  return result;

}



float minutesToDay(int minutes) {

  return minutes / 1440.0;

}



String minutesToDayHour(int minutes) {

  int days = minutes / 1440;

  int hours = (minutes % 1440) / 60;

  char TimeString[6];

  sprintf_P(TimeString, PSTR("%d%c%02d%c"), days, 'd', hours, 'h');

  return TimeString;

}



String minutesToHourMinute(int minutes) {

  int hours = (minutes % 1440) / 60;

  int mins = (minutes % 1440) % 60;

  char TimeString[20];

  sprintf_P(TimeString, PSTR("%d%c%02d%c"), hours, 'h', mins, 'm');

  return TimeString;

}



String minutesToDayHourMinute(int minutes) {

  int days = minutes / 1440;

  int hours = (minutes % 1440) / 60;

  int mins = (minutes % 1440) % 60;

  char TimeString[20];

  sprintf_P(TimeString, PSTR("%d%c%02d%c%02d%c"), days, 'd', hours, 'h', mins, 'm');

  return TimeString;

}



String secondsToDayHourMinuteSecond(int seconds) {

  int sec = seconds % 60;

  int minutes = seconds / 60;

  int days = minutes / 1440;

  int hours = (minutes % 1440) / 60;

  int mins = (minutes % 1440) % 60;

  char TimeString[20];

  sprintf_P(TimeString, PSTR("%d%c%02d%c%02d%c%02d"), days, 'd', hours, ':', mins, ':', sec);

  return TimeString;

}



String format_msec_duration(long duration) {

  String result;

  if (duration < 0) {

    result = "-";

    duration = -1 * duration;

  }

  if (duration < 10000) {

    result += duration;

    result += F(" ms");

    return result;

  }

  duration /= 1000;

  if (duration < 3600) {

    int sec = duration % 60;

    int minutes = duration / 60;

    if (minutes > 0) {

      result += minutes;

      result += F(" m ");

    }

    result += sec;

    result += F(" s");

    return result;

  }

  duration /= 60;

  if (duration < 1440) return minutesToHourMinute(duration);

  return minutesToDayHourMinute(duration);

}
# 293 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Convert.ino"
unsigned long float2ul(float f)

{

  unsigned long ul;

  memcpy(&ul, &f, 4);

  return ul;

}
# 315 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Convert.ino"
float ul2float(unsigned long ul)

{

  float f;

  memcpy(&f, &ul, 4);

  return f;

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStatistics.ino"
void logStatistics(byte loglevel, bool clearLog) {

  if (loglevelActiveFor(loglevel)) {

    String log;

    log.reserve(80);

    for (auto& x: pluginStats) {

        if (!x.second.isEmpty()) {

            const int pluginId = x.first/32;

            String P_name = "";

            Plugin_ptr[pluginId](PLUGIN_GET_DEVICENAME, NULL, P_name);

            log = F("PluginStats P_");

            log += pluginId + 1;

            log += '_';

            log += P_name;

            log += ' ';

            log += getPluginFunctionName(x.first%32);

            log += ' ';

            log += getLogLine(x.second);

            addLog(loglevel, log);

            if (clearLog) x.second.reset();

        }

    }

    for (auto& x: miscStats) {

        if (!x.second.isEmpty()) {

            log = getMiscStatsName(x.first);

            log += F(" stats: ");

            log += getLogLine(x.second);

            addLog(loglevel, log);

            if (clearLog) x.second.reset();

        }

    }

    log = getMiscStatsName(TIME_DIFF_COMPUTE);

    log += F(" stats: Count: ");

    log += timediff_calls;

    log += F(" - CPU cycles per call: ");

    log += static_cast<float>(timediff_cpu_cycles_total) / static_cast<float>(timediff_calls);

    addLog(loglevel, log);

    if (clearLog) {

      timediff_calls = 0;

      timediff_cpu_cycles_total = 0;

    }

  }

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
# 9 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
#define SPIFFS_CHECK(result,fname) if (!(result)) { return(FileError(__LINE__, fname)); }

String FileError(int line, const char * fname)

{

   String err = F("FS   : Error while reading/writing ");

   err += fname;

   err += F(" in ");

   err += line;

   addLog(LOG_LEVEL_ERROR, err);

   return(err);

}
# 39 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
void flashCount()

{

  if (RTC.flashDayCounter <= MAX_FLASHWRITES_PER_DAY)

    RTC.flashDayCounter++;

  RTC.flashCounter++;

  saveToRTC();

}



String flashGuard()

{

  checkRAM(F("flashGuard"));

  if (RTC.flashDayCounter > MAX_FLASHWRITES_PER_DAY)

  {

    String log = F("FS   : Daily flash write rate exceeded! (powercycle to reset this)");

    addLog(LOG_LEVEL_ERROR, log);

    return log;

  }

  flashCount();

  return(String());

}





#define FLASH_GUARD() { String flashErr=flashGuard(); if (flashErr.length()) return(flashErr); }
# 93 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String BuildFixes()

{

  checkRAM(F("BuildFixes"));

  Serial.println(F("\nBuild changed!"));



  if (Settings.Build < 145)

  {

    String fname=F(FILE_NOTIFICATION);

    fs::File f = SPIFFS.open(fname, "w");

    SPIFFS_CHECK(f, fname.c_str());



    if (f)

    {

      for (int x = 0; x < 4096; x++)

      {

        SPIFFS_CHECK(f.write(0), fname.c_str());

      }

      f.close();

    }

  }



  if (Settings.Build < 20101)

  {

    Serial.println(F("Fix reset Pin"));

    Settings.Pin_Reset = -1;

  }

  if (Settings.Build < 20102) {





    Serial.println(F("Fix settings with uninitalized data or corrupted by switching between versions"));

    Settings.UseRTOSMultitasking = false;

    Settings.Pin_Reset = -1;

    Settings.SyslogFacility = DEFAULT_SYSLOG_FACILITY;

    Settings.MQTTUseUnitNameAsClientId = DEFAULT_MQTT_USE_UNITNANE_AS_CLIENTID;

    Settings.StructSize = sizeof(Settings);

  }



  Settings.Build = BUILD;

  return(SaveSettings());

}
# 183 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
void fileSystemCheck()

{

  checkRAM(F("fileSystemCheck"));

  addLog(LOG_LEVEL_INFO, F("FS   : Mounting..."));

  if (SPIFFS.begin())

  {

    #if defined(ESP8266)

      fs::FSInfo fs_info;

      SPIFFS.info(fs_info);



      if (loglevelActiveFor(LOG_LEVEL_INFO)) {

        String log = F("FS   : Mount successful, used ");

        log=log+fs_info.usedBytes;

        log=log+F(" bytes of ");

        log=log+fs_info.totalBytes;

        addLog(LOG_LEVEL_INFO, log);

      }

    #endif



    fs::File f = SPIFFS.open(FILE_CONFIG, "r");

    if (!f)

    {

      ResetFactory();

    }

    f.close();

  }

  else

  {

    String log = F("FS   : Mount failed");

    Serial.println(log);

    addLog(LOG_LEVEL_ERROR, log);

    ResetFactory();

  }

}
# 259 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String SaveSettings(void)

{

  checkRAM(F("SaveSettings"));

  MD5Builder md5;

  uint8_t tmp_md5[16] = {0};

  String err;



  Settings.StructSize = sizeof(struct SettingsStruct);
# 299 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
    Settings.validate();

    err=SaveToFile((char*)FILE_CONFIG, 0, (byte*)&Settings, sizeof(Settings));

    if (err.length())

     return(err);





  memcpy( SecuritySettings.ProgmemMd5, CRCValues.runTimeMD5, 16);

  md5.begin();

  md5.add((uint8_t *)&SecuritySettings, sizeof(SecuritySettings)-16);

  md5.calculate();

  md5.getBytes(tmp_md5);

  if (memcmp(tmp_md5, SecuritySettings.md5, 16) != 0) {



    memcpy(SecuritySettings.md5, tmp_md5, 16);

    err=SaveToFile((char*)FILE_SECURITY, 0, (byte*)&SecuritySettings, sizeof(SecuritySettings));

    if (WifiIsAP(WiFi.getMode())) {



      wifiSetupConnect = true;

    }

  }

  return (err);

}
# 351 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String LoadSettings()

{

  checkRAM(F("LoadSettings"));

  String err;

  uint8_t calculatedMd5[16];

  MD5Builder md5;



  err=LoadFromFile((char*)FILE_CONFIG, 0, (byte*)&Settings, sizeof( SettingsStruct));

  if (err.length())

    return(err);

  Settings.validate();
# 411 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
  err=LoadFromFile((char*)FILE_SECURITY, 0, (byte*)&SecuritySettings, sizeof( SecurityStruct));

  md5.begin();

  md5.add((uint8_t *)&SecuritySettings, sizeof(SecuritySettings)-16);

  md5.calculate();

  md5.getBytes(calculatedMd5);

  if (memcmp (calculatedMd5, SecuritySettings.md5, 16)==0){

    addLog(LOG_LEVEL_INFO, F("CRC  : SecuritySettings CRC   ...OK "));

    if (memcmp(SecuritySettings.ProgmemMd5,CRCValues.runTimeMD5, 16)!=0)

      addLog(LOG_LEVEL_INFO, F("CRC  : binary has changed since last save of Settings"));

 }

  else{

    addLog(LOG_LEVEL_ERROR, F("CRC  : SecuritySettings CRC   ...FAIL"));

  }

  setUseStaticIP(useStaticIP());

  ExtraTaskSettings.clear();

  return(err);

}
# 453 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
byte disablePlugin(byte bootFailedCount) {

  for (byte i = 0; i < TASKS_MAX && bootFailedCount > 0; ++i) {

    if (Settings.TaskDeviceEnabled[i]) {

      --bootFailedCount;

      if (bootFailedCount == 0) {

        Settings.TaskDeviceEnabled[i] = false;

      }

    }

  }

  return bootFailedCount;

}
# 483 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
byte disableController(byte bootFailedCount) {

  for (byte i = 0; i < CONTROLLER_MAX && bootFailedCount > 0; ++i) {

    if (Settings.ControllerEnabled[i]) {

      --bootFailedCount;

      if (bootFailedCount == 0) {

        Settings.ControllerEnabled[i] = false;

      }

    }

  }

  return bootFailedCount;

}
# 513 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
byte disableNotification(byte bootFailedCount) {

  for (byte i = 0; i < NOTIFICATION_MAX && bootFailedCount > 0; ++i) {

    if (Settings.NotificationEnabled[i]) {

      --bootFailedCount;

      if (bootFailedCount == 0) {

        Settings.NotificationEnabled[i] = false;

      }

    }

  }

  return bootFailedCount;

}
# 543 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
bool getSettingsParameters(SettingsType settingsType, int index, int& max_index, int& offset, int& max_size, int& struct_size) {

  struct_size = 0;

  switch (settingsType) {

    case BasicSettings_Type:

      max_index = 1;

      offset = 0;

      max_size = DAT_BASIC_SETTINGS_SIZE;

      struct_size = sizeof(SettingsStruct);

      break;

    case TaskSettings_Type:

      max_index = TASKS_MAX;

      offset = DAT_OFFSET_TASKS + (index * DAT_TASKS_DISTANCE);

      max_size = DAT_TASKS_SIZE;

      struct_size = sizeof(ExtraTaskSettingsStruct);

      break;

    case CustomTaskSettings_Type:

      max_index = TASKS_MAX;

      offset = DAT_OFFSET_TASKS + (index * DAT_TASKS_DISTANCE) + DAT_TASKS_CUSTOM_OFFSET;

      max_size = DAT_TASKS_CUSTOM_SIZE;



      break;

    case ControllerSettings_Type:

      max_index = CONTROLLER_MAX;

      offset = DAT_OFFSET_CONTROLLER + (index * DAT_CONTROLLER_SIZE);

      max_size = DAT_CONTROLLER_SIZE;

      struct_size = sizeof(ControllerSettingsStruct);

      break;

    case CustomControllerSettings_Type:

      max_index = CONTROLLER_MAX;

      offset = DAT_OFFSET_CUSTOM_CONTROLLER + (index * DAT_CUSTOM_CONTROLLER_SIZE);

      max_size = DAT_CUSTOM_CONTROLLER_SIZE;



      break;

    case NotificationSettings_Type:

      max_index = NOTIFICATION_MAX;

      offset = index * DAT_NOTIFICATION_SIZE;

      max_size = DAT_NOTIFICATION_SIZE;

      struct_size = sizeof(NotificationSettingsStruct);

      break;

    default:

      max_index = -1;

      offset = -1;

      return false;

  }

  return true;

}



int getMaxFilePos(SettingsType settingsType) {

  int max_index, offset, max_size;

  int struct_size = 0;

  getSettingsParameters(settingsType, 0, max_index, offset, max_size, struct_size);

  getSettingsParameters(settingsType, max_index - 1, offset, max_size);

  return offset + max_size - 1;

}



int getFileSize(SettingsType settingsType) {

  if (settingsType == NotificationSettings_Type) {

    return getMaxFilePos(settingsType);

  }



  int max_file_pos = 0;

  for (int st = 0; st < SettingsType_MAX; ++st) {

    int filePos = getMaxFilePos(static_cast<SettingsType>(st));

    if (filePos > max_file_pos)

      max_file_pos = filePos;

  }

  return max_file_pos;

}



bool getAndLogSettingsParameters(bool read, SettingsType settingsType, int index, int& offset, int& max_size) {

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_DEV)) {

    String log = read ? F("Read") : F("Write");

    log += F(" settings: ");

    log += getSettingsTypeString(settingsType);

    log += F(" index: ");

    log += index;

    addLog(LOG_LEVEL_DEBUG_DEV, log);

  }

  return getSettingsParameters(settingsType, index, offset, max_size);

}



bool getSettingsParameters(SettingsType settingsType, int index, int& offset, int& max_size) {

  int max_index = -1;

  int struct_size;

  if (!getSettingsParameters(settingsType, index, max_index, offset, max_size, struct_size))

    return false;

  if (index >= 0 && index < max_index) return true;

  offset = -1;

  return false;

}
# 731 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String SaveTaskSettings(byte TaskIndex)

{

  checkRAM(F("SaveTaskSettings"));

  if (ExtraTaskSettings.TaskIndex != TaskIndex)

    return F("SaveTaskSettings taskIndex does not match");

  String err = SaveToFile(TaskSettings_Type, TaskIndex, (char*)FILE_CONFIG, (byte*)&ExtraTaskSettings, sizeof(struct ExtraTaskSettingsStruct));

  if (err.length() == 0)

    err = checkTaskSettings(TaskIndex);

  return err;

}
# 761 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String LoadTaskSettings(byte TaskIndex)

{

  if (TaskIndex < 0 || TaskIndex >= TASKS_MAX)

    return(String());

  checkRAM(F("LoadTaskSettings"));

  if (ExtraTaskSettings.TaskIndex == TaskIndex)

    return(String());

  ExtraTaskSettings.clear();

  String result = "";

  result = LoadFromFile(TaskSettings_Type, TaskIndex, (char*)FILE_CONFIG, (byte*)&ExtraTaskSettings, sizeof(struct ExtraTaskSettingsStruct));





  ExtraTaskSettings.TaskIndex = TaskIndex;

  if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0) {



    struct EventStruct TempEvent;

    TempEvent.TaskIndex = TaskIndex;

    String dummyString;



    PluginCall(PLUGIN_GET_DEVICEVALUENAMES, &TempEvent, dummyString);

  }



  return result;

}
# 819 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String SaveCustomTaskSettings(int TaskIndex, byte* memAddress, int datasize)

{

  checkRAM(F("SaveCustomTaskSettings"));

  return(SaveToFile(CustomTaskSettings_Type, TaskIndex, (char*)FILE_CONFIG, memAddress, datasize));

}
# 839 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String ClearCustomTaskSettings(int TaskIndex)

{



  return(ClearInFile(CustomTaskSettings_Type, TaskIndex, (char*)FILE_CONFIG));

}
# 857 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String LoadCustomTaskSettings(int TaskIndex, byte* memAddress, int datasize)

{

  checkRAM(F("LoadCustomTaskSettings"));

  return(LoadFromFile(CustomTaskSettings_Type, TaskIndex, (char*)FILE_CONFIG, memAddress, datasize));

}
# 875 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String SaveControllerSettings(int ControllerIndex, ControllerSettingsStruct& controller_settings)

{

  checkRAM(F("SaveControllerSettings"));

  controller_settings.validate();

  return SaveToFile(ControllerSettings_Type, ControllerIndex,

                    (char*)FILE_CONFIG, (byte*)&controller_settings, sizeof(controller_settings));

}
# 899 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String LoadControllerSettings(int ControllerIndex, ControllerSettingsStruct& controller_settings) {

  checkRAM(F("LoadControllerSettings"));

  String result =

    LoadFromFile(ControllerSettings_Type, ControllerIndex,

                 (char*)FILE_CONFIG, (byte*)&controller_settings, sizeof(controller_settings));

  controller_settings.validate();

  return result;

}
# 925 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String ClearCustomControllerSettings(int ControllerIndex)

{

  checkRAM(F("ClearCustomControllerSettings"));



  return(ClearInFile(CustomControllerSettings_Type, ControllerIndex, (char*)FILE_CONFIG));

}
# 947 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String SaveCustomControllerSettings(int ControllerIndex,byte* memAddress, int datasize)

{

  checkRAM(F("SaveCustomControllerSettings"));

  return SaveToFile(CustomControllerSettings_Type, ControllerIndex, (char*)FILE_CONFIG, memAddress, datasize);

}
# 967 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String LoadCustomControllerSettings(int ControllerIndex,byte* memAddress, int datasize)

{

  checkRAM(F("LoadCustomControllerSettings"));

  return(LoadFromFile(CustomControllerSettings_Type, ControllerIndex, (char*)FILE_CONFIG, memAddress, datasize));

}
# 985 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String SaveNotificationSettings(int NotificationIndex, byte* memAddress, int datasize)

{

  checkRAM(F("SaveNotificationSettings"));

  return SaveToFile(NotificationSettings_Type, NotificationIndex, (char*)FILE_NOTIFICATION, memAddress, datasize);

}
# 1005 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String LoadNotificationSettings(int NotificationIndex, byte* memAddress, int datasize)

{

  checkRAM(F("LoadNotificationSettings"));

  return(LoadFromFile(NotificationSettings_Type, NotificationIndex, (char*)FILE_NOTIFICATION, memAddress, datasize));

}
# 1029 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String InitFile(const char* fname, int datasize)

{

  checkRAM(F("InitFile"));

  FLASH_GUARD();



  fs::File f = SPIFFS.open(fname, "w");

  SPIFFS_CHECK(f, fname);



  for (int x = 0; x < datasize ; x++)

  {

    SPIFFS_CHECK(f.write(0), fname);

  }

  f.close();





  return String();

}
# 1071 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String SaveToFile(char* fname, int index, byte* memAddress, int datasize)

{

  if (index < 0) {

    String log = F("SaveToFile: ");

    log += fname;

    log += F(" ERROR, invalid position in file");

    addLog(LOG_LEVEL_ERROR, log);

    return log;

  }



  checkRAM(F("SaveToFile"));

  FLASH_GUARD();



  fs::File f = SPIFFS.open(fname, "r+");

  SPIFFS_CHECK(f, fname);



  SPIFFS_CHECK(f.seek(index, fs::SeekSet), fname);

  byte *pointerToByteToSave = memAddress;

  for (int x = 0; x < datasize ; x++)

  {

    SPIFFS_CHECK(f.write(*pointerToByteToSave), fname);

    pointerToByteToSave++;

  }

  f.close();

  String log = F("FILE : Saved ");

  log=log+fname;

  addLog(LOG_LEVEL_INFO, log);





  return String();

}
# 1141 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String ClearInFile(char* fname, int index, int datasize)

{

  if (index < 0) {

    String log = F("ClearInFile: ");

    log += fname;

    log += F(" ERROR, invalid position in file");

    addLog(LOG_LEVEL_ERROR, log);

    return log;

  }



  checkRAM(F("ClearInFile"));

  FLASH_GUARD();



  fs::File f = SPIFFS.open(fname, "r+");

  SPIFFS_CHECK(f, fname);



  SPIFFS_CHECK(f.seek(index, fs::SeekSet), fname);

  for (int x = 0; x < datasize ; x++)

  {

    SPIFFS_CHECK(f.write(0), fname);

  }

  f.close();





  return String();



}
# 1203 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String LoadFromFile(char* fname, int offset, byte* memAddress, int datasize)

{

  if (offset < 0) {

    String log = F("LoadFromFile: ");

    log += fname;

    log += F(" ERROR, invalid position in file");

    addLog(LOG_LEVEL_ERROR, log);

    return log;

  }

  START_TIMER;



  checkRAM(F("LoadFromFile"));



  fs::File f = SPIFFS.open(fname, "r+");

  SPIFFS_CHECK(f, fname);

  SPIFFS_CHECK(f.seek(offset, fs::SeekSet), fname);

  SPIFFS_CHECK(f.read(memAddress,datasize), fname);

  f.close();



  STOP_TIMER(LOADFILE_STATS);



  return(String());

}
# 1257 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
String getSettingsFileIndexRangeError(bool read, SettingsType settingsType, int index) {

  if (settingsType >= SettingsType_MAX) {

    String error = F("Unknown settingsType: ");

    error += static_cast<int>(settingsType);

    return error;

  }

  String error = read ? F("Load") : F("Save");

  error += getSettingsTypeString(settingsType);

  error += F(" index out of range: ");

  error += index;

  return error;

}



String getSettingsFileDatasizeError(bool read, SettingsType settingsType, int index, int datasize, int max_size) {

  String error = read ? F("Load") : F("Save");

  error += getSettingsTypeString(settingsType);

  error += '(';

  error += index;

  error += F(") datasize(");

  error += datasize;

  error += F(") > max_size(");

  error += max_size;

  error += ')';

  return error;

}



String LoadFromFile(SettingsType settingsType, int index, char* fname, byte* memAddress, int datasize) {

  bool read = true;

  int offset, max_size;

  if (!getAndLogSettingsParameters(read, settingsType, index, offset, max_size)) {

    return getSettingsFileIndexRangeError(read, settingsType, index);

  }

  if (datasize > max_size)

    return getSettingsFileDatasizeError(read, settingsType, index, datasize, max_size);

  return(LoadFromFile(fname, offset, memAddress, datasize));

}



String SaveToFile(SettingsType settingsType, int index, char* fname, byte* memAddress, int datasize) {

  bool read = false;

  int offset, max_size;

  if (!getAndLogSettingsParameters(read, settingsType, index, offset, max_size)) {

    return getSettingsFileIndexRangeError(read, settingsType, index);

  }

  if (datasize > max_size)

    return getSettingsFileDatasizeError(read, settingsType, index, datasize, max_size);

  return(SaveToFile(fname, offset, memAddress, datasize));

}



String ClearInFile(SettingsType settingsType, int index, char* fname) {

  bool read = false;

  int offset, max_size;

  if (!getAndLogSettingsParameters(read, settingsType, index, offset, max_size)) {

    return getSettingsFileIndexRangeError(read, settingsType, index);

  }

  return(ClearInFile(fname, offset, max_size));

}
# 1377 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
int SpiffsSectors()

{

  checkRAM(F("SpiffsSectors"));

  #if defined(ESP8266)

    uint32_t _sectorStart = ((uint32_t)&_SPIFFS_start - 0x40200000) / SPI_FLASH_SEC_SIZE;

    uint32_t _sectorEnd = ((uint32_t)&_SPIFFS_end - 0x40200000) / SPI_FLASH_SEC_SIZE;

    return _sectorEnd - _sectorStart;

  #endif

  #if defined(ESP32)

    return 32;

  #endif

}
# 1409 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyStorage.ino"
#ifdef ESP32

String getPartitionType(byte pType, byte pSubType) {

  esp_partition_type_t partitionType = static_cast<esp_partition_type_t>(pType);

  esp_partition_subtype_t partitionSubType = static_cast<esp_partition_subtype_t>(pSubType);

  if (partitionType == ESP_PARTITION_TYPE_APP) {

    if (partitionSubType >= ESP_PARTITION_SUBTYPE_APP_OTA_MIN &&

        partitionSubType < ESP_PARTITION_SUBTYPE_APP_OTA_MAX) {

        String result = F("OTA partition ");

        result += (partitionSubType - ESP_PARTITION_SUBTYPE_APP_OTA_MIN);

        return result;

    }



    switch (partitionSubType) {

      case ESP_PARTITION_SUBTYPE_APP_FACTORY: return F("Factory app");

      case ESP_PARTITION_SUBTYPE_APP_TEST: return F("Test app");

      default: break;

    }

  }

  if (partitionType == ESP_PARTITION_TYPE_DATA) {

    switch (partitionSubType) {

        case ESP_PARTITION_SUBTYPE_DATA_OTA: return F("OTA selection");

        case ESP_PARTITION_SUBTYPE_DATA_PHY: return F("PHY init data");

        case ESP_PARTITION_SUBTYPE_DATA_NVS: return F("NVS");

        case ESP_PARTITION_SUBTYPE_DATA_COREDUMP: return F("COREDUMP");

        case ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD: return F("ESPHTTPD");

        case ESP_PARTITION_SUBTYPE_DATA_FAT: return F("FAT");

        case ESP_PARTITION_SUBTYPE_DATA_SPIFFS: return F("SPIFFS");

        default: break;

    }

  }

  String result = F("Unknown(");

  result += partitionSubType;

  result += ')';

  return result;

}



String getPartitionTableHeader(const String& itemSep, const String& lineEnd) {

  String result;

  result += F("Address");

  result += itemSep;

  result += F("Size");

  result += itemSep;

  result += F("Label");

  result += itemSep;

  result += F("Partition Type");

  result += itemSep;

  result += F("Encrypted");

  result += lineEnd;

  return result;

}



String getPartitionTable(byte pType, const String& itemSep, const String& lineEnd) {

  esp_partition_type_t partitionType = static_cast<esp_partition_type_t>(pType);

  String result;

  const esp_partition_t * _mypart;

  esp_partition_iterator_t _mypartiterator = esp_partition_find(partitionType, ESP_PARTITION_SUBTYPE_ANY, NULL);

  if (_mypartiterator) {

    do {

      _mypart = esp_partition_get(_mypartiterator);

      result += formatToHex(_mypart->address);

      result += itemSep;

      result += formatToHex_decimal(_mypart->size, 1024);

      result += itemSep;

      result += _mypart->label;

      result += itemSep;

      result += getPartitionType(_mypart->type, _mypart->subtype);

      result += itemSep;

      result += (_mypart->encrypted ? F("Yes") : F("-"));

      result += lineEnd;

    } while ((_mypartiterator = esp_partition_next(_mypartiterator)) != NULL);

  }

  esp_partition_iterator_release(_mypartiterator);

  return result;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"


#define WIFI_AP_OFF_TIMER_DURATION 60000
# 15 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
void processConnect() {

  if (processedConnect) return;

  processedConnect = true;

  ++wifi_reconnects;

  if (wifiStatus < ESPEASY_WIFI_CONNECTED) return;

  const long connect_duration = timeDiff(last_wifi_connect_attempt_moment, lastConnectMoment);

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    String log = F("WIFI : Connected! AP: ");

    log += WiFi.SSID();

    log += F(" (");

    log += WiFi.BSSIDstr();

    log += F(") Ch: ");

    log += last_channel;

    if (connect_duration > 0 && connect_duration < 30000) {



      log += F(" Duration: ");

      log += connect_duration;

      log += F(" ms");

    }

    addLog(LOG_LEVEL_INFO, log);

  }

  if (Settings.UseRules && bssid_changed) {

    String event = F("WiFi#ChangedAccesspoint");

    rulesProcessing(event);

  }

  if (useStaticIP()) {

    setupStaticIPconfig();

    markGotIP();

  }

  logConnectionStatus();

}



void processDisconnect() {

  if (processedDisconnect) return;

  processedDisconnect = true;

  if (Settings.UseRules) {

    String event = F("WiFi#Disconnected");

    rulesProcessing(event);

  }

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    String log = F("WIFI : Disconnected! Reason: '");

    log += getLastDisconnectReason();

    log += F("'");

    if (lastConnectedDuration > 0) {

      log += F(" Connected for ");

      log += format_msec_duration(lastConnectedDuration);

    }

    addLog(LOG_LEVEL_INFO, log);

  }

  logConnectionStatus();

}





void processGotIP() {

  if (processedGetIP)

    return;

  IPAddress ip = WiFi.localIP();

  if (!useStaticIP())

    if (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] == 0)

      return;

  processedGetIP = true;

  const IPAddress gw = WiFi.gatewayIP();

  const IPAddress subnet = WiFi.subnetMask();

  const long dhcp_duration = timeDiff(lastConnectMoment, lastGetIPmoment);

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    String log = F("WIFI : ");

    if (useStaticIP()) {

      log += F("Static IP: ");

    } else {

      log += F("DHCP IP: ");

    }

    log += formatIP(ip);

    log += F(" (");

    log += WifiGetHostname();

    log += F(") GW: ");

    log += formatIP(gw);

    log += F(" SN: ");

    log += formatIP(subnet);

    if (dhcp_duration > 0 && dhcp_duration < 30000) {



      log += F("   duration: ");

      log += dhcp_duration;

      log += F(" ms");

    }

    addLog(LOG_LEVEL_INFO, log);

  }





  if (Settings.IP_Octet != 0 && Settings.IP_Octet != 255)

  {

    ip[3] = Settings.IP_Octet;

    if (loglevelActiveFor(LOG_LEVEL_INFO)) {

      String log = F("IP   : Fixed IP octet:");

      log += formatIP(ip);

      addLog(LOG_LEVEL_INFO, log);

    }

    WiFi.config(ip, gw, subnet);

  }



  #ifdef FEATURE_MDNS



    if (loglevelActiveFor(LOG_LEVEL_INFO)) {

      String log = F("WIFI : ");

      if (MDNS.begin(WifiGetHostname().c_str(), WiFi.localIP())) {



        log += F("mDNS started, with name: ");

        log += WifiGetHostname();

        log += F(".local");

      }

      else{

        log += F("mDNS failed");

      }

      addLog(LOG_LEVEL_INFO, log);

    }

  #endif





  if (Settings.UseNTP) {

    initTime();

  }

  mqtt_reconnect_count = 0;

  MQTTclient_should_reconnect = true;

  timermqtt_interval = 100;

  setIntervalTimer(TIMER_MQTT);

  if (Settings.UseRules)

  {

    String event = F("WiFi#Connected");

    rulesProcessing(event);

  }

  statusLED(true);



  wifiStatus = ESPEASY_WIFI_SERVICES_INITIALIZED;

  setWebserverRunning(true);

  wifi_connect_attempt = 0;

  if (wifiSetup) {



    wifiSetup = false;

    SaveSettings();

  }

  logConnectionStatus();

}



void processConnectAPmode() {

  if (processedConnectAPmode) return;

  processedConnectAPmode = true;

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    String log = F("AP Mode: Client connected: ");

    log += formatMAC(lastMacConnectedAPmode);

    log += F(" Connected devices: ");

    log += WiFi.softAPgetStationNum();

    addLog(LOG_LEVEL_INFO, log);

  }

  timerAPoff = 0;

  setWebserverRunning(true);







  if (!dnsServerActive) {

    dnsServerActive = true;

    dnsServer.start(DNS_PORT, "*", apIP);

  }

}



void processDisconnectAPmode() {

  if (processedDisconnectAPmode) return;

  processedDisconnectAPmode = true;

  const int nrStationsConnected = WiFi.softAPgetStationNum();

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    String log = F("AP Mode: Client disconnected: ");

    log += formatMAC(lastMacDisconnectedAPmode);

    log += F(" Connected devices: ");

    log += nrStationsConnected;

    addLog(LOG_LEVEL_INFO, log);

  }

  if (nrStationsConnected == 0) {

    timerAPoff = millis() + WIFI_AP_OFF_TIMER_DURATION;

  }

}



void processDisableAPmode() {

  if (timerAPoff == 0) return;

  if (WifiIsAP(WiFi.getMode())) {



    if (timeOutReached(timerAPoff)) {

      setAP(false);

    }

  }

}



void processScanDone() {

  if (processedScanDone) return;

  processedScanDone = true;

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    String log = F("WIFI  : Scan finished, found: ");

    log += scan_done_number;

    addLog(LOG_LEVEL_INFO, log);

  }



  int bestScanID = -1;

  int32_t bestRssi = -1000;

  uint8_t bestWiFiSettings = lastWiFiSettings;

  if (selectValidWiFiSettings()) {

    bool done = false;

    String lastWiFiSettingsSSID = getLastWiFiSettingsSSID();

    for (int settingNr = 0; !done && settingNr < 2; ++settingNr) {

      for (int i = 0; i < scan_done_number; ++i) {

        if (WiFi.SSID(i) == lastWiFiSettingsSSID) {

          int32_t rssi = WiFi.RSSI(i);

          if (bestRssi < rssi) {

            bestRssi = rssi;

            bestScanID = i;

            bestWiFiSettings = lastWiFiSettings;

          }

        }

      }

      if (!selectNextWiFiSettings()) done = true;

    }

    if (bestScanID >= 0) {

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {

        String log = F("WIFI  : Selected: ");

        log += formatScanResult(bestScanID, " ");

        addLog(LOG_LEVEL_INFO, log);

      }

      lastWiFiSettings = bestWiFiSettings;

      uint8_t * scanbssid = WiFi.BSSID(bestScanID);

      if (scanbssid) {

        for (int i = 0; i < 6 ; ++i) {

          lastBSSID[i] = *(scanbssid + i);

        }

      }

    }

  }

}



void resetWiFi() {

  addLog(LOG_LEVEL_INFO, F("Reset WiFi."));

  setWifiMode(WIFI_OFF);

  setWifiMode(WIFI_STA);

  lastDisconnectMoment = millis();

  processedDisconnect = false;

  wifiStatus = ESPEASY_WIFI_DISCONNECTED;

}



void WifiScanAsync() {

  addLog(LOG_LEVEL_INFO, F("WIFI  : Start network scan"));

  #ifdef ESP32

    bool async = true;

    bool show_hidden = false;

    bool passive = false;

    uint32_t max_ms_per_chan = 300;

    WiFi.scanNetworks(async, show_hidden, passive, max_ms_per_chan);

  #else





  #endif

}
# 557 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
bool WifiIsAP(WiFiMode_t wifimode)

{

  #if defined(ESP32)

    return (wifimode == WIFI_MODE_AP) || (wifimode == WIFI_MODE_APSTA);

  #else

    return (wifimode == WIFI_AP) || (wifimode == WIFI_AP_STA);

  #endif

}



bool WifiIsSTA(WiFiMode_t wifimode)

{

  #if defined(ESP32)

    return ((wifimode & WIFI_MODE_STA) != 0);

  #else

    return ((wifimode & WIFI_STA) != 0);

  #endif

}
# 601 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
void setSTA(bool enable) {

  switch(WiFi.getMode()) {

    case WIFI_OFF:

      if (enable) setWifiMode(WIFI_STA);

      break;

    case WIFI_STA:

      if (!enable) setWifiMode(WIFI_OFF);

      break;

    case WIFI_AP:

      if (enable) setWifiMode(WIFI_AP_STA);

      break;

    case WIFI_AP_STA:

      if (!enable) setWifiMode(WIFI_AP);

      break;

    default:

      break;

  }

}



void setAP(bool enable) {

  switch(WiFi.getMode()) {

    case WIFI_OFF:

      if (enable) setWifiMode(WIFI_AP);

      break;

    case WIFI_STA:

      if (enable) setWifiMode(WIFI_AP_STA);

      break;

    case WIFI_AP:

      if (!enable) setWifiMode(WIFI_OFF);

      break;

    case WIFI_AP_STA:

      if (!enable) setWifiMode(WIFI_STA);

      break;

    default:

      break;

  }

  setAPinternal(enable);

}





void setAPinternal(bool enable)

{

    if (enable) {

    timerAPoff = millis() + WIFI_AP_OFF_TIMER_DURATION;





    String softAPSSID=WifiGetAPssid();

    String pwd = SecuritySettings.WifiAPKey;

    IPAddress subnet(DEFAULT_AP_SUBNET);

    if (!WiFi.softAPConfig(apIP, apIP, subnet)) {

      addLog(LOG_LEVEL_ERROR, F("WIFI : [AP] softAPConfig failed!"));

    }

    if (WiFi.softAP(softAPSSID.c_str(),pwd.c_str())) {

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {

        String log(F("WIFI : AP Mode ssid will be "));

        log += softAPSSID;

        log += F(" with address ");

        log += WiFi.softAPIP().toString();

        addLog(LOG_LEVEL_INFO, log);

      }

    } else {

      if (loglevelActiveFor(LOG_LEVEL_ERROR)) {

        String log(F("WIFI : Error while starting AP Mode with SSID: "));

        log += softAPSSID;

        log += F(" IP: ");

        log += apIP.toString();

        addLog(LOG_LEVEL_ERROR, log);

      }

    }

    #ifdef ESP32



    #else

      if(wifi_softap_dhcps_status() != DHCP_STARTED) {

        if(!wifi_softap_dhcps_start()) {

          addLog(LOG_LEVEL_ERROR, F("WIFI : [AP] wifi_softap_dhcps_start failed!"));

        }

      }

    #endif

  } else {

    timerAPoff = 0;

    if (dnsServerActive) {

      dnsServerActive = false;

      dnsServer.stop();

    }

  }

}





void setWifiMode(WiFiMode_t wifimode) {

  if (WiFi.getMode() == wifimode) {

    return;

  }

  switch (wifimode) {

    case WIFI_OFF:

      addLog(LOG_LEVEL_INFO, F("WIFI : Switch off WiFi"));

      break;

    case WIFI_STA:

      addLog(LOG_LEVEL_INFO, F("WIFI : Set WiFi to STA"));

      break;

    case WIFI_AP:

      addLog(LOG_LEVEL_INFO, F("WIFI : Set WiFi to AP"));

      break;

    case WIFI_AP_STA:

      addLog(LOG_LEVEL_INFO, F("WIFI : Set WiFi to AP+STA"));

      break;

    default:

      break;

  }

  setUseStaticIP(useStaticIP());

  WiFi.mode(wifimode);

  delay(30);

}
# 835 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
String WifiGetAPssid()

{

  String ssid(Settings.Name);

  if (Settings.appendUnitToHostname()) {

    ssid+=F("_");

    ssid+=Settings.Unit;

  }

  return (ssid);

}
# 861 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
String WifiGetHostname()

{

  String hostname(WifiGetAPssid());

  hostname.replace(F(" "), F("-"));

  hostname.replace(F("_"), F("-"));

  return (hostname);

}





bool useStaticIP() {

  return (Settings.IP[0] != 0 && Settings.IP[0] != 255);

}



bool WiFiConnected() {



  return wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED;

}



void WiFiConnectRelaxed() {

  if (WiFiConnected())

    return;

  if (prepareWiFi()) {

    if (selectValidWiFiSettings()) {

      tryConnectWiFi();

      return;

    }

  }

  addLog(LOG_LEVEL_ERROR, F("WIFI : Could not connect to AP!"));



  setAP(true);

}
# 931 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
bool prepareWiFi() {

  if (!selectValidWiFiSettings()) {

    addLog(LOG_LEVEL_ERROR, F("WIFI : No valid wifi settings"));

    return false;

  }

  setSTA(true);

  char hostname[40];

  strncpy(hostname, WifiGetHostname().c_str(), sizeof(hostname));

  #if defined(ESP8266)

    wifi_station_set_hostname(hostname);

  #endif

  #if defined(ESP32)

    WiFi.setHostname(hostname);

  #endif

  return true;

}
# 973 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
const char* getLastWiFiSettingsSSID() {

  return lastWiFiSettings == 0 ? SecuritySettings.WifiSSID : SecuritySettings.WifiSSID2;

}



const char* getLastWiFiSettingsPassphrase() {

  return lastWiFiSettings == 0 ? SecuritySettings.WifiKey : SecuritySettings.WifiKey2;

}



bool selectNextWiFiSettings() {

  uint8_t tmp = lastWiFiSettings;

  lastWiFiSettings = (lastWiFiSettings + 1) % 2;

  if (!wifiSettingsValid(getLastWiFiSettingsSSID(), getLastWiFiSettingsPassphrase())) {



    lastWiFiSettings = tmp;

    return false;

  }

  return true;

}



bool selectValidWiFiSettings() {

  if (wifiSettingsValid(getLastWiFiSettingsSSID(), getLastWiFiSettingsPassphrase()))

    return true;

  return selectNextWiFiSettings();

}



bool wifiSettingsValid(const char* ssid, const char* pass) {

  if (ssid[0] == 0 || (strcasecmp(ssid, "ssid") == 0)) {

    return false;

  }



  if (strlen(ssid) > 32) return false;

  if (strlen(pass) > 64) return false;

  return true;

}



bool wifiConnectTimeoutReached() {

  if (wifi_connect_attempt == 0) return true;

  if (timeDiff(last_wifi_connect_attempt_moment, lastDisconnectMoment) >0 ) {



    return true;

  }

  if (WifiIsAP(WiFi.getMode())) {



    return timeOutReached(last_wifi_connect_attempt_moment + 20000);

  }





  #if defined(ESP8266)

  const unsigned int randomOffset_in_sec = wifi_connect_attempt == 1 ? 0 : 1000 * ((ESP.getChipId() & 0xF));

  #endif

  #if defined(ESP32)

  const unsigned int randomOffset_in_sec = wifi_connect_attempt == 1 ? 0 : 1000 * ((ESP.getEfuseMac() & 0xF));

  #endif

  return timeOutReached(last_wifi_connect_attempt_moment + DEFAULT_WIFI_CONNECTION_TIMEOUT + randomOffset_in_sec);

}



void setupStaticIPconfig() {

  setUseStaticIP(useStaticIP());

  if (!useStaticIP()) return;

  const IPAddress ip = Settings.IP;

  const IPAddress gw = Settings.Gateway;

  const IPAddress subnet = Settings.Subnet;

  const IPAddress dns = Settings.DNS;

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    String log = F("IP   : Static IP : ");

    log += formatIP(ip);

    log += F(" GW: ");

    log += formatIP(gw);

    log += F(" SN: ");

    log += formatIP(subnet);

    log += F(" DNS: ");

    log += formatIP(dns);

    addLog(LOG_LEVEL_INFO, log);

  }

  WiFi.config(ip, gw, subnet, dns);

}
# 1133 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
bool tryConnectWiFi() {

  if (wifiSetupConnect) {

    lastWiFiSettings = 0;

    wifi_connect_attempt = 0;

  }

  if (wifiStatus != ESPEASY_WIFI_DISCONNECTED) {

    if (!WifiIsAP(WiFi.getMode())) {



      return(true);

    }

  }

  if (!wifiConnectTimeoutReached())

    return true;

  if (!selectValidWiFiSettings()) {

    addLog(LOG_LEVEL_ERROR, F("WIFI : No valid WiFi settings!"));

    return false;

  }

  if (wifi_connect_attempt != 0 && (wifi_connect_attempt % 2) == 0) {

    selectNextWiFiSettings();

  }

  if (wifi_connect_attempt > 5) {

    setAP(true);

  }

  const char* ssid = getLastWiFiSettingsSSID();

  const char* passphrase = getLastWiFiSettingsPassphrase();

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    String log = F("WIFI : Connecting ");

    log += ssid;

    log += F(" attempt #");

    log += wifi_connect_attempt;

    addLog(LOG_LEVEL_INFO, log);

  }

  setupStaticIPconfig();

  last_wifi_connect_attempt_moment = millis();

  switch (wifi_connect_attempt) {

    case 0:

      if (lastBSSID[0] == 0)

        WiFi.begin(ssid, passphrase);

      else

        WiFi.begin(ssid, passphrase, 0, &lastBSSID[0]);

      break;

    default:

      WiFi.begin(ssid, passphrase);

  }

  ++wifi_connect_attempt;

  logConnectionStatus();

  switch (WiFi.status()) {

    case WL_NO_SSID_AVAIL: {

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {

        String log = F("WIFI : No SSID found matching: ");

        log += ssid;

        addLog(LOG_LEVEL_INFO, log);

      }

      return false;

    }

    case WL_CONNECT_FAILED: {

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {

        String log = F("WIFI : Connection failed to: ");

        log += ssid;

        addLog(LOG_LEVEL_INFO, log);

      }

      return false;

    }

    default:

     break;

  }

  return true;

}
# 1277 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
void WifiDisconnect()

{

  #if defined(ESP32)

    WiFi.disconnect();

  #else

    ETS_UART_INTR_DISABLE();

    wifi_station_disconnect();

    ETS_UART_INTR_ENABLE();

  #endif

}
# 1307 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
void WifiScan()

{



  Serial.println(F("WIFI : SSID Scan start"));

  int n = WiFi.scanNetworks(false, true);

  if (n == 0)

    Serial.println(F("WIFI : No networks found"));

  else

  {

    Serial.print(F("WIFI : "));

    Serial.print(n);

    Serial.println(F(" networks found"));

    for (int i = 0; i < n; ++i)

    {



      Serial.print(F("WIFI : "));

      Serial.print(i + 1);

      Serial.print(": ");

      Serial.println(formatScanResult(i, " "));

      delay(10);

    }

  }

  Serial.println("");

}



String formatScanResult(int i, const String& separator) {

  String result = WiFi.SSID(i);

  #ifndef ESP32

  if (WiFi.isHidden(i)) {

    result += F("#Hidden#");

  }

  #endif

  result += separator;

  result += WiFi.BSSIDstr(i);

  result += separator;

  result += F("Ch:");

  result += WiFi.channel(i);

  result += F(" (");

  result += WiFi.RSSI(i);

  result += F("dBm) ");

  switch (WiFi.encryptionType(i)) {

  #ifdef ESP32

    case WIFI_AUTH_OPEN: result += F("open"); break;

    case WIFI_AUTH_WEP: result += F("WEP"); break;

    case WIFI_AUTH_WPA_PSK: result += F("WPA/PSK"); break;

    case WIFI_AUTH_WPA2_PSK: result += F("WPA2/PSK"); break;

    case WIFI_AUTH_WPA_WPA2_PSK: result += F("WPA/WPA2/PSK"); break;

    case WIFI_AUTH_WPA2_ENTERPRISE: result += F("WPA2 Enterprise"); break;

  #else

    case ENC_TYPE_WEP: result += F("WEP"); break;

    case ENC_TYPE_TKIP: result += F("WPA/PSK"); break;

    case ENC_TYPE_CCMP: result += F("WPA2/PSK"); break;

    case ENC_TYPE_NONE: result += F("open"); break;

    case ENC_TYPE_AUTO: result += F("WPA/WPA2/PSK"); break;

  #endif

    default:

      break;

  }

  return result;

}



#ifndef ESP32

String SDKwifiStatusToString(uint8_t sdk_wifistatus) {

  switch (sdk_wifistatus) {

    case STATION_IDLE: return F("STATION_IDLE");

    case STATION_CONNECTING: return F("STATION_CONNECTING");

    case STATION_WRONG_PASSWORD: return F("STATION_WRONG_PASSWORD");

    case STATION_NO_AP_FOUND: return F("STATION_NO_AP_FOUND");

    case STATION_CONNECT_FAIL: return F("STATION_CONNECT_FAIL");

    case STATION_GOT_IP: return F("STATION_GOT_IP");

  }

  return F("Unknown");

}

#endif



String ArduinoWifiStatusToString(uint8_t arduino_corelib_wifistatus) {

  String log;

  switch (arduino_corelib_wifistatus) {

    case WL_IDLE_STATUS: log += F("WL_IDLE_STATUS"); break;

    case WL_NO_SSID_AVAIL: log += F("WL_NO_SSID_AVAIL"); break;

    case WL_SCAN_COMPLETED: log += F("WL_SCAN_COMPLETED"); break;

    case WL_CONNECTED: log += F("WL_CONNECTED"); break;

    case WL_CONNECT_FAILED: log += F("WL_CONNECT_FAILED"); break;

    case WL_CONNECTION_LOST: log += F("WL_CONNECTION_LOST"); break;

    case WL_DISCONNECTED: log += F("WL_DISCONNECTED"); break;

    default: log += arduino_corelib_wifistatus; break;

  }

  return log;

}



String ESPeasyWifiStatusToString() {

  String log;

  switch (wifiStatus) {

    case ESPEASY_WIFI_DISCONNECTED: log += F("ESPEASY_WIFI_DISCONNECTED"); break;

    case ESPEASY_WIFI_CONNECTED: log += F("ESPEASY_WIFI_CONNECTED"); break;

    case ESPEASY_WIFI_GOT_IP: log += F("ESPEASY_WIFI_GOT_IP"); break;

    case ESPEASY_WIFI_SERVICES_INITIALIZED: log += F("ESPEASY_WIFI_SERVICES_INITIALIZED"); break;

    default: log += wifiStatus;

  }

  return log;

}



void logConnectionStatus() {

  const uint8_t arduino_corelib_wifistatus = WiFi.status();

  String log;

  #ifndef ESP32

  const uint8_t sdk_wifistatus = wifi_station_get_connect_status();

  if ((arduino_corelib_wifistatus == WL_CONNECTED) != (sdk_wifistatus == STATION_GOT_IP)) {

    if (loglevelActiveFor(LOG_LEVEL_ERROR)) {

      String log = F("WIFI  : SDK station status differs from Arduino status. SDK-status: ");

      log += SDKwifiStatusToString(sdk_wifistatus);

      log += F(" Arduino status: ");

      log += ArduinoWifiStatusToString(arduino_corelib_wifistatus);

      addLog(LOG_LEVEL_ERROR, log);

    }

  }

  #endif

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE)) {

    String log = F("WIFI  : Arduino wifi status: ");

    log += ArduinoWifiStatusToString(arduino_corelib_wifistatus);

    log += F(" ESPeasy internal wifi status: ");

    log += ESPeasyWifiStatusToString();

    addLog(LOG_LEVEL_DEBUG_MORE, log);

  }

}
# 1567 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
void WifiCheck()

{

  if(wifiSetup)

    return;



  processDisableAPmode();

  IPAddress ip = WiFi.localIP();

  if (!useStaticIP()) {

    if (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] == 0) {

      if (WiFiConnected()) {



        resetWiFi();

      }

    }

  }



  if (wifiStatus != ESPEASY_WIFI_SERVICES_INITIALIZED) {

    if (timeOutReached(last_wifi_connect_attempt_moment + (1000 + wifi_connect_attempt * 200))) {

      WiFiConnectRelaxed();

    }

  }

  if (mqtt_reconnect_count > 10) {

    connectionCheckHandler();

  }

}
# 1625 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPEasyWifi.ino"
bool getSubnetRange(IPAddress& low, IPAddress& high)

{

  if (WifiIsAP(WiFi.getMode())) {



    return false;

  }

  if (wifiStatus < ESPEASY_WIFI_GOT_IP) {

    return false;

  }

  const IPAddress ip = WiFi.localIP();

  const IPAddress subnet = WiFi.subnetMask();

  low = ip;

  high = ip;



  for (byte i=0; i < 4; ++i) {

    if (subnet[i] != 255) {

      low[i] = low[i] & subnet[i];

      high[i] = high[i] | ~subnet[i];

    }

  }

  return true;

}





String getLastDisconnectReason() {

  String reason = F("(");

  reason += lastDisconnectReason;

  reason += F(") ");

  switch (lastDisconnectReason) {

    case WIFI_DISCONNECT_REASON_UNSPECIFIED: reason += F("Unspecified"); break;

    case WIFI_DISCONNECT_REASON_AUTH_EXPIRE: reason += F("Auth expire"); break;

    case WIFI_DISCONNECT_REASON_AUTH_LEAVE: reason += F("Auth leave"); break;

    case WIFI_DISCONNECT_REASON_ASSOC_EXPIRE: reason += F("Assoc expire"); break;

    case WIFI_DISCONNECT_REASON_ASSOC_TOOMANY: reason += F("Assoc toomany"); break;

    case WIFI_DISCONNECT_REASON_NOT_AUTHED: reason += F("Not authed"); break;

    case WIFI_DISCONNECT_REASON_NOT_ASSOCED: reason += F("Not assoced"); break;

    case WIFI_DISCONNECT_REASON_ASSOC_LEAVE: reason += F("Assoc leave"); break;

    case WIFI_DISCONNECT_REASON_ASSOC_NOT_AUTHED: reason += F("Assoc not authed"); break;

    case WIFI_DISCONNECT_REASON_DISASSOC_PWRCAP_BAD: reason += F("Disassoc pwrcap bad"); break;

    case WIFI_DISCONNECT_REASON_DISASSOC_SUPCHAN_BAD: reason += F("Disassoc supchan bad"); break;

    case WIFI_DISCONNECT_REASON_IE_INVALID: reason += F("IE invalid"); break;

    case WIFI_DISCONNECT_REASON_MIC_FAILURE: reason += F("Mic failure"); break;

    case WIFI_DISCONNECT_REASON_4WAY_HANDSHAKE_TIMEOUT: reason += F("4way handshake timeout"); break;

    case WIFI_DISCONNECT_REASON_GROUP_KEY_UPDATE_TIMEOUT: reason += F("Group key update timeout"); break;

    case WIFI_DISCONNECT_REASON_IE_IN_4WAY_DIFFERS: reason += F("IE in 4way differs"); break;

    case WIFI_DISCONNECT_REASON_GROUP_CIPHER_INVALID: reason += F("Group cipher invalid"); break;

    case WIFI_DISCONNECT_REASON_PAIRWISE_CIPHER_INVALID: reason += F("Pairwise cipher invalid"); break;

    case WIFI_DISCONNECT_REASON_AKMP_INVALID: reason += F("AKMP invalid"); break;

    case WIFI_DISCONNECT_REASON_UNSUPP_RSN_IE_VERSION: reason += F("Unsupp RSN IE version"); break;

    case WIFI_DISCONNECT_REASON_INVALID_RSN_IE_CAP: reason += F("Invalid RSN IE cap"); break;

    case WIFI_DISCONNECT_REASON_802_1X_AUTH_FAILED: reason += F("802 1X auth failed"); break;

    case WIFI_DISCONNECT_REASON_CIPHER_SUITE_REJECTED: reason += F("Cipher suite rejected"); break;

    case WIFI_DISCONNECT_REASON_BEACON_TIMEOUT: reason += F("Beacon timeout"); break;

    case WIFI_DISCONNECT_REASON_NO_AP_FOUND: reason += F("No AP found"); break;

    case WIFI_DISCONNECT_REASON_AUTH_FAIL: reason += F("Auth fail"); break;

    case WIFI_DISCONNECT_REASON_ASSOC_FAIL: reason += F("Assoc fail"); break;

    case WIFI_DISCONNECT_REASON_HANDSHAKE_TIMEOUT: reason += F("Handshake timeout"); break;

    default: reason += F("Unknown"); break;

  }

  return reason;

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/ESPeasyGPIO.ino"
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Hardware.ino"
# 9 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Hardware.ino"
void hardwareInit()

{





  for (byte x=0; x < 17; x++)

    if (Settings.PinBootStates[x] != 0)

      switch(Settings.PinBootStates[x])

      {

        case 1:

          pinMode(x,OUTPUT);

          digitalWrite(x,LOW);

          setPinState(1, x, PIN_MODE_OUTPUT, LOW);

          break;

        case 2:

          pinMode(x,OUTPUT);

          digitalWrite(x,HIGH);

          setPinState(1, x, PIN_MODE_OUTPUT, HIGH);

          break;

        case 3:

          pinMode(x,INPUT_PULLUP);

          setPinState(1, x, PIN_MODE_INPUT, 0);

          break;

      }



  if (Settings.Pin_Reset != -1)

    pinMode(Settings.Pin_Reset,INPUT_PULLUP);





  if (Settings.Pin_i2c_sda != -1)

  {

    String log = F("INIT : I2C");

    addLog(LOG_LEVEL_INFO, log);

    Wire.begin(Settings.Pin_i2c_sda, Settings.Pin_i2c_scl);

      if(Settings.WireClockStretchLimit)

      {

        String log = F("INIT : I2C custom clockstretchlimit:");

        log += Settings.WireClockStretchLimit;

        addLog(LOG_LEVEL_INFO, log);

        #if defined(ESP8266)

          Wire.setClockStretchLimit(Settings.WireClockStretchLimit);

        #endif

      }

  }





  if (Settings.WDI2CAddress != 0)

  {

    delay(500);

    Wire.beginTransmission(Settings.WDI2CAddress);

    Wire.write(0x83);

    Wire.write(17);

    Wire.endTransmission();



    Wire.requestFrom(Settings.WDI2CAddress, (uint8_t)1);

    if (Wire.available())

    {

      byte status = Wire.read();

      if (status & 0x1)

      {

        String log = F("INIT : Reset by WD!");

        addLog(LOG_LEVEL_ERROR, log);

        lastBootCause = BOOT_CAUSE_EXT_WD;

      }

    }

  }





  if (Settings.InitSPI)

  {

    SPI.setHwCs(false);

    SPI.begin();

    String log = F("INIT : SPI Init (without CS)");

    addLog(LOG_LEVEL_INFO, log);

  }

  else

  {

    String log = F("INIT : SPI not enabled");

    addLog(LOG_LEVEL_INFO, log);

  }



#ifdef FEATURE_SD

  if (Settings.Pin_sd_cs >= 0)

  {

    if (SD.begin(Settings.Pin_sd_cs))

    {

      String log = F("SD   : Init OK");

      addLog(LOG_LEVEL_INFO, log);

    }

    else

    {

      String log = F("SD   : Init failed");

      addLog(LOG_LEVEL_ERROR, log);

    }

  }

#endif



}



void checkResetFactoryPin(){

  static byte factoryResetCounter=0;

  if (Settings.Pin_Reset == -1)

    return;



  if (digitalRead(Settings.Pin_Reset) == 0){

    factoryResetCounter++;

  }

  else

  {

    if (factoryResetCounter > 9)

      ResetFactory();

    if (factoryResetCounter > 3)

    #if defined(ESP8266)

      ESP.reset();

    #endif

    #if defined(ESP32)

      ESP.restart();

    #endif



    factoryResetCounter = 0;

  }

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"






bool I2C_read_bytes(uint8_t i2caddr, I2Cdata_bytes& data) {

  const uint8_t size = data.getSize();

  return size == i2cdev.readBytes(i2caddr, data.getRegister(), size, data.get());

}



bool I2C_read_words(uint8_t i2caddr, I2Cdata_words& data) {

  const uint8_t size = data.getSize();

  return size == i2cdev.readWords(i2caddr, data.getRegister(), size, data.get());

}





#ifdef ESP32

  #define END_TRANSMISSION_FLAG true

#else

  #define END_TRANSMISSION_FLAG false

#endif
# 47 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"
void I2C_wakeup(uint8_t i2caddr) {

  Wire.beginTransmission(i2caddr);

  Wire.endTransmission();

}
# 63 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"
bool I2C_write8(uint8_t i2caddr, byte value) {

  Wire.beginTransmission(i2caddr);

  Wire.write((uint8_t)value);

  return (Wire.endTransmission() == 0);

}
# 83 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"
bool I2C_write8_reg(uint8_t i2caddr, byte reg, byte value) {

  Wire.beginTransmission(i2caddr);

  Wire.write((uint8_t)reg);

  Wire.write((uint8_t)value);

  return (Wire.endTransmission() == 0);

}
# 103 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"
bool I2C_write16_reg(uint8_t i2caddr, byte reg, uint16_t value) {

  Wire.beginTransmission(i2caddr);

  Wire.write((uint8_t)reg);

  Wire.write((uint8_t)(value >> 8));

  Wire.write((uint8_t)value);

  return (Wire.endTransmission() == 0);

}
# 125 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"
bool I2C_write16_LE_reg(uint8_t i2caddr, byte reg, uint16_t value) {

  return (I2C_write16_reg(i2caddr, reg, (value << 8)|(value >> 8)));

}
# 139 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"
uint8_t I2C_read8_reg(uint8_t i2caddr, byte reg, bool * is_ok) {

  uint8_t value;



  Wire.beginTransmission(i2caddr);

  Wire.write((uint8_t)reg);

  Wire.endTransmission(END_TRANSMISSION_FLAG);

  byte count = Wire.requestFrom(i2caddr, (byte)1);

  if (is_ok != NULL) {

    *is_ok = (count == 1);

  }

  value = Wire.read();



  return value;

}
# 175 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"
uint16_t I2C_read16_reg(uint8_t i2caddr, byte reg) {

  uint16_t value(0);



  Wire.beginTransmission(i2caddr);

  Wire.write((uint8_t)reg);

  Wire.endTransmission(END_TRANSMISSION_FLAG);

  Wire.requestFrom(i2caddr, (byte)2);

  value = (Wire.read() << 8) | Wire.read();



  return value;

}
# 205 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"
int32_t I2C_read24_reg(uint8_t i2caddr, byte reg) {

  int32_t value;



  Wire.beginTransmission(i2caddr);

  Wire.write((uint8_t)reg);

  Wire.endTransmission(END_TRANSMISSION_FLAG);

  Wire.requestFrom(i2caddr, (byte)3);

  value = (((int32_t)Wire.read()) << 16) | (Wire.read() << 8) | Wire.read();



  return value;

}
# 235 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"
int32_t I2C_read32_reg(uint8_t i2caddr, byte reg) {

  int32_t value;



  Wire.beginTransmission(i2caddr);

  Wire.write((uint8_t)reg);

  Wire.endTransmission(END_TRANSMISSION_FLAG);

  Wire.requestFrom(i2caddr, (byte)3);

  value = (((int32_t)Wire.read()) <<24) | (((uint32_t)Wire.read()) << 16) | (Wire.read() << 8) | Wire.read();



  return value;

}
# 265 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"
uint16_t I2C_read16_LE_reg(uint8_t i2caddr, byte reg) {

  uint16_t temp = I2C_read16_reg(i2caddr, reg);

  return (temp >> 8) | (temp << 8);

}
# 281 "C:/Users/admin/Documents/GitHub/ESPEasy/src/I2C.ino"
int16_t I2C_readS16_reg(uint8_t i2caddr, byte reg) {

  return (int16_t)I2C_read16_reg(i2caddr, reg);

}



int16_t I2C_readS16_LE_reg(uint8_t i2caddr, byte reg) {

  return (int16_t)I2C_read16_LE_reg(i2caddr, reg);

}



#undef END_TRANSMISSION_FLAG
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
#if defined(ESP8266)

  #include <md5.h>

#endif

#if defined(ESP8266)



struct tcp_pcb;

extern struct tcp_pcb* tcp_tw_pcbs;

extern "C" void tcp_abort (struct tcp_pcb* pcb);



void tcpCleanup()

{



     while(tcp_tw_pcbs!=NULL)

    {

      tcp_abort(tcp_tw_pcbs);

    }



 }

#endif



bool isDeepSleepEnabled()

{

  if (!Settings.deepSleep)

    return false;
# 69 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
  pinMode(16,INPUT_PULLUP);

  if (!digitalRead(16))

  {

    return false;

  }

  return true;

}



bool readyForSleep()

{

  if (!isDeepSleepEnabled())

    return false;

  if (!checkConnectionsEstablished()) {



    return timeOutReached(timerAwakeFromDeepSleep + 12000);

  }

  return timeOutReached(timerAwakeFromDeepSleep + 1000 * Settings.deepSleep);

}



void deepSleep(int delay)

{



  checkRAM(F("deepSleep"));

  if (!isDeepSleepEnabled())

  {



    return;

  }





  if (lastBootCause!=BOOT_CAUSE_DEEP_SLEEP)

  {

    addLog(LOG_LEVEL_INFO, F("SLEEP: Entering deep sleep in 30 seconds."));

    delayBackground(30000);



    if (!isDeepSleepEnabled())

    {

      addLog(LOG_LEVEL_INFO, F("SLEEP: Deep sleep cancelled (GPIO16 connected to GND)"));

      return;

    }

  }

  saveUserVarToRTC();

  deepSleepStart(delay);

}



void deepSleepStart(int delay)

{



  String event = F("System#Sleep");

  rulesProcessing(event);





  RTC.deepSleepState = 1;

  saveToRTC();



  if (delay > 4294 || delay < 0)

    delay = 4294;



  addLog(LOG_LEVEL_INFO, F("SLEEP: Powering down to deepsleep..."));

  #if defined(ESP8266)

    ESP.deepSleep((uint32_t)delay * 1000000, WAKE_RF_DEFAULT);

  #endif

  #if defined(ESP32)

    esp_sleep_enable_timer_wakeup((uint32_t)delay * 1000000);

    esp_deep_sleep_start();

  #endif

}



boolean remoteConfig(struct EventStruct *event, const String& string)

{

  checkRAM(F("remoteConfig"));

  boolean success = false;

  String command = parseString(string, 1);



  if (command == F("config"))

  {

    success = true;

    if (parseString(string, 2) == F("task"))

    {

      String configTaskName = parseStringKeepCase(string, 3);

      String configCommand = parseStringToEndKeepCase(string, 4);

      if (configTaskName.length() == 0 || configCommand.length() == 0)

        return success;



      int8_t index = getTaskIndexByName(configTaskName);

      if (index != -1)

      {

        event->TaskIndex = index;

        success = PluginCall(PLUGIN_SET_CONFIG, event, configCommand);

      }

    }

  }

  return success;

}



int8_t getTaskIndexByName(String TaskNameSearch)

{



  for (byte x = 0; x < TASKS_MAX; x++)

  {

    LoadTaskSettings(x);

    String TaskName = getTaskDeviceName(x);

    if ((TaskName.length() != 0 ) && (TaskNameSearch.equalsIgnoreCase(TaskName)))

    {

      return x;

    }

  }

  return -1;

}
# 299 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void setPinState(byte plugin, byte index, byte mode, uint16_t value)

{





  boolean reUse = false;

  for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

    if ((pinStates[x].plugin == plugin) && (pinStates[x].index == index))

    {

      pinStates[x].mode = mode;

      pinStates[x].value = value;

      reUse = true;

      break;

    }



  if (!reUse)

  {

    for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

      if (pinStates[x].plugin == 0)

      {

        pinStates[x].plugin = plugin;

        pinStates[x].index = index;

        pinStates[x].mode = mode;

        pinStates[x].value = value;

        break;

      }

  }

}
# 363 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
boolean getPinState(byte plugin, byte index, byte *mode, uint16_t *value)

{

  for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

    if ((pinStates[x].plugin == plugin) && (pinStates[x].index == index))

    {

      *mode = pinStates[x].mode;

      *value = pinStates[x].value;

      return true;

    }

  return false;

}
# 395 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
boolean hasPinState(byte plugin, byte index)

{

  for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

    if ((pinStates[x].plugin == plugin) && (pinStates[x].index == index))

    {

      return true;

    }

  return false;

}
# 423 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
bool getBitFromUL(uint32_t number, byte bitnr) {

  return (number >> bitnr) & 1UL;

}



void setBitToUL(uint32_t& number, byte bitnr, bool value) {

  uint32_t newbit = value ? 1UL : 0UL;

  number ^= (-newbit ^ number) & (1UL << bitnr);

}
# 449 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
String getPinStateJSON(boolean search, byte plugin, byte index, String& log, uint16_t noSearchValue)

{

  checkRAM(F("getPinStateJSON"));

  printToWebJSON = true;

  byte mode = PIN_MODE_INPUT;

  uint16_t value = noSearchValue;

  String reply = "";

  boolean found = false;



  if (search)

  {

    for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

      if ((pinStates[x].plugin == plugin) && (pinStates[x].index == index))

      {

        mode = pinStates[x].mode;

        value = pinStates[x].value;

        found = true;

        break;

      }

  }



  if (!search || (search && found))

  {

    reply += F("{\n\"log\": \"");

    reply += log.substring(7, 32);

    reply += F("\",\n\"plugin\": ");

    reply += plugin;

    reply += F(",\n\"pin\": ");

    reply += index;

    reply += F(",\n\"mode\": \"");

    switch (mode)

    {

      case PIN_MODE_UNDEFINED:

        reply += F("undefined");

        break;

      case PIN_MODE_INPUT:

        reply += F("input");

        break;

      case PIN_MODE_OUTPUT:

        reply += F("output");

        break;

      case PIN_MODE_PWM:

        reply += F("PWM");

        break;

      case PIN_MODE_SERVO:

        reply += F("servo");

        break;

    }

    reply += F("\",\n\"state\": ");

    reply += value;

    reply += F("\n}\n");

    return reply;

  }

  return "?";

}
# 569 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
#if defined(ESP32)

  #define PWMRANGE 1024

#endif

#define STATUS_PWM_NORMALVALUE (PWMRANGE>>2)

#define STATUS_PWM_NORMALFADE (PWMRANGE>>8)

#define STATUS_PWM_TRAFFICRISE (PWMRANGE>>1)



void statusLED(boolean traffic)

{

  static int gnStatusValueCurrent = -1;

  static long int gnLastUpdate = millis();



  if (Settings.Pin_status_led == -1)

    return;



  if (gnStatusValueCurrent<0)

    pinMode(Settings.Pin_status_led, OUTPUT);



  int nStatusValue = gnStatusValueCurrent;



  if (traffic)

  {

    nStatusValue += STATUS_PWM_TRAFFICRISE;

  }

  else

  {



    if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED)

    {

      long int delta = timePassedSince(gnLastUpdate);

      if (delta>0 || delta<0 )

      {

        nStatusValue -= STATUS_PWM_NORMALFADE;

        nStatusValue = std::max(nStatusValue, STATUS_PWM_NORMALVALUE);

        gnLastUpdate=millis();

      }

    }



    else if (WifiIsAP(WiFi.getMode()))

    {

      nStatusValue = ((millis()>>1) & PWMRANGE) - (PWMRANGE>>2);

    }



    else

    {

      nStatusValue = (millis()>>1) & (PWMRANGE>>2);

    }

  }



  nStatusValue = constrain(nStatusValue, 0, PWMRANGE);



  if (gnStatusValueCurrent != nStatusValue)

  {

    gnStatusValueCurrent = nStatusValue;



    long pwm = nStatusValue * nStatusValue;

    pwm >>= 10;

    if (Settings.Pin_status_led_Inversed)

      pwm = PWMRANGE-pwm;



    #if defined(ESP8266)

      analogWrite(Settings.Pin_status_led, pwm);

    #endif

  }

}
# 709 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void delayBackground(unsigned long delay)

{

  unsigned long timer = millis() + delay;

  while (!timeOutReached(timer))

    backgroundtasks();

}
# 731 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void parseCommandString(struct EventStruct *event, const String& string)

{

  checkRAM(F("parseCommandString"));

  char command[INPUT_COMMAND_SIZE];

  command[0] = 0;

  char TmpStr1[INPUT_COMMAND_SIZE];

  TmpStr1[0] = 0;



  string.toCharArray(command, INPUT_COMMAND_SIZE);

  event->Par1 = 0;

  event->Par2 = 0;

  event->Par3 = 0;

  event->Par4 = 0;

  event->Par5 = 0;



  if (GetArgv(command, TmpStr1, 2)) event->Par1 = CalculateParam(TmpStr1);

  if (GetArgv(command, TmpStr1, 3)) event->Par2 = CalculateParam(TmpStr1);

  if (GetArgv(command, TmpStr1, 4)) event->Par3 = CalculateParam(TmpStr1);

  if (GetArgv(command, TmpStr1, 5)) event->Par4 = CalculateParam(TmpStr1);

  if (GetArgv(command, TmpStr1, 6)) event->Par5 = CalculateParam(TmpStr1);

}
# 781 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void taskClear(byte taskIndex, boolean save)

{

  checkRAM(F("taskClear"));

  Settings.clearTask(taskIndex);

  ExtraTaskSettings.clear();

  ExtraTaskSettings.TaskIndex = taskIndex;

  if (save) {

    SaveTaskSettings(taskIndex);

    SaveSettings();

  }

}



String checkTaskSettings(byte taskIndex) {

  String err = LoadTaskSettings(taskIndex);

  if (err.length() > 0) return err;

  if (!ExtraTaskSettings.checkUniqueValueNames()) {

    return F("Use unique value names");

  }

  if (!ExtraTaskSettings.checkInvalidCharInNames()) {

    return F("Invalid character in names. Do not use ',#[]' or space.");

  }

  String deviceName = ExtraTaskSettings.TaskDeviceName;

  if (deviceName.length() == 0) {

    if (Settings.TaskDeviceEnabled[taskIndex]) {



      return F("Warning: Task Device Name is empty. It is adviced to give tasks an unique name");

    }

  }

  for (int i = 0; i < TASKS_MAX; ++i) {

    if (i != taskIndex && Settings.TaskDeviceEnabled[i]) {

      LoadTaskSettings(i);

      if (ExtraTaskSettings.TaskDeviceName[0] != 0) {

        if (strcasecmp(ExtraTaskSettings.TaskDeviceName, deviceName.c_str()) == 0) {

          err = F("Task Device Name is not unique, conflicts with task ID #");

          err += (i+1);

          return err;

        }

      }

    }

  }



  err = LoadTaskSettings(taskIndex);

  return err;

}
# 881 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
byte getDeviceIndex(byte Number)

{

  for (byte x = 0; x <= deviceCount ; x++) {

    if (Device[x].Number == Number) {

      return x;

    }

  }

  return 0;

}
# 907 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
String getPluginNameFromDeviceIndex(byte deviceIndex) {

  String deviceName = "";

  Plugin_ptr[deviceIndex](PLUGIN_GET_DEVICENAME, 0, deviceName);

  return deviceName;

}
# 927 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
byte getProtocolIndex(byte Number)

{

  for (byte x = 0; x <= protocolCount ; x++) {

    if (Protocol[x].Number == Number) {

      return x;

    }

  }

  return 0;

}
# 953 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
byte getNotificationProtocolIndex(byte Number)

{

  for (byte x = 0; x <= notificationCount ; x++) {

    if (Notification[x].Number == Number) {

      return(x);

    }

  }

  return(NPLUGIN_NOT_FOUND);

}
# 979 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
boolean GetArgv(const char *string, char *argv, unsigned int argc) {

  return GetArgv(string, argv, INPUT_COMMAND_SIZE, argc);

}



boolean GetArgv(const char *string, char *argv, unsigned int argv_size, unsigned int argc)

{

  unsigned int string_pos = 0, argv_pos = 0, argc_pos = 0;

  char c, d;

  boolean parenthesis = false;

  char matching_parenthesis = '"';



  while (string_pos < strlen(string))

  {

    c = string[string_pos];

    d = string[string_pos + 1];



    if (!parenthesis && c == ' ' && d == ' ') {}

    else if (!parenthesis && c == ' ' && d == ',') {}

    else if (!parenthesis && c == ',' && d == ' ') {}

    else if (!parenthesis && c == ' ' && d >= 33 && d <= 126) {}

    else if (!parenthesis && c == ',' && d >= 33 && d <= 126) {}

    else if (c == '"' || c == '\'' || c == '[') {

      parenthesis = true;

      matching_parenthesis = c;

      if (c == '[')

        matching_parenthesis = ']';

    }

    else

    {

      if ((argv_pos +2 ) >= argv_size) {

        if (loglevelActiveFor(LOG_LEVEL_ERROR)) {

          String log = F("GetArgv Error; argv_size exceeded. argc=");

          log += argc;

          log += F(" argv_size=");

          log += argv_size;

          log += F(" argv=");

          log += argv;

          addLog(LOG_LEVEL_ERROR, log);

        }

        return false;

      }

      argv[argv_pos++] = c;

      argv[argv_pos] = 0;



      if ((!parenthesis && (d == ' ' || d == ',' || d == 0)) || (parenthesis && (d == matching_parenthesis)))

      {

        if (d == matching_parenthesis)

          parenthesis = false;

        argv[argv_pos] = 0;

        argc_pos++;



        if (argc_pos == argc)

        {

          return true;

        }



        argv[0] = 0;

        argv_pos = 0;

        string_pos++;

      }

    }

    string_pos++;

  }

  return false;

}
# 1143 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
#if defined(ARDUINO_ESP8266_RELEASE_2_3_0)

void dump (uint32_t addr) {

  Serial.print (addr, HEX);

  Serial.print(": ");

  for (uint32_t a = addr; a < addr + 16; a++)

  {

    Serial.print ( pgm_read_byte(a), HEX);

    Serial.print (" ");

  }

  Serial.println("");

}

#endif



uint32_t progMemMD5check(){

    checkRAM(F("progMemMD5check"));

    #define BufSize 10

    uint32_t calcBuffer[BufSize];

    CRCValues.numberOfCRCBytes = 0;

    memcpy (calcBuffer,CRCValues.compileTimeMD5,16);

    if( memcmp (calcBuffer, "MD5_MD5_MD5_",12)==0){

        addLog(LOG_LEVEL_INFO, F("CRC  : No program memory checksum found. Check output of crc2.py"));

        return 0;

    }

    MD5Builder md5;

    md5.begin();

    for (int l = 0; l<4; l++){

        uint32_t *ptrStart = (uint32_t *)&CRCValues.compileTimeMD5[16+l*4];

        uint32_t *ptrEnd = (uint32_t *)&CRCValues.compileTimeMD5[16+4*4+l*4];

        if ((*ptrStart) == 0) break;

        for (uint32_t i = *ptrStart; i< (*ptrEnd) ; i=i+sizeof(calcBuffer)){

             for (int buf = 0; buf < BufSize; buf ++){

                calcBuffer[buf] = pgm_read_dword((uint32_t*)i+buf);

                CRCValues.numberOfCRCBytes+=sizeof(calcBuffer[0]);

             }

             md5.add((uint8_t *)&calcBuffer[0],(*ptrEnd-i)<sizeof(calcBuffer) ? (*ptrEnd-i):sizeof(calcBuffer) );

        }

   }

   md5.calculate();

   md5.getBytes(CRCValues.runTimeMD5);

   if ( CRCValues.checkPassed()) {

      addLog(LOG_LEVEL_INFO, F("CRC  : program checksum       ...OK"));

      return CRCValues.numberOfCRCBytes;

   }

   addLog(LOG_LEVEL_INFO, F("CRC  : program checksum       ...FAIL"));

   return 0;

}
# 1243 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
String getTaskDeviceName(byte TaskIndex) {

  LoadTaskSettings(TaskIndex);

  return ExtraTaskSettings.TaskDeviceName;

}
# 1261 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void ResetFactory(void)

{



  checkRAM(F("ResetFactory"));



  Serial.println(F("RESET: Resetting factory defaults..."));

  delay(1000);

  if (readFromRTC())

  {

    Serial.print(F("RESET: Warm boot, reset count: "));

    Serial.println(RTC.factoryResetCounter);

    if (RTC.factoryResetCounter >= 3)

    {

      Serial.println(F("RESET: Too many resets, protecting your flash memory (powercycle to solve this)"));

      return;

    }

  }

  else

  {

    Serial.println(F("RESET: Cold boot"));

    initRTC();

  }



  RTC.flashCounter=0;

  RTC.factoryResetCounter++;

  saveToRTC();





  SPIFFS.end();

  Serial.println(F("RESET: formatting..."));

  SPIFFS.format();

  Serial.println(F("RESET: formatting done..."));

  if (!SPIFFS.begin())

  {

    Serial.println(F("RESET: FORMAT SPIFFS FAILED!"));

    return;

  }







  String fname;



  fname=FILE_CONFIG;

  InitFile(fname.c_str(), CONFIG_FILE_SIZE);



  fname=FILE_SECURITY;

  InitFile(fname.c_str(), 4096);



  fname=FILE_NOTIFICATION;

  InitFile(fname.c_str(), 4096);



  fname=FILE_RULES;

  InitFile(fname.c_str(), 0);



  Settings.clearAll();





#if DEFAULT_USE_STATIC_IP

  str2ip((char*)DEFAULT_IP, Settings.IP);

  str2ip((char*)DEFAULT_DNS, Settings.DNS);

  str2ip((char*)DEFAULT_GW, Settings.Gateway);

  str2ip((char*)DEFAULT_SUBNET, Settings.Subnet);

#endif



  Settings.PID = ESP_PROJECT_PID;

  Settings.Version = VERSION;

  Settings.Unit = UNIT;

  strcpy_P(SecuritySettings.WifiSSID, PSTR(DEFAULT_SSID));

  strcpy_P(SecuritySettings.WifiKey, PSTR(DEFAULT_KEY));

  strcpy_P(SecuritySettings.WifiAPKey, PSTR(DEFAULT_AP_KEY));

  SecuritySettings.Password[0] = 0;



  str2ip((char*)DEFAULT_IPRANGE_LOW, SecuritySettings.AllowedIPrangeLow);

  str2ip((char*)DEFAULT_IPRANGE_HIGH, SecuritySettings.AllowedIPrangeHigh);

  SecuritySettings.IPblockLevel = DEFAULT_IP_BLOCK_LEVEL;



  Settings.Delay = DEFAULT_DELAY;

  Settings.Pin_i2c_sda = DEFAULT_PIN_I2C_SDA;

  Settings.Pin_i2c_scl = DEFAULT_PIN_I2C_SCL;

  Settings.Pin_status_led = DEFAULT_PIN_STATUS_LED;

  Settings.Pin_status_led_Inversed = DEFAULT_PIN_STATUS_LED_INVERSED;

  Settings.Pin_sd_cs = -1;

  Settings.Pin_Reset = -1;

  Settings.Protocol[0] = DEFAULT_PROTOCOL;

  strcpy_P(Settings.Name, PSTR(DEFAULT_NAME));

  Settings.deepSleep = false;

  Settings.CustomCSS = false;

  Settings.InitSPI = false;

  for (byte x = 0; x < TASKS_MAX; x++)

  {

    Settings.TaskDevicePin1[x] = -1;

    Settings.TaskDevicePin2[x] = -1;

    Settings.TaskDevicePin3[x] = -1;

    Settings.TaskDevicePin1PullUp[x] = true;

    Settings.TaskDevicePin1Inversed[x] = false;

    for (byte y = 0; y < CONTROLLER_MAX; y++)

      Settings.TaskDeviceSendData[y][x] = true;

    Settings.TaskDeviceTimer[x] = Settings.Delay;

  }

  Settings.Build = BUILD;





 Settings.UseRules = DEFAULT_USE_RULES;



 Settings.MQTTRetainFlag = DEFAULT_MQTT_RETAIN;

 Settings.MessageDelay = DEFAULT_MQTT_DELAY;

 Settings.MQTTUseUnitNameAsClientId = DEFAULT_MQTT_USE_UNITNANE_AS_CLIENTID;



    Settings.UseNTP = DEFAULT_USE_NTP;

 strcpy_P(Settings.NTPHost, PSTR(DEFAULT_NTP_HOST));

 Settings.TimeZone = DEFAULT_TIME_ZONE;

    Settings.DST = DEFAULT_USE_DST;



 str2ip((char*)DEFAULT_SYSLOG_IP, Settings.Syslog_IP);



  setLogLevelFor(LOG_TO_SYSLOG, DEFAULT_SYSLOG_LEVEL);

  setLogLevelFor(LOG_TO_SERIAL, DEFAULT_SERIAL_LOG_LEVEL);

 setLogLevelFor(LOG_TO_WEBLOG, DEFAULT_WEB_LOG_LEVEL);

  setLogLevelFor(LOG_TO_SDCARD, DEFAULT_SD_LOG_LEVEL);

  Settings.SyslogFacility = DEFAULT_SYSLOG_FACILITY;

 Settings.UseValueLogger = DEFAULT_USE_SD_LOG;



 Settings.UseSerial = DEFAULT_USE_SERIAL;

 Settings.BaudRate = DEFAULT_SERIAL_BAUD;
# 1543 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
  SaveSettings();



#if DEFAULT_CONTROLLER

  ControllerSettingsStruct ControllerSettings;

  strcpy_P(ControllerSettings.Subscribe, PSTR(DEFAULT_SUB));

  strcpy_P(ControllerSettings.Publish, PSTR(DEFAULT_PUB));

  strcpy_P(ControllerSettings.MQTTLwtTopic, PSTR(DEFAULT_MQTT_LWT_TOPIC));

  strcpy_P(ControllerSettings.LWTMessageConnect, PSTR(DEFAULT_MQTT_LWT_CONNECT_MESSAGE));

  strcpy_P(ControllerSettings.LWTMessageDisconnect, PSTR(DEFAULT_MQTT_LWT_DISCONNECT_MESSAGE));

  str2ip((char*)DEFAULT_SERVER, ControllerSettings.IP);

  ControllerSettings.HostName[0]=0;

  ControllerSettings.Port = DEFAULT_PORT;

  SaveControllerSettings(0, ControllerSettings);

#endif

  checkRAM(F("ResetFactory2"));

  Serial.println(F("RESET: Succesful, rebooting. (you might need to press the reset button if you've justed flashed the firmware)"));



  delay(1000);

  WiFi.persistent(true);

  intent_to_reboot = true;

  WifiDisconnect();

  WiFi.persistent(false);

  reboot();

}
# 1603 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void emergencyReset()

{



  Serial.begin(115200);

  Serial.write(0xAA);

  Serial.write(0x55);

  delay(1);

  if (Serial.available() == 2)

    if (Serial.read() == 0xAA && Serial.read() == 0x55)

    {

      Serial.println(F("\n\n\rSystem will reset to factory defaults in 10 seconds..."));

      delay(10000);

      ResetFactory();

    }

}
# 1643 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
unsigned long FreeMem(void)

{

  #if defined(ESP8266)

    return system_get_free_heap_size();

  #endif

  #if defined(ESP32)

    return ESP.getFreeHeap();

  #endif

}
# 1669 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
String getLastBootCauseString() {

  switch (lastBootCause)

  {

    case BOOT_CAUSE_MANUAL_REBOOT: return F("Manual reboot");

    case BOOT_CAUSE_DEEP_SLEEP:

       return F("Deep sleep");

    case BOOT_CAUSE_COLD_BOOT:

       return F("Cold boot");

    case BOOT_CAUSE_EXT_WD:

       return F("External Watchdog");

  }

  return F("Unknown");

}



#ifdef ESP32



String getResetReasonString(byte icore) {

  bool isDEEPSLEEP_RESET(false);

  switch (rtc_get_reset_reason( (RESET_REASON) icore)) {

    case NO_MEAN : return F("NO_MEAN");

    case POWERON_RESET : return F("Vbat power on reset");

    case SW_RESET : return F("Software reset digital core");

    case OWDT_RESET : return F("Legacy watch dog reset digital core");

    case DEEPSLEEP_RESET : isDEEPSLEEP_RESET = true; break;

    case SDIO_RESET : return F("Reset by SLC module, reset digital core");

    case TG0WDT_SYS_RESET : return F("Timer Group0 Watch dog reset digital core");

    case TG1WDT_SYS_RESET : return F("Timer Group1 Watch dog reset digital core");

    case RTCWDT_SYS_RESET : return F("RTC Watch dog Reset digital core");

    case INTRUSION_RESET : return F("Instrusion tested to reset CPU");

    case TGWDT_CPU_RESET : return F("Time Group reset CPU");

    case SW_CPU_RESET : return F("Software reset CPU");

    case RTCWDT_CPU_RESET : return F("RTC Watch dog Reset CPU");

    case EXT_CPU_RESET : return F("for APP CPU, reseted by PRO CPU");

    case RTCWDT_BROWN_OUT_RESET : return F("Reset when the vdd voltage is not stable");

    case RTCWDT_RTC_RESET : return F("RTC Watch dog reset digital core and rtc module");

    default: break;

  }

  if (isDEEPSLEEP_RESET) {

    String reason = F("Deep Sleep, Wakeup reason (");

    reason += rtc_get_wakeup_cause();

    reason += ')';

    return reason;

  }

  return F("Unknown");

}

#endif



String getResetReasonString() {

  #ifdef ESP32

  String reason = F("CPU0: ");

  reason += getResetReasonString(0);

  reason += F(" CPU1: ");

  reason += getResetReasonString(1);

  return reason;

  #else

  return ESP.getResetReason();

  #endif

}



uint32_t getFlashRealSizeInBytes() {

  #if defined(ESP32)

    return ESP.getFlashChipSize();

  #else

    return ESP.getFlashChipRealSize();

  #endif

}



String getSystemBuildString() {

  String result;

  result += BUILD;

  result += F(" ");

  result += F(BUILD_NOTES);

  return result;

}



String getPluginDescriptionString() {

  String result;

  #ifdef PLUGIN_BUILD_NORMAL

    result += F(" [Normal]");

  #endif

  #ifdef PLUGIN_BUILD_TESTING

    result += F(" [Testing]");

  #endif

  #ifdef PLUGIN_BUILD_DEV

    result += F(" [Development]");

  #endif

  return result;

}



String getSystemLibraryString() {

  String result;

  #if defined(ESP32)

    result += F("ESP32 SDK ");

    result += ESP.getSdkVersion();

  #else

    result += F("ESP82xx Core ");

    result += ESP.getCoreVersion();

    result += F(", NONOS SDK ");

    result += system_get_sdk_version();

    result += F(", LWIP: ");

    result += getLWIPversion();

  #endif

  return result;

}



#ifndef ESP32

String getLWIPversion() {

  String result;

  result += LWIP_VERSION_MAJOR;

  result += F(".");

  result += LWIP_VERSION_MINOR;

  result += F(".");

  result += LWIP_VERSION_REVISION;

  if (LWIP_VERSION_IS_RC) {

    result += F("-RC");

    result += LWIP_VERSION_RC;

  } else if (LWIP_VERSION_IS_DEVELOPMENT) {

    result += F("-dev");

  }

  return result;

}

#endif
# 1927 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
boolean isFloat(const String& tBuf) {

  return isNumerical(tBuf, false);

}



boolean isValidFloat(float f) {

  if (f == NAN) return false;

  if (f == INFINITY) return false;

  if (-f == INFINITY)return false;

  if (isnan(f)) return false;

  if (isinf(f)) return false;

  return true;

}



boolean isInt(const String& tBuf) {

  return isNumerical(tBuf, true);

}



bool validIntFromString(const String& tBuf, int& result) {

  const String numerical = getNumerical(tBuf, true);

  const bool isvalid = isInt(numerical);

  result = numerical.toInt();

  return isvalid;

}



bool validFloatFromString(const String& tBuf, float& result) {

  const String numerical = getNumerical(tBuf, false);

  const bool isvalid = isFloat(numerical);

  result = numerical.toFloat();

  return isvalid;

}





String getNumerical(const String& tBuf, bool mustBeInteger) {

  String result = "";

  const unsigned int bufLength = tBuf.length();

  if (bufLength == 0) return result;

  boolean decPt = false;

  int firstDec = 0;

  char c = tBuf.charAt(0);

  if(c == '+' || c == '-') {

    result += c;

    firstDec = 1;

  }

  for(unsigned int x=firstDec; x < bufLength; ++x) {

    c = tBuf.charAt(x);

    if(c == '.') {

      if (mustBeInteger) return result;



      if(decPt) return result;

      else decPt = true;

    }

    else if(c < '0' || c > '9') return result;

    result += c;

  }

  return result;

}



boolean isNumerical(const String& tBuf, bool mustBeInteger) {

  const unsigned int bufLength = tBuf.length();

  if (bufLength == 0) return false;

  boolean decPt = false;

  int firstDec = 0;

  char c = tBuf.charAt(0);

  if(c == '+' || c == '-')

    firstDec = 1;

  for(unsigned int x=firstDec; x < bufLength; ++x) {

    c = tBuf.charAt(x);

    if(c == '.') {

      if (mustBeInteger) return false;



      if(decPt) return false;

      else decPt = true;

    }

    else if(c < '0' || c > '9') return false;

  }

  return true;

}





float timeStringToSeconds(String tBuf) {

 float sec = 0;

 int split = tBuf.indexOf(':');

 if (split < 0) {

  sec += tBuf.toFloat() * 60 * 60;

 } else {

  sec += tBuf.substring(0, split).toFloat() * 60 * 60;

  tBuf = tBuf.substring(split +1);

  split = tBuf.indexOf(':');

  if (split < 0) {

   sec += tBuf.toFloat() * 60;

  } else {

   sec += tBuf.substring(0, split).toFloat() * 60;

   sec += tBuf.substring(split +1).toFloat();

  }

 }

 return sec;

}
# 2129 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void initLog()

{



  Settings.UseSerial=true;

  Settings.SyslogFacility=0;

  setLogLevelFor(LOG_TO_SYSLOG, 0);

  setLogLevelFor(LOG_TO_SERIAL, 2);

  setLogLevelFor(LOG_TO_WEBLOG, 2);

  setLogLevelFor(LOG_TO_SDCARD, 0);

}
# 2157 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
String getLogLevelDisplayString(byte index, int& logLevel) {

  switch (index) {

    case 0: logLevel = LOG_LEVEL_ERROR; return F("Error");

    case 1: logLevel = LOG_LEVEL_INFO; return F("Info");

    case 2: logLevel = LOG_LEVEL_DEBUG; return F("Debug");

    case 3: logLevel = LOG_LEVEL_DEBUG_MORE; return F("Debug More");

    case 4: logLevel = LOG_LEVEL_DEBUG_DEV; return F("Debug dev");



    default: logLevel = -1; return "";

  }

}



void addToLog(byte loglevel, const String& string)

{

  addToLog(loglevel, string.c_str());

}



void addToLog(byte logLevel, const __FlashStringHelper* flashString)

{

    checkRAM(F("addToLog"));

    String s(flashString);

    addToLog(logLevel, s.c_str());

}



bool SerialAvailableForWrite() {

  if (!Settings.UseSerial) return false;

  #if defined(ESP8266)

    if (!Serial.availableForWrite()) return false;

  #endif

  return true;

}



void disableSerialLog() {

  log_to_serial_disabled = true;

  setLogLevelFor(LOG_TO_SERIAL, 0);

}



void setLogLevelFor(byte destination, byte logLevel) {

  switch (destination) {

    case LOG_TO_SERIAL:

      if (!log_to_serial_disabled || logLevel == 0)

        Settings.SerialLogLevel = logLevel; break;

    case LOG_TO_SYSLOG: Settings.SyslogLevel = logLevel; break;

    case LOG_TO_WEBLOG: Settings.WebLogLevel = logLevel; break;

    case LOG_TO_SDCARD: Settings.SDLogLevel = logLevel; break;

    default:

      break;

  }

  updateLogLevelCache();

}



void updateLogLevelCache() {

  byte max_lvl = 0;

  max_lvl = _max(max_lvl, Settings.SerialLogLevel);

  max_lvl = _max(max_lvl, Settings.SyslogLevel);

  max_lvl = _max(max_lvl, Settings.WebLogLevel);

  max_lvl = _max(max_lvl, Settings.SDLogLevel);

  highest_active_log_level = max_lvl;

}



bool loglevelActiveFor(byte logLevel) {

  return loglevelActive(logLevel, highest_active_log_level);

}



boolean loglevelActiveFor(byte destination, byte logLevel) {

  byte logLevelSettings = 0;

  switch (destination) {

    case LOG_TO_SERIAL: {

      if (!SerialAvailableForWrite()) return false;

      logLevelSettings = Settings.SerialLogLevel;

      if (wifiStatus != ESPEASY_WIFI_SERVICES_INITIALIZED)

        logLevelSettings = 2;

      break;

    }

    case LOG_TO_SYSLOG: {

      logLevelSettings = Settings.SyslogLevel;

      break;

    }

    case LOG_TO_WEBLOG: {

      logLevelSettings = Settings.WebLogLevel;

      break;

    }

    case LOG_TO_SDCARD: {

      logLevelSettings = Settings.SDLogLevel;

      break;

    }

    default:

      return false;

  }

  return loglevelActive(logLevel, logLevelSettings);

}





boolean loglevelActive(byte logLevel, byte logLevelSettings) {

  return (logLevel <= logLevelSettings);

}



void addToLog(byte logLevel, const char *line)

{

  const size_t line_length = strlen(line);

  if (loglevelActiveFor(LOG_TO_SERIAL, logLevel)) {

    int roomLeft = ESP.getFreeHeap() - 5000;

    if (roomLeft > 0) {

      String timestamp_log(millis());

      timestamp_log += F(" : ");

      for (size_t i = 0; i < timestamp_log.length(); ++i) {

        serialLogBuffer.push_back(timestamp_log[i]);

      }

      size_t pos = 0;

      while (pos < line_length && pos < static_cast<size_t>(roomLeft)) {

        serialLogBuffer.push_back(line[pos]);

        ++pos;

      }

      serialLogBuffer.push_back('\r');

      serialLogBuffer.push_back('\n');

    }

  }

  if (loglevelActiveFor(LOG_TO_SYSLOG, logLevel)) {

    syslog(logLevel, line);

  }

  if (loglevelActiveFor(LOG_TO_WEBLOG, logLevel)) {

    Logging.add(logLevel, line);

  }



#ifdef FEATURE_SD

  if (loglevelActiveFor(LOG_TO_SDCARD, logLevel)) {

    File logFile = SD.open("log.dat", FILE_WRITE);

    if (logFile)

      logFile.println(line);

    logFile.close();

  }

#endif

}



void process_serialLogBuffer() {

  if (serialLogBuffer.size() == 0) return;

  if (timePassedSince(last_serial_log_emptied) > 10000) {

    last_serial_log_emptied = millis();

    serialLogBuffer.clear();

    return;

  }

  size_t snip = 128;

#if defined(ESP8266)

  snip = Serial.availableForWrite();

#endif

  if (snip > 0) last_serial_log_emptied = millis();

  size_t bytes_to_write = serialLogBuffer.size();

  if (snip < bytes_to_write) bytes_to_write = snip;

  for (size_t i = 0; i < bytes_to_write; ++i) {

    Serial.write(serialLogBuffer.front());

    serialLogBuffer.pop_front();

  }

}
# 2471 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void delayedReboot(int rebootDelay)

{



  while (rebootDelay != 0 )

  {

    Serial.print(F("Delayed Reset "));

    Serial.println(rebootDelay);

    rebootDelay--;

    delay(1000);

  }

  reboot();

}



void reboot() {

  #if defined(ESP32)

    ESP.restart();

  #else

    ESP.reset();

  #endif

}
# 2521 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
boolean saveToRTC()

{

  #if defined(ESP32)

    return false;

  #else

    if (!system_rtc_mem_write(RTC_BASE_STRUCT, (byte*)&RTC, sizeof(RTC)) || !readFromRTC())

    {

      addLog(LOG_LEVEL_ERROR, F("RTC  : Error while writing to RTC"));

      return(false);

    }

    else

    {

      return(true);

    }

  #endif

}
# 2563 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void initRTC()

{

  memset(&RTC, 0, sizeof(RTC));

  RTC.ID1 = 0xAA;

  RTC.ID2 = 0x55;

  saveToRTC();



  memset(&UserVar, 0, sizeof(UserVar));

  saveUserVarToRTC();

}
# 2591 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
boolean readFromRTC()

{

  #if defined(ESP32)

    return false;

  #else

    if (!system_rtc_mem_read(RTC_BASE_STRUCT, (byte*)&RTC, sizeof(RTC)))

      return(false);

    return (RTC.ID1 == 0xAA && RTC.ID2 == 0x55);

  #endif

}
# 2621 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
boolean saveUserVarToRTC()

{

  #if defined(ESP32)

    return false;

  #else



    byte* buffer = (byte*)&UserVar;

    size_t size = sizeof(UserVar);

    uint32_t sum = getChecksum(buffer, size);

    boolean ret = system_rtc_mem_write(RTC_BASE_USERVAR, buffer, size);

    ret &= system_rtc_mem_write(RTC_BASE_USERVAR+(size>>2), (byte*)&sum, 4);

    return ret;

  #endif

}
# 2659 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
boolean readUserVarFromRTC()

{

  #if defined(ESP32)

    return false;

  #else



    byte* buffer = (byte*)&UserVar;

    size_t size = sizeof(UserVar);

    boolean ret = system_rtc_mem_read(RTC_BASE_USERVAR, buffer, size);

    uint32_t sumRAM = getChecksum(buffer, size);

    uint32_t sumRTC = 0;

    ret &= system_rtc_mem_read(RTC_BASE_USERVAR+(size>>2), (byte*)&sumRTC, 4);

    if (!ret || sumRTC != sumRAM)

    {

      addLog(LOG_LEVEL_ERROR, F("RTC  : Checksum error on reading RTC user var"));

      memset(buffer, 0, size);

    }

    return ret;

  #endif

}





uint32_t getChecksum(byte* buffer, size_t size)

{

  uint32_t sum = 0x82662342;

  for (size_t i=0; i<size; i++)

    sum += buffer[i];

  return sum;

}
# 2727 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
String parseTemplate(String &tmpString, byte lineSize)

{

  checkRAM(F("parseTemplate"));

  String newString = "";

  String tmpStringMid = "";

  newString.reserve(lineSize);





  int leftBracketIndex = tmpString.indexOf('[');

  if (leftBracketIndex == -1)

    newString = tmpString;

  else

  {

    byte count = 0;

    byte currentTaskIndex = ExtraTaskSettings.TaskIndex;



    while (leftBracketIndex >= 0 && count < 10 - 1)

    {

      newString += tmpString.substring(0, leftBracketIndex);

      tmpString = tmpString.substring(leftBracketIndex + 1);

      int rightBracketIndex = tmpString.indexOf(']');

      if (rightBracketIndex >= 0)

      {

        tmpStringMid = tmpString.substring(0, rightBracketIndex);

        tmpString = tmpString.substring(rightBracketIndex + 1);

        int hashtagIndex = tmpStringMid.indexOf('#');

        if (hashtagIndex >= 0) {

          String deviceName = tmpStringMid.substring(0, hashtagIndex);

          String valueName = tmpStringMid.substring(hashtagIndex + 1);

          String valueFormat = "";

          hashtagIndex = valueName.indexOf('#');

          if (hashtagIndex >= 0)

          {

            valueFormat = valueName.substring(hashtagIndex + 1);

            valueName = valueName.substring(0, hashtagIndex);

          }



          if (deviceName.equalsIgnoreCase(F("Plugin")))

          {

            String tmpString = tmpStringMid.substring(7);

            tmpString.replace('#', ',');

            if (PluginCall(PLUGIN_REQUEST, 0, tmpString))

              newString += tmpString;

          }

          else

            for (byte y = 0; y < TASKS_MAX; y++)

            {

              if (Settings.TaskDeviceEnabled[y])

              {

                LoadTaskSettings(y);

                String taskDeviceName = getTaskDeviceName(y);

                if (taskDeviceName.length() != 0)

                {

                  if (deviceName.equalsIgnoreCase(taskDeviceName))

                  {

                    boolean match = false;

                    for (byte z = 0; z < VARS_PER_TASK; z++)

                      if (valueName.equalsIgnoreCase(ExtraTaskSettings.TaskDeviceValueNames[z]))

                      {



                        match = true;

                        bool isvalid;

                        String value = formatUserVar(y, z, isvalid);

                        if (isvalid) {







                          if (valueFormat.length() > 0)

                          {

                            String valueJust = "";



                            hashtagIndex = valueFormat.indexOf('#');

                            if (hashtagIndex >= 0)

                            {

                              valueJust = valueFormat.substring(hashtagIndex + 1);

                              valueFormat = valueFormat.substring(0, hashtagIndex);

                            }







                            if (valueFormat.length() > 0)

                            {

                              const int val = value == "0" ? 0 : 1;

                              const float valFloat = value.toFloat();



                              String tempValueFormat = valueFormat;

                              int tempValueFormatLength = tempValueFormat.length();

                              const int invertedIndex = tempValueFormat.indexOf('!');

                              const bool inverted = invertedIndex >= 0 ? 1 : 0;

                              if (inverted)

                                tempValueFormat.remove(invertedIndex,1);



                              const int rightJustifyIndex = tempValueFormat.indexOf('R');

                              const bool rightJustify = rightJustifyIndex >= 0 ? 1 : 0;

                              if (rightJustify)

                                tempValueFormat.remove(rightJustifyIndex,1);



                              tempValueFormatLength = tempValueFormat.length();





                              if (tempValueFormatLength > 0)

                              {

                                switch (tempValueFormat[0])

                                  {

                                  case 'V':

                                    break;

                                  case 'O':

                                    value = val == inverted ? F("OFF") : F(" ON");

                                    break;

                                  case 'C':

                                    value = val == inverted ? F("CLOSE") : F(" OPEN");

                                    break;

                                  case 'M':

                                    value = val == inverted ? F("AUTO") : F(" MAN");

                                    break;

                                  case 'm':

                                    value = val == inverted ? F("A") : F("M");

                                    break;

                                  case 'H':

                                    value = val == inverted ? F("COLD") : F(" HOT");

                                    break;

                                  case 'U':

                                    value = val == inverted ? F("DOWN") : F("  UP");

                                    break;

                                  case 'u':

                                    value = val == inverted ? F("D") : F("U");

                                    break;

                                  case 'Y':

                                    value = val == inverted ? F(" NO") : F("YES");

                                    break;

                                  case 'y':

                                    value = val == inverted ? F("N") : F("Y");

                                    break;

                                  case 'X':

                                    value = val == inverted ? F("O") : F("X");

                                    break;

                                  case 'I':

                                    value = val == inverted ? F("OUT") : F(" IN");

                                    break;

                                  case 'Z' :

                                    value = val == inverted ? F("0") : F("1");

                                    break;

                                  case 'D' :

                                    {

                                      int x;

                                      int y;

                                      x = 0;

                                      y = 0;



                                      switch (tempValueFormatLength)

                                      {

                                        case 2:

                                          if (isDigit(tempValueFormat[1]))

                                          {

                                            x = (int)tempValueFormat[1]-'0';

                                          }

                                          break;

                                        case 3:

                                          if (tempValueFormat[1]=='.' && isDigit(tempValueFormat[2]))

                                          {

                                            y = (int)tempValueFormat[2]-'0';

                                          }

                                          break;

                                        case 4:

                                          if (isDigit(tempValueFormat[1]) && tempValueFormat[2]=='.' && isDigit(tempValueFormat[3]))

                                          {

                                            x = (int)tempValueFormat[1]-'0';

                                            y = (int)tempValueFormat[3]-'0';

                                          }

                                          break;

                                        case 1:

                                        default:

                                          break;

                                      }

                                      value = toString(valFloat,y);

                                      int indexDot;

                                      indexDot = value.indexOf('.') > 0 ? value.indexOf('.') : value.length();

                                      for (byte f = 0; f < (x - indexDot); f++)

                                        value = "0" + value;

                                      break;

                                    }

                                  case 'F' :

                                    value = (int)floorf(valFloat);

                                    break;

                                  case 'E' :

                                    value = (int)ceilf(valFloat);

                                    break;

                                  default:

                                    value = F("ERR");

                                    break;

                                  }





                                  const int valueJustLength = valueJust.length();

                                  if (valueJustLength > 0)

                                  {

                                    value.trim();

                                    switch (valueJust[0])

                                    {

                                    case 'P' :

                                      if (valueJustLength > 1)

                                      {

                                        if (isDigit(valueJust[1]))

                                        {

                                          int filler = valueJust[1] - value.length() - '0' ;

                                          for (byte f = 0; f < filler; f++)

                                            newString += " ";

                                        }

                                      }

                                      break;

                                    case 'S' :

                                      if (valueJustLength > 1)

                                      {

                                        if (isDigit(valueJust[1]))

                                        {

                                          int filler = valueJust[1] - value.length() - '0' ;

                                          for (byte f = 0; f < filler; f++)

                                            value += " ";

                                        }

                                      }

                                      break;

                                    case 'L':

                                      if (valueJustLength > 1)

                                      {

                                        if (isDigit(valueJust[1]))

                                        {

                                          value = value.substring(0,(int)valueJust[1]-'0');

                                        }

                                      }

                                      break;

                                    case 'R':

                                      if (valueJustLength > 1)

                                      {

                                        if (isDigit(valueJust[1]))

                                        {

                                          value = value.substring(std::max(0,(int)value.length()-((int)valueJust[1]-'0')));

                                         }

                                      }

                                      break;

                                    case 'U':

                                      if (valueJustLength > 1)

                                      {

                                        if (isDigit(valueJust[1]) && valueJust[2]=='.' && isDigit(valueJust[3]) && valueJust[1] > '0' && valueJust[3] > '0')

                                        {

                                          value = value.substring(std::min((int)value.length(),(int)valueJust[1]-'0'-1),(int)valueJust[1]-'0'-1+(int)valueJust[3]-'0');

                                        }

                                        else

                                        {

                                          newString += F("ERR");

                                        }

                                      }

                                      break;

                                    default:

                                      newString += F("ERR");

                                      break;

                                  }

                                }

                              }

                              if (rightJustify)

                              {

                                int filler = lineSize - newString.length() - value.length() - tmpString.length() ;

                                for (byte f = 0; f < filler; f++)

                                  newString += " ";

                              }

                              {

                                if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {

                                  String logFormatted = F("DEBUG: Formatted String='");

                                  logFormatted += newString;

                                  logFormatted += value;

                                  logFormatted += "'";

                                  addLog(LOG_LEVEL_DEBUG, logFormatted);

                                }

                              }

                            }

                          }





                          newString += String(value);

                          {

                            if (loglevelActiveFor(LOG_LEVEL_DEBUG_DEV)) {

                              String logParsed = F("DEBUG DEV: Parsed String='");

                              logParsed += newString;

                              logParsed += "'";

                              addLog(LOG_LEVEL_DEBUG_DEV, logParsed);

                            }

                          }

                          break;

                        }

                      }

                    if (!match)

                    {

                      struct EventStruct TempEvent;

                      TempEvent.TaskIndex = y;

                      String tmpName = valueName;

                      if (PluginCall(PLUGIN_GET_CONFIG, &TempEvent, tmpName))

                        newString += tmpName;

                    }

                    break;

                  }

                }

              }

            }

        }

      }

      leftBracketIndex = tmpString.indexOf('[');

      count++;

    }

    checkRAM(F("parseTemplate2"));

    newString += tmpString;



    if (currentTaskIndex != 255)

      LoadTaskSettings(currentTaskIndex);

  }



  parseSystemVariables(newString, false);

  parseStandardConversions(newString, false);





  while (newString.length() < lineSize)

    newString += " ";

  checkRAM(F("parseTemplate3"));

  return newString;

}
# 3381 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
#define CALCULATE_OK 0

#define CALCULATE_ERROR_STACK_OVERFLOW 1

#define CALCULATE_ERROR_BAD_OPERATOR 2

#define CALCULATE_ERROR_PARENTHESES_MISMATCHED 3

#define CALCULATE_ERROR_UNKNOWN_TOKEN 4

#define STACK_SIZE 10

#define TOKEN_MAX 20



float globalstack[STACK_SIZE];

float *sp = globalstack - 1;

float *sp_max = &globalstack[STACK_SIZE - 1];



#define is_operator(c) (c == '+' || c == '-' || c == '*' || c == '/' || c == '^' || c == '%')

#define is_unary_operator(c) (c == '!')



int push(float value)

{

  if (sp != sp_max)

  {

    *(++sp) = value;

    return 0;

  }

  else

    return CALCULATE_ERROR_STACK_OVERFLOW;

}



float pop()

{

  if (sp != (globalstack - 1))

    return *(sp--);

  else

    return 0.0;

}



float apply_operator(char op, float first, float second)

{

  switch (op)

  {

    case '+':

      return first + second;

    case '-':

      return first - second;

    case '*':

      return first * second;

    case '/':

      return first / second;

    case '%':

      return round(first) % round(second);

    case '^':

      return pow(first, second);

    default:

      return 0;

  }

}



float apply_unary_operator(char op, float first)

{

  switch (op)

  {

    case '!':

      return (round(first) == 0) ? 1 : 0;

    default:

      return 0;

  }

}



char *next_token(char *linep)

{

  while (isspace(*(linep++)));

  while (*linep && !isspace(*(linep++)));

  return linep;

}



int RPNCalculate(char* token)

{

  if (token[0] == 0)

    return 0;



  if (is_operator(token[0]) && token[1] == 0)

  {

    float second = pop();

    float first = pop();



    if (push(apply_operator(token[0], first, second)))

      return CALCULATE_ERROR_STACK_OVERFLOW;

  } else if (is_unary_operator(token[0]) && token[1] == 0)

  {

    float first = pop();



    if (push(apply_unary_operator(token[0], first)))

      return CALCULATE_ERROR_STACK_OVERFLOW;



  } else

    if (push(atof(token)))

      return CALCULATE_ERROR_STACK_OVERFLOW;



  return 0;

}
# 3589 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
int op_preced(const char c)

{

  switch (c)

  {

    case '!':

      return 4;

    case '^':

      return 3;

    case '*':

    case '/':

    case '%':

      return 2;

    case '+':

    case '-':

      return 1;

  }

  return 0;

}



bool op_left_assoc(const char c)

{

  switch (c)

  {

    case '^':

    case '*':

    case '/':

    case '+':

    case '-':

    case '%':

      return true;

    case '!':

      return false;

  }

  return false;

}



unsigned int op_arg_count(const char c)

{

  switch (c)

  {

    case '^':

    case '*':

    case '/':

    case '+':

    case '-':

    case '%':

      return 2;

    case '!':

      return 1;

  }

  return 0;

}





int Calculate(const char *input, float* result)

{

  checkRAM(F("Calculate"));

  const char *strpos = input, *strend = input + strlen(input);

  char token[25];

  char c, oc, *TokenPos = token;

  char stack[32];

  unsigned int sl = 0;

  char sc;

  int error = 0;





  sp = globalstack - 1;

  oc=c=0;



  if (input[0] == '=') {

    ++strpos;

    c = *strpos;

  }



  while (strpos < strend)

  {



    oc = c;

    c = *strpos;

    if (c != ' ')

    {



      if ((c >= '0' && c <= '9') || c == '.' || (c == '-' && is_operator(oc)))

      {

        *TokenPos = c;

        ++TokenPos;

      }





      else if (is_operator(c) || is_unary_operator(c))

      {

        *(TokenPos) = 0;

        error = RPNCalculate(token);

        TokenPos = token;

        if (error)return error;

        while (sl > 0)

        {

          sc = stack[sl - 1];
# 3795 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
          if (is_operator(sc) && ((op_left_assoc(c) && (op_preced(c) <= op_preced(sc))) || (op_preced(c) < op_preced(sc))))

          {



            *TokenPos = sc;

            ++TokenPos;

            *(TokenPos) = 0;

            error = RPNCalculate(token);

            TokenPos = token;

            if (error)return error;

            sl--;

          }

          else

            break;

        }



        stack[sl] = c;

        ++sl;

      }



      else if (c == '(')

      {

        stack[sl] = c;

        ++sl;

      }



      else if (c == ')')

      {

        bool pe = false;





        while (sl > 0)

        {

          *(TokenPos) = 0;

          error = RPNCalculate(token);

          TokenPos = token;

          if (error)return error;

          sc = stack[sl - 1];

          if (sc == '(')

          {

            pe = true;

            break;

          }

          else

          {

            *TokenPos = sc;

            ++TokenPos;

            sl--;

          }

        }



        if (!pe)

          return CALCULATE_ERROR_PARENTHESES_MISMATCHED;





        sl--;





        if (sl > 0)

          sc = stack[sl - 1];



      }

      else

        return CALCULATE_ERROR_UNKNOWN_TOKEN;

    }

    ++strpos;

  }





  while (sl > 0)

  {

    sc = stack[sl - 1];

    if (sc == '(' || sc == ')')

      return CALCULATE_ERROR_PARENTHESES_MISMATCHED;



    *(TokenPos) = 0;

    error = RPNCalculate(token);

    TokenPos = token;

    if (error)return error;

    *TokenPos = sc;

    ++TokenPos;

    --sl;

  }



  *(TokenPos) = 0;

  error = RPNCalculate(token);

  TokenPos = token;

  if (error)

  {

    *result = 0;

    return error;

  }

  *result = *sp;

  checkRAM(F("Calculate2"));

  return CALCULATE_OK;

}



int CalculateParam(char *TmpStr) {

  int returnValue;







  if (TmpStr[0] != '=') {

    returnValue=str2int(TmpStr);

  } else {

    float param=0;

    TmpStr[0] = ' ';

    int returnCode=Calculate(TmpStr, &param);

    if (returnCode!=CALCULATE_OK) {

      String errorDesc;

      switch (returnCode) {

        case CALCULATE_ERROR_STACK_OVERFLOW:

          errorDesc = F("Stack Overflow");

          break;

        case CALCULATE_ERROR_BAD_OPERATOR:

          errorDesc = F("Bad Operator");

          break;

        case CALCULATE_ERROR_PARENTHESES_MISMATCHED:

          errorDesc = F("Parenthesis mismatch");

          break;

        case CALCULATE_ERROR_UNKNOWN_TOKEN:

          errorDesc = F("Unknown token");

          break;

        default:

          errorDesc = F("Unknown error");

          break;

        }

        String log = String(F("CALCULATE PARAM ERROR: ")) + errorDesc;

        addLog(LOG_LEVEL_ERROR, log);

        log = F("CALCULATE PARAM ERROR details: ");

        log += TmpStr;

        log += F(" = ");

        log += round(param);

        addLog(LOG_LEVEL_ERROR, log);

      } else {

      if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {

        String log = F("CALCULATE PARAM: ");

        log += TmpStr;

        log += F(" = ");

        log += round(param);

        addLog(LOG_LEVEL_DEBUG, log);

      }

    }

    returnValue=round(param);

  }

  return returnValue;

}



void checkRuleSets(){

for (byte x=0; x < RULESETS_MAX; x++){

  #if defined(ESP8266)

    String fileName = F("rules");

  #endif

  #if defined(ESP32)

    String fileName = F("/rules");

  #endif

  fileName += x+1;

  fileName += F(".txt");

  if (SPIFFS.exists(fileName))

    activeRuleSets[x] = true;

  else

    activeRuleSets[x] = false;



  if (Settings.SerialLogLevel == LOG_LEVEL_DEBUG_DEV){

    Serial.print(fileName);

    Serial.print(" ");

    Serial.println(activeRuleSets[x]);

    }

  }

}
# 4143 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void rulesProcessing(String& event)

{

  checkRAM(F("rulesProcessing"));

  unsigned long timer = millis();

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    String log = F("EVENT: ");

    log += event;

    addLog(LOG_LEVEL_INFO, log);

  }



  for (byte x = 0; x < RULESETS_MAX; x++)

  {

    #if defined(ESP8266)

      String fileName = F("rules");

    #endif

    #if defined(ESP32)

      String fileName = F("/rules");

    #endif

    fileName += x+1;

    fileName += F(".txt");

    if(activeRuleSets[x])

      rulesProcessingFile(fileName, event);

  }



  if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {

    String log = F("EVENT: ");

    log += event;

    log += F(" Processing time:");

    log += timePassedSince(timer);

    log += F(" milliSeconds");

    addLog(LOG_LEVEL_DEBUG, log);

  }

  backgroundtasks();



}
# 4221 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
String rulesProcessingFile(String fileName, String& event)

{

  checkRAM(F("rulesProcessingFile"));

  if (Settings.SerialLogLevel == LOG_LEVEL_DEBUG_DEV){

    Serial.print(F("RuleDebug Processing:"));

    Serial.println(fileName);

    Serial.println(F("     flags CMI  parse output:"));

  }



  static byte nestingLevel = 0;

  int data = 0;

  String log = "";



  nestingLevel++;

  if (nestingLevel > RULES_MAX_NESTING_LEVEL)

  {

    addLog(LOG_LEVEL_ERROR, F("EVENT: Error: Nesting level exceeded!"));

    nestingLevel--;

    return (log);

  }



  fs::File f = SPIFFS.open(fileName, "r+");

  SPIFFS_CHECK(f, fileName.c_str());



  String line = "";

  bool match = false;

  bool codeBlock = false;

  bool isCommand = false;

  bool condition[RULES_IF_MAX_NESTING_LEVEL];

  bool ifBranche[RULES_IF_MAX_NESTING_LEVEL];

  byte ifBlock = 0;

  byte fakeIfBlock = 0;



  byte buf[RULES_BUFFER_SIZE];

  int len = 0;

  while (f.available())

  {

    len = f.read((byte*)buf, RULES_BUFFER_SIZE);

    for (int x = 0; x < len; x++) {

      data = buf[x];



      SPIFFS_CHECK(data >= 0, fileName.c_str());



      if (data != 10) {

        line += char(data);

      }

      else

      {

        line.replace(F("\r"), "");

        if (line.substring(0, 2) != F("//") && line.length() > 0)

        {

          parseCompleteNonCommentLine(

            line, event, log,

            match, codeBlock, isCommand,

            condition, ifBranche,

            ifBlock, fakeIfBlock);

          backgroundtasks();

        }



        line = "";

      }

    }

  }



  nestingLevel--;

  checkRAM(F("rulesProcessingFile2"));

  return (F(""));

}



void parseCompleteNonCommentLine(

    String& line,

    String& event,

    String& log,

    bool& match,

    bool& codeBlock,

    bool& isCommand,

    bool condition[],

    bool ifBranche[],

    byte& ifBlock,

    byte& fakeIfBlock)

{

  isCommand = true;





  int comment = line.indexOf(F("//"));

  if (comment > 0)

    line = line.substring(0, comment);



  if (match || !codeBlock) {





    line = parseTemplate(line, line.length());



    if (match && !fakeIfBlock) {



      if (event.charAt(0) == '!')

      {

        line.replace(F("%eventvalue%"), event);

      }

      else

      {

        int equalsPos = event.indexOf("=");

        if (equalsPos > 0)

        {

          String tmpString = event.substring(equalsPos + 1);

          line.replace(F("%eventvalue%"), tmpString);

        }

      }

    }

  }

  line.trim();



  String lineOrg = line;

  line.toLowerCase();





  String eventTrigger = "";

  String action = "";



  if (!codeBlock)

  {

    if (line.startsWith(F("on ")))

    {

      ifBlock = 0;

      fakeIfBlock = 0;

      line = line.substring(3);

      int split = line.indexOf(F(" do"));

      if (split != -1)

      {

        eventTrigger = line.substring(0, split);

        action = lineOrg.substring(split + 7);

        action.trim();

      }

      if (eventTrigger == "*")

        match = true;

      else

        match = ruleMatch(event, eventTrigger);

      if (action.length() > 0)

      {

        isCommand = true;

        codeBlock = false;

      }

      else

      {

        isCommand = false;

        codeBlock = true;

      }

    }

  }

  else

  {

    action = lineOrg;

  }



  String lcAction = action;

  lcAction.toLowerCase();

  if (lcAction == F("endon"))

  {

    isCommand = false;

    codeBlock = false;

    match = false;

    ifBlock = 0;

    fakeIfBlock = 0;

  }



  if (Settings.SerialLogLevel == LOG_LEVEL_DEBUG_DEV){

    Serial.print(F("RuleDebug: "));

    Serial.print(codeBlock);

    Serial.print(match);

    Serial.print(isCommand);

    Serial.print(F(": "));

    Serial.println(line);

  }



  if (match)

  {

    processMatchedRule(

      lcAction, action, event, log,

      match, codeBlock, isCommand,

      condition, ifBranche,

      ifBlock, fakeIfBlock);

  }

}



void processMatchedRule(

  String& lcAction, String& action, String& event, String& log,

  bool& match,

  bool& codeBlock,

  bool& isCommand,

  bool condition[],

  bool ifBranche[],

  byte& ifBlock,

  byte& fakeIfBlock)

{

  if (fakeIfBlock)

    isCommand = false;

  else if (ifBlock)

    if (condition[ifBlock-1] != ifBranche[ifBlock-1])

      isCommand = false;

  int split = lcAction.indexOf(F("elseif "));

  if (split != -1)

  {

    isCommand = false;

    if (ifBlock && !fakeIfBlock)

    {

      if (ifBranche[ifBlock-1])

      {

        if (condition[ifBlock-1])

          ifBranche[ifBlock-1] = false;

        else

        {

          String check = lcAction.substring(split + 7);

          log = F("Lev.");

          log += String(ifBlock);

          log += F(": [elseif ");

          log += check;

          log += "]=";

          condition[ifBlock-1] = conditionMatchExtended(check);

          log += toString(condition[ifBlock-1]);

          addLog(LOG_LEVEL_DEBUG, log);

        }

      }

    }

  }

  else

  {

    split = lcAction.indexOf(F("if "));

    if (split != -1)

    {

      if (ifBlock < RULES_IF_MAX_NESTING_LEVEL)

      {

        if (isCommand)

        {

          ifBlock++;

          String check = lcAction.substring(split + 3);

          log = F("Lev.");

          log += String(ifBlock);

          log += F(": [if ");

          log += check;

          log += F("]=");

          condition[ifBlock-1] = conditionMatchExtended(check);

          ifBranche[ifBlock-1] = true;

          log += toString(condition[ifBlock-1]);

          addLog(LOG_LEVEL_DEBUG, log);

        }

        else

          fakeIfBlock++;

      }

      else

      {

        fakeIfBlock++;

        log = F("Lev.");

        log += String(ifBlock);

        log = F(": Error: IF Nesting level exceeded!");

        addLog(LOG_LEVEL_ERROR, log);

      }

      isCommand = false;

    }

  }



  if ((lcAction == F("else")) && !fakeIfBlock)

  {

    ifBranche[ifBlock-1] = false;

    isCommand = false;

    if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {

      log = F("Lev.");

      log += String(ifBlock);

      log += F(": [else]=");

      log += toString(condition[ifBlock-1] == ifBranche[ifBlock-1]);

      addLog(LOG_LEVEL_DEBUG, log);

    }

  }



  if (lcAction == F("endif"))

  {

    if (fakeIfBlock)

      fakeIfBlock--;

    else if (ifBlock)

      ifBlock--;

    isCommand = false;

  }





  if (isCommand)

  {

    if (event.charAt(0) == '!')

    {

      action.replace(F("%eventvalue%"), event);

    }

    else

    {

      int equalsPos = event.indexOf("=");

      if (equalsPos > 0)

      {

        String tmpString = event.substring(equalsPos + 1);



        char command[INPUT_COMMAND_SIZE];

        command[0] = 0;

        char tmpParam[INPUT_COMMAND_SIZE];

        tmpParam[0] = 0;

        tmpString.toCharArray(command, INPUT_COMMAND_SIZE);



        if (GetArgv(command,tmpParam,1)) {

           action.replace(F("%eventvalue%"), tmpParam);

           action.replace(F("%eventvalue1%"), tmpParam);

        }

        if (GetArgv(command,tmpParam,2)) action.replace(F("%eventvalue2%"), tmpParam);

        if (GetArgv(command,tmpParam,3)) action.replace(F("%eventvalue3%"), tmpParam);

        if (GetArgv(command,tmpParam,4)) action.replace(F("%eventvalue4%"), tmpParam);

      }

    }



    if (loglevelActiveFor(LOG_LEVEL_INFO)) {

      String log = F("ACT  : ");

      log += action;

      addLog(LOG_LEVEL_INFO, log);

    }



    struct EventStruct TempEvent;

    parseCommandString(&TempEvent, action);
# 4869 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
    yield();



    String tmpAction(action);

    if (!PluginCall(PLUGIN_WRITE, &TempEvent, tmpAction)) {

      if (!tmpAction.equals(action)) {

        if (loglevelActiveFor(LOG_LEVEL_ERROR)) {

          String log = F("PLUGIN_WRITE altered the string: ");

          log += action;

          log += F(" to: ");

          log += tmpAction;

          addLog(LOG_LEVEL_ERROR, log);

        }

      }

      ExecuteCommand(VALUE_SOURCE_SYSTEM, action.c_str());

    }

    yield();

  }

}
# 4913 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
boolean ruleMatch(String& event, String& rule)

{

  checkRAM(F("ruleMatch"));

  boolean match = false;

  String tmpEvent = event;

  String tmpRule = rule;





  tmpRule.replace(F("["),F(""));

  tmpRule.replace(F("]"),F(""));





  if (event.charAt(0) == '!')

  {

    int pos = rule.indexOf('*');

    if (pos != -1)

      {

        tmpEvent = event.substring(0,pos-1);

        tmpRule = rule.substring(0,pos-1);

      }

    else

      {

        pos = rule.indexOf('#');

        if (pos == -1)

          {

            tmpEvent = event.substring(0,rule.length());

            tmpRule = rule;

          }

      }



    if (tmpEvent.equalsIgnoreCase(tmpRule))

      return true;

    else

      return false;

  }



  if (event.startsWith(F("Clock#Time")))

  {

    int pos1 = event.indexOf("=");

    int pos2 = rule.indexOf("=");

    if (pos1 > 0 && pos2 > 0)

    {

      tmpEvent = event.substring(0, pos1);

      tmpRule = rule.substring(0, pos2);

      if (tmpRule.equalsIgnoreCase(tmpEvent))

      {

        tmpEvent = event.substring(pos1 + 1);

        tmpRule = rule.substring(pos2 + 1);

        unsigned long clockEvent = string2TimeLong(tmpEvent);

        unsigned long clockSet = string2TimeLong(tmpRule);

        if (matchClockEvent(clockEvent, clockSet))

          return true;

        else

          return false;

      }

    }

  }







  float value = 0;

  int pos = event.indexOf("=");

  if (pos)

  {

    tmpEvent = event.substring(pos + 1);

    value = tmpEvent.toFloat();

    tmpEvent = event.substring(0, pos);

  }





  int comparePos = 0;

  char compare = ' ';

  comparePos = rule.indexOf(">");

  if (comparePos > 0)

  {

    compare = '>';

  }

  else

  {

    comparePos = rule.indexOf("<");

    if (comparePos > 0)

    {

      compare = '<';

    }

    else

    {

      comparePos = rule.indexOf("=");

      if (comparePos > 0)

      {

        compare = '=';

      }

    }

  }



  float ruleValue = 0;



  if (comparePos > 0)

  {

    tmpRule = rule.substring(comparePos + 1);

    ruleValue = tmpRule.toFloat();

    tmpRule = rule.substring(0, comparePos);

  }



  switch (compare)

  {

    case '>':

      if (tmpRule.equalsIgnoreCase(tmpEvent) && value > ruleValue)

        match = true;

      break;



    case '<':

      if (tmpRule.equalsIgnoreCase(tmpEvent) && value < ruleValue)

        match = true;

      break;



    case '=':

      if (tmpRule.equalsIgnoreCase(tmpEvent) && value == ruleValue)

        match = true;

      break;



    case ' ':

      if (tmpRule.equalsIgnoreCase(tmpEvent))

        match = true;

      break;

  }

  checkRAM(F("ruleMatch2"));

  return match;

}
# 5181 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
boolean conditionMatchExtended(String& check) {

 int condAnd = -1;

 int condOr = -1;

 boolean rightcond = false;

 boolean leftcond = conditionMatch(check);



 do {

  condAnd = check.indexOf(F(" and "));

  condOr = check.indexOf(F(" or "));



  if (condAnd > 0 || condOr > 0) {

   if (condAnd > 0 && ((condOr < 0 && condOr < condAnd) || (condOr > 0 && condOr > condAnd))) {

    check = check.substring(condAnd + 5);

    rightcond = conditionMatch(check);

    leftcond = (leftcond && rightcond);

   } else {

    check = check.substring(condOr + 4);

    rightcond = conditionMatch(check);

    leftcond = (leftcond || rightcond);

   }

  }

 } while (condAnd > 0 || condOr > 0);

 return leftcond;

}



boolean conditionMatch(const String& check)

{

  boolean match = false;



  char compare = ' ';



  int posStart = check.length();

  int posEnd = posStart;

  int comparePos = 0;



  if ((comparePos = check.indexOf("!="))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+2;

   compare = '!'+'=';

  }

  if ((comparePos = check.indexOf("<>"))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+2;

   compare = '!'+'=';

  }

  if ((comparePos = check.indexOf(">="))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+2;

   compare = '>'+'=';

  }

  if ((comparePos = check.indexOf("<="))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+2;

   compare = '<'+'=';

  }

  if ((comparePos = check.indexOf("<"))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+1;

   compare = '<';

  }

  if ((comparePos = check.indexOf(">"))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+1;

   compare = '>';

  }

  if ((comparePos = check.indexOf("="))>0 && comparePos<posStart) {

   posStart = comparePos;

   posEnd = posStart+1;

   compare = '=';

  }



  float Value1 = 0;

  float Value2 = 0;



  if (compare > ' ')

  {

    String tmpCheck1 = check.substring(0, posStart);

    String tmpCheck2 = check.substring(posEnd);

    if (!isFloat(tmpCheck1) || !isFloat(tmpCheck2)) {

        Value1 = timeStringToSeconds(tmpCheck1);

        Value2 = timeStringToSeconds(tmpCheck2);

    } else {

        Value1 = tmpCheck1.toFloat();

        Value2 = tmpCheck2.toFloat();

    }

  }

  else

    return false;



  switch (compare)

  {

  case '>'+'=':

   if (Value1 >= Value2)

    match = true;

   break;



  case '<'+'=':

   if (Value1 <= Value2)

    match = true;

   break;



  case '!'+'=':

   if (Value1 != Value2)

    match = true;

   break;



  case '>':

   if (Value1 > Value2)

    match = true;

   break;



  case '<':

   if (Value1 < Value2)

    match = true;

   break;



  case '=':

   if (Value1 == Value2)

    match = true;

   break;

  }

  return match;

}
# 5437 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void rulesTimers()

{

  for (byte x = 0; x < RULES_TIMER_MAX; x++)

  {

    if (!RulesTimer[x].paused && RulesTimer[x].timestamp != 0L)

    {

      if (timeOutReached(RulesTimer[x].timestamp))

      {

        RulesTimer[x].timestamp = 0L;

        String event = F("Rules#Timer=");

        event += x + 1;

        rulesProcessing(event);

      }

    }

  }

}
# 5481 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void createRuleEvents(byte TaskIndex)

{

  LoadTaskSettings(TaskIndex);

  byte BaseVarIndex = TaskIndex * VARS_PER_TASK;

  byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);

  byte sensorType = Device[DeviceIndex].VType;

  for (byte varNr = 0; varNr < Device[DeviceIndex].ValueCount; varNr++)

  {

    String eventString = getTaskDeviceName(TaskIndex);

    eventString += F("#");

    eventString += ExtraTaskSettings.TaskDeviceValueNames[varNr];

    eventString += F("=");



    if (sensorType == SENSOR_TYPE_LONG)

      eventString += (unsigned long)UserVar[BaseVarIndex] + ((unsigned long)UserVar[BaseVarIndex + 1] << 16);

    else

      eventString += UserVar[BaseVarIndex + varNr];



    rulesProcessing(eventString);

  }

}





void SendValueLogger(byte TaskIndex)

{

  bool featureSD = false;

  #ifdef FEATURE_SD

    featureSD = true;

  #endif



  String logger;

  if (featureSD || loglevelActiveFor(LOG_LEVEL_DEBUG)) {

    LoadTaskSettings(TaskIndex);

    byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);

    for (byte varNr = 0; varNr < Device[DeviceIndex].ValueCount; varNr++)

    {

      logger += getDateString('-');

      logger += F(" ");

      logger += getTimeString(':');

      logger += F(",");

      logger += Settings.Unit;

      logger += F(",");

      logger += getTaskDeviceName(TaskIndex);

      logger += F(",");

      logger += ExtraTaskSettings.TaskDeviceValueNames[varNr];

      logger += F(",");

      logger += formatUserVarNoCheck(TaskIndex, varNr);

      logger += F("\r\n");

    }



    addLog(LOG_LEVEL_DEBUG, logger);

  }



#ifdef FEATURE_SD

  String filename = F("VALUES.CSV");

  File logFile = SD.open(filename, FILE_WRITE);

  if (logFile)

    logFile.print(logger);

  logFile.close();

#endif

}





#define TRACES 3

#define TRACEENTRIES 15



class RamTracker{

  private:

    String traces[TRACES] ;

    unsigned int tracesMemory[TRACES] ;

    unsigned int readPtr, writePtr;

    String nextAction[TRACEENTRIES];

    unsigned int nextActionStartMemory[TRACEENTRIES];



    unsigned int bestCaseTrace (void){

       unsigned int lowestMemoryInTrace = 0;

       unsigned int lowestMemoryInTraceIndex=0;

       for (int i = 0; i<TRACES; i++) {

          if (tracesMemory[i] > lowestMemoryInTrace){

            lowestMemoryInTrace= tracesMemory[i];

            lowestMemoryInTraceIndex=i;

            }

          }



      return lowestMemoryInTraceIndex;

      }



  public:

    RamTracker(void){

        readPtr=0;

        writePtr=0;

        for (int i = 0; i< TRACES; i++) {

          traces[i]="";

          tracesMemory[i]=0xffffffff;

          }

        for (int i = 0; i< TRACEENTRIES; i++) {

          nextAction[i]="startup";

          nextActionStartMemory[i] = ESP.getFreeHeap();

          }

        };



    void registerRamState(String &s){

       nextAction[writePtr]=s;

       nextActionStartMemory[writePtr]=ESP.getFreeHeap();

       int bestCase = bestCaseTrace();

       if ( ESP.getFreeHeap() < tracesMemory[bestCase]){

            traces[bestCase]="";

            readPtr = writePtr+1;

            if (readPtr>=TRACEENTRIES) readPtr=0;

            tracesMemory[bestCase] = ESP.getFreeHeap();



            for (int i = 0; i<TRACEENTRIES; i++) {

              traces[bestCase]+= nextAction[readPtr];

              traces[bestCase]+= "-> ";

              traces[bestCase]+= String(nextActionStartMemory[readPtr]);

              traces[bestCase]+= " ";

              readPtr++;

              if (readPtr >=TRACEENTRIES) readPtr=0;

            }

       }

       writePtr++;

       if (writePtr >= TRACEENTRIES) writePtr=0;

    };

   void getTraceBuffer(){

      if (loglevelActiveFor(LOG_LEVEL_DEBUG_DEV)) {

        String retval="Memtrace\n";

        for (int i = 0; i< TRACES; i++){

          retval += String(i);

          retval += ": lowest: ";

          retval += String(tracesMemory[i]);

          retval += "  ";

          retval += traces[i];

          addLog(LOG_LEVEL_DEBUG_DEV, retval);

          retval="";

        }

      }

    }

}myRamTracker;



void checkRAMtoLog(void){

  myRamTracker.getTraceBuffer();

}



void checkRAM(const __FlashStringHelper* flashString, int a ) {

 String s=String(a);

 checkRAM(flashString,s);

}



void checkRAM(const __FlashStringHelper* flashString, String &a ) {

  String s = flashString;

  checkRAM(s,a);

}



void checkRAM(String &flashString, String &a ) {

  String s = flashString;

  s+=" (";

  s+=a;

  s+=")";

  checkRAM(s);

}



void checkRAM( const __FlashStringHelper* flashString)

{

  String s = flashString;

  myRamTracker.registerRamState(s);



  uint32_t freeRAM = FreeMem();



  if (freeRAM < lowestRAM)

  {

    lowestRAM = freeRAM;

    lowestRAMfunction = flashString;

  }

}



void checkRAM( String &a ) {

  myRamTracker.registerRamState(a);

}
# 5845 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
#define isdigit(n) (n >= '0' && n <= '9')
# 5855 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void tone_espEasy(uint8_t _pin, unsigned int frequency, unsigned long duration) {

  #ifdef ESP32

    delay(duration);

  #else

    analogWriteFreq(frequency);



    analogWrite(_pin,100);

    delay(duration);

    analogWrite(_pin,0);

  #endif

}
# 5885 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void play_rtttl(uint8_t _pin, const char *p )

{

  checkRAM(F("play_rtttl"));

  #define OCTAVE_OFFSET 0





  const int notes[] = { 0,

    262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494,

    523, 554, 587, 622, 659, 698, 740, 784, 831, 880, 932, 988,

    1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976,

    2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951

  };







  byte default_dur = 4;

  byte default_oct = 6;

  int bpm = 63;

  int num;

  long wholenote;

  long duration;

  byte note;

  byte scale;
# 5939 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
  while(*p != ':') p++;

  p++;





  if(*p == 'd')

  {

    p++; p++;

    num = 0;

    while(isdigit(*p))

    {

      num = (num * 10) + (*p++ - '0');

    }

    if(num > 0) default_dur = num;

    p++;

  }





  if(*p == 'o')

  {

    p++; p++;

    num = *p++ - '0';

    if(num >= 3 && num <=7) default_oct = num;

    p++;

  }





  if(*p == 'b')

  {

    p++; p++;

    num = 0;

    while(isdigit(*p))

    {

      num = (num * 10) + (*p++ - '0');

    }

    bpm = num;

    p++;

  }





  wholenote = (60 * 1000L / bpm) * 4;





  while(*p)

  {



    num = 0;

    while(isdigit(*p))

    {

      num = (num * 10) + (*p++ - '0');

    }



    if (num) duration = wholenote / num;

    else duration = wholenote / default_dur;





    note = 0;



    switch(*p)

    {

      case 'c':

        note = 1;

        break;

      case 'd':

        note = 3;

        break;

      case 'e':

        note = 5;

        break;

      case 'f':

        note = 6;

        break;

      case 'g':

        note = 8;

        break;

      case 'a':

        note = 10;

        break;

      case 'b':

        note = 12;

        break;

      case 'p':

      default:

        note = 0;

    }

    p++;





    if(*p == '#')

    {

      note++;

      p++;

    }





    if(*p == '.')

    {

      duration += duration/2;

      p++;

    }





    if(isdigit(*p))

    {

      scale = *p - '0';

      p++;

    }

    else

    {

      scale = default_oct;

    }



    scale += OCTAVE_OFFSET;



    if(*p == ',')

      p++;





    if(note)

    {

      tone_espEasy(_pin, notes[(scale - 4) * 12 + note], duration);

    }

    else

    {

      delay(duration/10);

    }

  }

 checkRAM(F("play_rtttl2"));

}
# 6203 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
#ifdef FEATURE_ARDUINO_OTA
# 6213 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
void ArduinoOTAInit()

{

  checkRAM(F("ArduinoOTAInit"));



  ArduinoOTA.setPort(ARDUINO_OTA_PORT);

  ArduinoOTA.setHostname(Settings.Name);

  if (SecuritySettings.Password[0]!=0)

    ArduinoOTA.setPassword(SecuritySettings.Password);



  ArduinoOTA.onStart([]() {

      Serial.println(F("OTA  : Start upload"));

      SPIFFS.end();

  });



  ArduinoOTA.onEnd([]() {

      Serial.println(F("\nOTA  : End"));





      Serial.println(F("\nOTA  : DO NOT RESET OR POWER OFF UNTIL BOOT+FLASH IS COMPLETE."));

      delay(100);

      reboot();

  });

  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {



      Serial.printf("OTA  : Progress %u%%\r", (progress / (total / 100)));

  });



  ArduinoOTA.onError([](ota_error_t error) {

      Serial.print(F("\nOTA  : Error (will reboot): "));

      if (error == OTA_AUTH_ERROR) Serial.println(F("Auth Failed"));

      else if (error == OTA_BEGIN_ERROR) Serial.println(F("Begin Failed"));

      else if (error == OTA_CONNECT_ERROR) Serial.println(F("Connect Failed"));

      else if (error == OTA_RECEIVE_ERROR) Serial.println(F("Receive Failed"));

      else if (error == OTA_END_ERROR) Serial.println(F("End Failed"));



      delay(100);

      reboot();

  });

  ArduinoOTA.begin();



  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    String log = F("OTA  : Arduino OTA enabled on port ");

    log += ARDUINO_OTA_PORT;

    addLog(LOG_LEVEL_INFO, log);

  }

}



#endif



int calc_CRC16(const String& text) {

  return calc_CRC16(text.c_str(), text.length());

}



int calc_CRC16(const char *ptr, int count)

{

    int crc;

    char i;

    crc = 0;

    while (--count >= 0)

    {

        crc = crc ^ (int) *ptr++ << 8;

        i = 8;

        do

        {

            if (crc & 0x8000)

                crc = crc << 1 ^ 0x1021;

            else

                crc = crc << 1;

        } while(--i);

    }

    return crc;

}
# 6365 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
float compute_dew_point_temp(float temperature, float humidity_percentage) {

  return pow(humidity_percentage / 100.0, 0.125) *

         (112.0 + 0.9*temperature) + 0.1*temperature - 112.0;

}
# 6381 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Misc.ino"
float compute_humidity_from_dewpoint(float temperature, float dew_temperature) {

  return 100.0 * pow((112.0 - 0.1 * temperature + dew_temperature) /

                     (112.0 + 0.9 * temperature), 8);

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Modbus.ino"


# ifndef MODBUS_H

#define MODBUS_H 



enum MODBUS_states_t {MODBUS_IDLE, MODBUS_RECEIVE, MODBUS_RECEIVE_PAYLOAD};

enum MODBUS_registerTypes_t {signed16, unsigned16, signed32, unsigned32, signed64, unsigned64};



#define MODBUS_FUNCTION_READ 4



class Modbus

{

  public:

    Modbus(void);

    bool handle();

    bool begin(uint8_t function, uint8_t ModbusID, uint16_t ModbusRegister, MODBUS_registerTypes_t type, char* IPaddress);

    double read() {

      if (resultReceived) {

        resultReceived = false;

        return result;

      }

      else

        return -1;

    };

    bool available() {

      return resultReceived;

    };

    unsigned int getReadErrors() {

      return errcnt;

    };

    void resetReadErrors() {

      errcnt = 0;

    };

    void stop() {

      TXRXstate = MODBUS_IDLE;

      handle();

    };

    bool tryRead (uint8_t ModbusID, uint16_t M_register, MODBUS_registerTypes_t type, char* IPaddress, double &result);



  private:

    WiFiClient *ModbusClient;

    unsigned int errcnt;

    char sendBuffer[12] = {0, 1, 0, 0, 0, 6, 0x7e, 4, 0x9d, 7, 0, 1};

    String LogString = "";

    unsigned long timeout;

    MODBUS_states_t TXRXstate;

    unsigned int RXavailable;

    unsigned int payLoad;

    bool hasTimeout();

    MODBUS_registerTypes_t incomingValue;

    double result;

    bool resultReceived;

    bool isBusy(void) {

      return TXRXstate != MODBUS_IDLE;

    };

    uint16_t currentRegister;

    uint8_t currentFunction;

};

#endif







Modbus::Modbus() : ModbusClient(nullptr), errcnt(0), timeout(0),

                   TXRXstate(MODBUS_IDLE), RXavailable(0), payLoad(0) {}



bool Modbus::begin(uint8_t function, uint8_t ModbusID, uint16_t ModbusRegister, MODBUS_registerTypes_t type, char* IPaddress)

{

  currentRegister = ModbusRegister;

  currentFunction = function;

  incomingValue = type;

  resultReceived = false;

  ModbusClient = new WiFiClient();

  ModbusClient->setNoDelay(true);

  ModbusClient->setTimeout(200);

  timeout = millis();

  ModbusClient->flush();



  if (ModbusClient->connected()) {

    LogString += F(" already connected. ");

  } else {

    LogString += F("connect: "); LogString += IPaddress;

    if (ModbusClient->connect(IPaddress, 502) != 1) {

      LogString += F(" fail. ");

      TXRXstate = MODBUS_IDLE;

      errcnt++;

      if (LogString.length() > 1 ) addLog(LOG_LEVEL_DEBUG, LogString);

      return false;

    }

  }

  LogString += F(" OK, sending read request: ");



  sendBuffer[6] = ModbusID ;

  sendBuffer[7] = function;

  sendBuffer[8] = (ModbusRegister >> 8) ;

  sendBuffer[9] = (ModbusRegister & 0x00ff) ;

  if ((incomingValue == signed64) || (incomingValue == unsigned64))

    sendBuffer[11] = 4;

  if ((incomingValue == signed32) || (incomingValue == unsigned32))

    sendBuffer[11] = 2;

  if ((incomingValue == signed16) || (incomingValue == unsigned16))

    sendBuffer[11] = 1;

  ModbusClient->flush();

  ModbusClient->write(&sendBuffer[0], sizeof(sendBuffer));

  for (unsigned int i = 0; i < sizeof(sendBuffer); i++) {

    LogString += ((unsigned int)(sendBuffer[i]));

    LogString += (" ");

  }

  TXRXstate = MODBUS_RECEIVE;

  if (LogString.length() > 1 ) addLog(LOG_LEVEL_DEBUG, LogString);

  return true;

}



bool Modbus::handle() {

  unsigned int RXavailable = 0;

  LogString = "";

  int64_t rxValue = 0;

  switch ( TXRXstate ) {



    case MODBUS_IDLE:



      if (ModbusClient) {

        ModbusClient->flush();

        ModbusClient->stop();

        delete (ModbusClient);

        delay(1);

        ModbusClient = nullptr;

      }

      break;



    case MODBUS_RECEIVE:

      if (hasTimeout()) break;

      if (ModbusClient->available() < 9) break;



      LogString += F("reading bytes: ");

      for (int a = 0; a < 9; a++) {

        payLoad = ModbusClient->read();

        LogString += (payLoad); LogString += F(" ");

      }

      LogString += F("> ");

      if (payLoad > 8) {

        LogString += F("Payload too large !? ");

        errcnt++;

        TXRXstate = MODBUS_IDLE;

      }



    case MODBUS_RECEIVE_PAYLOAD:

      if (hasTimeout()) break;

      RXavailable = ModbusClient->available();

      if (payLoad != RXavailable) {

        TXRXstate = MODBUS_RECEIVE_PAYLOAD;

        break;

      }

      for (unsigned int i = 0; i < RXavailable; i++) {

        rxValue = rxValue << 8;

        char a = ModbusClient->read();

        rxValue = rxValue | a;

        LogString += ((int)a); LogString += (" ");

      }

      switch (incomingValue) {

        case signed16:

          result = (int16_t) rxValue;

          break;

        case unsigned16:

          result = (uint16_t) rxValue;

          break;

        case signed32:

          result = (int32_t) rxValue;

          break;

        case unsigned32:

          result = (uint32_t) rxValue;

          break;

        case signed64:

          result = (int64_t) rxValue;

          break;

        case unsigned64:

          result = (uint64_t) rxValue;

          break;

      }



      LogString += "value: "; LogString += result;





      TXRXstate = MODBUS_IDLE;



      resultReceived = true;

      break;



    default:

      LogString += F("default. ");

      TXRXstate = MODBUS_IDLE;

      break;



  }

  if (LogString.length() > 1 ) addLog(LOG_LEVEL_DEBUG, LogString);

  return true;

}



bool Modbus::hasTimeout()

{

  if ( (millis() - timeout) > 10000) {

    LogString += F("Modbus RX timeout. "); LogString += String(ModbusClient->available());

    errcnt++;

    TXRXstate = MODBUS_IDLE;

    return true;

  }

  return false;

}
# 425 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Modbus.ino"
bool Modbus::tryRead (uint8_t ModbusID, uint16_t M_register, MODBUS_registerTypes_t type, char* IPaddress, double &result) {

  if (isBusy()) return false;

  if (available()) {

    if ((currentFunction == MODBUS_FUNCTION_READ ) && (currentRegister == M_register)) {

      result = read();

      return true;

    }

  } else {

    begin(MODBUS_FUNCTION_READ, ModbusID, M_register, type, IPaddress);

  }

  return false;

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
#define IPADDR2STR(addr) (uint8_t)((uint32_t)addr & 0xFF), (uint8_t)(((uint32_t)addr >> 8) & 0xFF), (uint8_t)(((uint32_t)addr >> 16) & 0xFF), (uint8_t)(((uint32_t)addr >> 24) & 0xFF)
# 23 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
void syslog(byte logLevel, const char *message)

{

  if (Settings.Syslog_IP[0] != 0 && wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED)

  {

    IPAddress broadcastIP(Settings.Syslog_IP[0], Settings.Syslog_IP[1], Settings.Syslog_IP[2], Settings.Syslog_IP[3]);

    portUDP.beginPacket(broadcastIP, 514);

    char str[256];

    str[0] = 0;

    byte prio = Settings.SyslogFacility * 8;

    if ( logLevel == LOG_LEVEL_ERROR )

      prio += 3;

    else if ( logLevel == LOG_LEVEL_INFO )

      prio += 5;

    else

      prio += 7;
# 61 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
    snprintf_P(str, sizeof(str), PSTR("<%u>%s EspEasy: %s"), prio, Settings.Name, message);







    #if defined(ESP8266)

      portUDP.write(str);

    #endif

    #if defined(ESP32)

      portUDP.write((uint8_t*)str,strlen(str));

    #endif

    portUDP.endPacket();

  }

}
# 97 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
boolean runningUPDCheck = false;

void checkUDP()

{

  if (Settings.UDPPort == 0)

    return;



  if (runningUPDCheck)

    return;



  runningUPDCheck = true;





  int packetSize = portUDP.parsePacket();

  if (packetSize > 0 )

  {

    statusLED(true);



    IPAddress remoteIP = portUDP.remoteIP();

    if (portUDP.remotePort() == 123)

    {



      runningUPDCheck = false;

      return;

    }

    if (packetSize >= 2 && packetSize < UDP_PACKETSIZE_MAX) {



      std::vector<char> packetBuffer;

      packetBuffer.resize(packetSize + 1);

      memset(&packetBuffer[0], 0, packetSize + 1);



      int len = portUDP.read(&packetBuffer[0], packetSize);

      if (len >= 2) {

        if (packetBuffer[0] != 255)

        {

          packetBuffer[len] = 0;

          String request = &packetBuffer[0];

          addLog(LOG_LEVEL_DEBUG, request);

          struct EventStruct TempEvent;

          parseCommandString(&TempEvent, request);

          TempEvent.Source = VALUE_SOURCE_SYSTEM;

          if (!PluginCall(PLUGIN_WRITE, &TempEvent, request))

            ExecuteCommand(VALUE_SOURCE_SYSTEM, &packetBuffer[0]);

        }

        else

        {



          switch (packetBuffer[1])

          {



            case 1:

              {

                if (len < 13)

                  break;

                byte mac[6];

                byte ip[4];

                byte unit = packetBuffer[12];

                for (byte x = 0; x < 6; x++)

                  mac[x] = packetBuffer[x + 2];

                for (byte x = 0; x < 4; x++)

                  ip[x] = packetBuffer[x + 8];



                Nodes[unit].age = 0;

                NodesMap::iterator it = Nodes.find(unit);

                if (it != Nodes.end()) {

                  for (byte x = 0; x < 4; x++)

                    it->second.ip[x] = packetBuffer[x + 8];

                  it->second.age = 0;

                  if (len >= 41)

                  {

                    it->second.build = packetBuffer[13] + 256*packetBuffer[14];

                    char tmpNodeName[26] = {0};

                    memcpy(&tmpNodeName[0], reinterpret_cast<byte*>(&packetBuffer[15]), 25);

                    tmpNodeName[25] = 0;

                    it->second.nodeName = tmpNodeName;

                    it->second.nodeName.trim();

                    it->second.nodeType = packetBuffer[40];

                  }

                }



                char macaddress[20];

                formatMAC(mac, macaddress);

                char ipaddress[20];

                formatIP(ip, ipaddress);

                if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE)) {

                  char log[80];

                  sprintf_P(log, PSTR("UDP  : %s,%s,%u"), macaddress, ipaddress, unit);

                  addLog(LOG_LEVEL_DEBUG_MORE, log);

                }

                break;

              }



            default:

              {

                struct EventStruct TempEvent;

                TempEvent.Data = reinterpret_cast<byte*>(&packetBuffer[0]);

                TempEvent.Par1 = remoteIP[3];

                TempEvent.Par2 = len;

                PluginCall(PLUGIN_UDP_IN, &TempEvent, dummyString);

                CPluginCall(CPLUGIN_UDP_IN, &TempEvent);

                break;

              }

          }

        }

      }

    }

  }

  #if defined(ESP32)

    portUDP.flush();

  #endif

  runningUPDCheck = false;

}
# 329 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
void SendUDPCommand(byte destUnit, char* data, byte dataLength)

{

  if (!WiFiConnected(100)) {

    return;

  }

  if (destUnit != 0)

  {

    sendUDP(destUnit, (byte*)data, dataLength);

    delay(10);

  } else {

    for (NodesMap::iterator it = Nodes.begin(); it != Nodes.end(); ++it) {

      if (it->first != Settings.Unit) {

        sendUDP(it->first, (byte*)data, dataLength);

        delay(10);

      }

    }

  }

  delay(50);

}
# 377 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
void sendUDP(byte unit, byte* data, byte size)

{

  if (!WiFiConnected(100)) {

    return;

  }



  IPAddress remoteNodeIP;

  if (unit == 255)

    remoteNodeIP = {255,255,255,255};

  else {

    NodesMap::iterator it = Nodes.find(unit);

    if (it == Nodes.end())

      return;

    if (it->second.ip[0] == 0)

      return;

    remoteNodeIP = it->second.ip;

  }



  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE)) {

    String log = F("UDP  : Send UDP message to ");

    log += unit;

    addLog(LOG_LEVEL_DEBUG_MORE, log);

  }



  statusLED(true);

  portUDP.beginPacket(remoteNodeIP, Settings.UDPPort);

  portUDP.write(data, size);

  portUDP.endPacket();

}
# 445 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
void refreshNodeList()

{

  for (NodesMap::iterator it = Nodes.begin(); it != Nodes.end(); ) {

    bool mustRemove = true;

    if (it->second.ip[0] != 0) {

      if (it->second.age < 10) {

        it->second.age++;

        mustRemove = false;

        ++it;

      }

    }

    if (mustRemove) {

      it = Nodes.erase(it);

    }

  }

}
# 485 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
void sendSysInfoUDP(byte repeats)

{

  if (Settings.UDPPort == 0 || !WiFiConnected(100))

    return;
# 517 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
  addLog(LOG_LEVEL_DEBUG_MORE, F("UDP  : Send Sysinfo message"));

  for (byte counter = 0; counter < repeats; counter++)

  {

    uint8_t mac[] = {0, 0, 0, 0, 0, 0};

    uint8_t* macread = WiFi.macAddress(mac);

    byte data[80];

    data[0] = 255;

    data[1] = 1;

    for (byte x = 0; x < 6; x++)

      data[x + 2] = macread[x];

    IPAddress ip = WiFi.localIP();

    for (byte x = 0; x < 4; x++)

      data[x + 8] = ip[x];

    data[12] = Settings.Unit;

    data[13] = Settings.Build & 0xff;

    data[14] = Settings.Build >> 8;

    memcpy((byte*)data+15,Settings.Name,25);

    data[40] = NODE_TYPE_ID;

    statusLED(true);



    IPAddress broadcastIP(255, 255, 255, 255);

    portUDP.beginPacket(broadcastIP, Settings.UDPPort);

    portUDP.write(data, 80);

    portUDP.endPacket();

    if (counter < (repeats - 1))

      delay(500);

  }



  Nodes[Settings.Unit].age = 0;



  NodesMap::iterator it = Nodes.find(Settings.Unit);

  if (it != Nodes.end())

  {

    IPAddress ip = WiFi.localIP();

    for (byte x = 0; x < 4; x++)

      it->second.ip[x] = ip[x];

    it->second.age = 0;

    it->second.build = Settings.Build;

    it->second.nodeType = NODE_TYPE_ID;

  }

}



#if defined(ESP8266)







void SSDP_schema(WiFiClient &client) {

  if (!WiFiConnected(100)) {

    return;

  }



  const IPAddress ip = WiFi.localIP();

  const uint32_t chipId = ESP.getChipId();

  char uuid[64];

  sprintf_P(uuid, PSTR("38323636-4558-4dda-9188-cda0e6%02x%02x%02x"),

            (uint16_t) ((chipId >> 16) & 0xff),

            (uint16_t) ((chipId >> 8) & 0xff),

            (uint16_t) chipId & 0xff );



  String ssdp_schema = F(

                         "HTTP/1.1 200 OK\r\n"

                         "Content-Type: text/xml\r\n"

                         "Connection: close\r\n"

                         "Access-Control-Allow-Origin: *\r\n"

                         "\r\n"

                         "<?xml version=\"1.0\"?>"

                         "<root xmlns=\"urn:schemas-upnp-org:device-1-0\">"

                         "<specVersion>"

                         "<major>1</major>"

                         "<minor>0</minor>"

                         "</specVersion>"

                         "<URLBase>http://");

  ssdp_schema += formatIP(ip);

  ssdp_schema += F(":80/</URLBase>"

                   "<device>"

                   "<deviceType>urn:schemas-upnp-org:device:BinaryLight:1</deviceType>"

                   "<friendlyName>");

  ssdp_schema += Settings.Name;

  ssdp_schema += F("</friendlyName>"

                   "<presentationURL>/</presentationURL>"

                   "<serialNumber>");

  ssdp_schema += ESP.getChipId();

  ssdp_schema += F("</serialNumber>"

                   "<modelName>ESP Easy</modelName>"

                   "<modelNumber>");

  ssdp_schema += BUILD_GIT;

  ssdp_schema += F("</modelNumber>"

                   "<modelURL>http://www.letscontrolit.com</modelURL>"

                   "<manufacturer>http://www.letscontrolit.com</manufacturer>"

                   "<manufacturerURL>http://www.letscontrolit.com</manufacturerURL>"

                   "<UDN>uuid:");

  ssdp_schema += uuid;

  ssdp_schema += F("</UDN></device>"

                   "</root>\r\n"

                   "\r\n");



  client.printf(ssdp_schema.c_str());

}
# 723 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
typedef enum {

  NONE,

  SEARCH,

  NOTIFY

} ssdp_method_t;



UdpContext* _server;



IPAddress _respondToAddr;

uint16_t _respondToPort;



bool _pending;

unsigned short _delay;

unsigned long _process_time;

unsigned long _notify_time;



#define SSDP_INTERVAL 1200

#define SSDP_PORT 1900

#define SSDP_METHOD_SIZE 10

#define SSDP_URI_SIZE 2

#define SSDP_BUFFER_SIZE 64

#define SSDP_MULTICAST_TTL 2



static const IPAddress SSDP_MULTICAST_ADDR(239, 255, 255, 250);
# 781 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
bool SSDP_begin() {

  _pending = false;



  if (_server) {

    _server->unref();

    _server = 0;

  }



  _server = new UdpContext;

  _server->ref();



  ip_addr_t ifaddr;

  ifaddr.addr = WiFi.localIP();

  ip_addr_t multicast_addr;

  multicast_addr.addr = (uint32_t) SSDP_MULTICAST_ADDR;

  if (igmp_joingroup(&ifaddr, &multicast_addr) != ERR_OK ) {

    return false;

  }



  if (!_server->listen(*IP_ADDR_ANY, SSDP_PORT)) {

    return false;

  }



  _server->setMulticastInterface(ifaddr);

  _server->setMulticastTTL(SSDP_MULTICAST_TTL);

  _server->onRx(&SSDP_update);

  if (!_server->connect(multicast_addr, SSDP_PORT)) {

    return false;

  }



  SSDP_update();



  return true;

}
# 859 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
void SSDP_send(byte method) {

  char buffer[1460];

  uint32_t ip = WiFi.localIP();



  uint32_t chipId = ESP.getChipId();



  char uuid[64];

  sprintf_P(uuid, PSTR("38323636-4558-4dda-9188-cda0e6%02x%02x%02x"),

            (uint16_t) ((chipId >> 16) & 0xff),

            (uint16_t) ((chipId >> 8) & 0xff),

            (uint16_t) chipId & 0xff );



  String _ssdp_response_template = F(

                                     "HTTP/1.1 200 OK\r\n"

                                     "EXT:\r\n"

                                     "ST: upnp:rootdevice\r\n");



  String _ssdp_notify_template = F(

                                   "NOTIFY * HTTP/1.1\r\n"

                                   "HOST: 239.255.255.250:1900\r\n"

                                   "NT: upnp:rootdevice\r\n"

                                   "NTS: ssdp:alive\r\n");



  String _ssdp_packet_template = F(

                                   "%s"

                                   "CACHE-CONTROL: max-age=%u\r\n"

                                   "SERVER: Arduino/1.0 UPNP/1.1 ESPEasy/%u\r\n"

                                   "USN: uuid:%s\r\n"

                                   "LOCATION: http://%u.%u.%u.%u:80/ssdp.xml\r\n"

                                   "\r\n");



  int len = snprintf(buffer, sizeof(buffer),

                     _ssdp_packet_template.c_str(),

                     (method == 0) ? _ssdp_response_template.c_str() : _ssdp_notify_template.c_str(),

                     SSDP_INTERVAL,

                     Settings.Build,

                     uuid,

                     IPADDR2STR(&ip)

                    );



  _server->append(buffer, len);



  ip_addr_t remoteAddr;

  uint16_t remotePort;

  if (method == 0) {

    remoteAddr.addr = _respondToAddr;

    remotePort = _respondToPort;

  } else {

    remoteAddr.addr = SSDP_MULTICAST_ADDR;

    remotePort = SSDP_PORT;

  }

  _server->send(&remoteAddr, remotePort);

  statusLED(true);

}
# 977 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
void SSDP_update() {



  if (!_pending && _server->next()) {

    ssdp_method_t method = NONE;



    _respondToAddr = _server->getRemoteAddress();

    _respondToPort = _server->getRemotePort();



    typedef enum {METHOD, URI, PROTO, KEY, VALUE, ABORT} states;

    states state = METHOD;



    typedef enum {START, MAN, ST, MX} headers;

    headers header = START;



    uint8_t cursor = 0;

    uint8_t cr = 0;



    char buffer[SSDP_BUFFER_SIZE] = {0};



    while (_server->getSize() > 0) {

      char c = _server->read();



      (c == '\r' || c == '\n') ? cr++ : cr = 0;



      switch (state) {

        case METHOD:

          if (c == ' ') {

            if (strcmp_P(buffer, PSTR("M-SEARCH")) == 0) method = SEARCH;

            else if (strcmp_P(buffer, PSTR("NOTIFY")) == 0) method = NOTIFY;



            if (method == NONE) state = ABORT;

            else state = URI;

            cursor = 0;



          } else if (cursor < SSDP_METHOD_SIZE - 1) {

            buffer[cursor++] = c;

            buffer[cursor] = '\0';

          }

          break;

        case URI:

          if (c == ' ') {

            if (strcmp(buffer, "*")) state = ABORT;

            else state = PROTO;

            cursor = 0;

          } else if (cursor < SSDP_URI_SIZE - 1) {

            buffer[cursor++] = c;

            buffer[cursor] = '\0';

          }

          break;

        case PROTO:

          if (cr == 2) {

            state = KEY;

            cursor = 0;

          }

          break;

        case KEY:

          if (cr == 4) {

            _pending = true;

            _process_time = millis();

          }

          else if (c == ' ') {

            cursor = 0;

            state = VALUE;

          }

          else if (c != '\r' && c != '\n' && c != ':' && cursor < SSDP_BUFFER_SIZE - 1) {

            buffer[cursor++] = c;

            buffer[cursor] = '\0';

          }

          break;

        case VALUE:

          if (cr == 2) {

            switch (header) {

              case START:

                break;

              case MAN:

                break;

              case ST:

                if (strcmp_P(buffer, PSTR("ssdp:all"))) {

                  state = ABORT;

                }



                if (strcmp_P(buffer, PSTR("urn:schemas-upnp-org:device:BinaryLight:1")) == 0) {

                  _pending = true;

                  _process_time = millis();

                  state = KEY;

                }

                break;

              case MX:

                _delay = random(0, atoi(buffer)) * 1000L;

                break;

            }



            if (state != ABORT) {

              state = KEY;

              header = START;

              cursor = 0;

            }

          } else if (c != '\r' && c != '\n') {

            if (header == START) {

              if (strncmp(buffer, "MA", 2) == 0) header = MAN;

              else if (strcmp(buffer, "ST") == 0) header = ST;

              else if (strcmp(buffer, "MX") == 0) header = MX;

            }



            if (cursor < SSDP_BUFFER_SIZE - 1) {

              buffer[cursor++] = c;

              buffer[cursor] = '\0';

            }

          }

          break;

        case ABORT:

          _pending = false; _delay = 0;

          break;

      }

    }

  }



  if (_pending && timeOutReached(_process_time + _delay)) {

    _pending = false; _delay = 0;

    SSDP_send(NONE);

  } else if (_notify_time == 0 || timeOutReached(_notify_time + (SSDP_INTERVAL * 1000L))) {

    _notify_time = millis();

    SSDP_send(NOTIFY);

  }



  if (_pending) {

    while (_server->next())

      _server->flush();

  }

}

#endif





bool WiFiConnected(uint32_t timeout_ms) {

  uint32_t timer = millis() + (timeout_ms > 500 ? 500 : timeout_ms);

  uint32_t min_delay = timeout_ms / 20;

  if (min_delay < 10) {

    yield();

    min_delay = 10;

  }







  while (!WiFiConnected()) {

    if (timeOutReached(timer)) {

      return false;

    }

    delay(min_delay);

  }

  return true;

}



bool hostReachable(const IPAddress& ip) {

  if (!WiFiConnected()) return false;



  return true;
# 1345 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Networking.ino"
}



bool hostReachable(const String& hostname) {

  if (!WiFiConnected()) return false;

  IPAddress remote_addr;

  if (WiFi.hostByName(hostname.c_str(), remote_addr)) {

    return hostReachable(remote_addr);

  }

  String log = F("Hostname cannot be resolved: ");

  log += hostname;

  addLog(LOG_LEVEL_ERROR, log);

  return false;

}







bool beginWiFiUDP_randomPort(WiFiUDP& udp) {

  unsigned int attempts = 3;

  while (attempts > 0) {

    --attempts;

    long port = random(1025, 65535);

    if (udp.begin(port) != 0)

      return true;

  }

  return false;

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
#define TIMER_ID_SHIFT 28



#define SYSTEM_EVENT_QUEUE 0

#define CONST_INTERVAL_TIMER 1

#define PLUGIN_TASK_TIMER 2

#define TASK_DEVICE_TIMER 3



#include <list>

struct EventStructCommandWrapper {

  EventStructCommandWrapper() : id(0) {}

  EventStructCommandWrapper(unsigned long i, const struct EventStruct& e) : id(i), event(e) {}



  unsigned long id;

  String cmd;

  String line;

  struct EventStruct event;

};

std::list<EventStructCommandWrapper> EventQueue;
# 47 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
void setTimer(unsigned long timerType, unsigned long id, unsigned long msecFromNow) {

  setNewTimerAt(getMixedId(timerType, id), millis() + msecFromNow);

}



void setNewTimerAt(unsigned long id, unsigned long timer) {

  START_TIMER;

  msecTimerHandler.registerAt(id, timer);

  STOP_TIMER(SET_NEW_TIMER);

}





unsigned long getMixedId(unsigned long timerType, unsigned long id) {

  return (timerType << TIMER_ID_SHIFT) + id;

}
# 83 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
void handle_schedule() {

  unsigned long timer;

  const unsigned long mixed_id = msecTimerHandler.getNextId(timer);

  if (mixed_id == 0) {







    backgroundtasks();

    process_system_event_queue();

    return;

  }

  const unsigned long timerType = (mixed_id >> TIMER_ID_SHIFT);

  const unsigned long mask = (1 << TIMER_ID_SHIFT) -1;

  const unsigned long id = mixed_id & mask;



  switch (timerType) {

    case CONST_INTERVAL_TIMER:

      process_interval_timer(id, timer);

      break;

    case PLUGIN_TASK_TIMER:

      process_plugin_task_timer(id);

      break;

    case TASK_DEVICE_TIMER:

      process_task_device_timer(id, timer);

      break;

  }

}
# 149 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
void setIntervalTimer(unsigned long id) {

  setIntervalTimer(id, millis());

}



void setIntervalTimerAt(unsigned long id, unsigned long newtimer) {

  setNewTimerAt(getMixedId(CONST_INTERVAL_TIMER, id), newtimer);

}



void setIntervalTimerOverride(unsigned long id, unsigned long msecFromNow) {

  unsigned long timer = millis();

  setNextTimeInterval(timer, msecFromNow);

  setNewTimerAt(getMixedId(CONST_INTERVAL_TIMER, id), timer);

}



void scheduleNextDelayQueue(unsigned long id, unsigned long nextTime) {

  if (nextTime != 0) {



    setIntervalTimerAt(id, nextTime);

  }

}



void setIntervalTimer(unsigned long id, unsigned long lasttimer) {



  unsigned long interval = 0;

  switch (id) {

    case TIMER_20MSEC: interval = 20; break;

    case TIMER_100MSEC: interval = 100; break;

    case TIMER_1SEC: interval = 1000; break;

    case TIMER_30SEC: interval = 30000; break;

    case TIMER_MQTT: interval = timermqtt_interval; break;

    case TIMER_STATISTICS: interval = 30000; break;





    case TIMER_MQTT_DELAY_QUEUE:

    case TIMER_C001_DELAY_QUEUE:

    case TIMER_C003_DELAY_QUEUE:

    case TIMER_C004_DELAY_QUEUE:

    case TIMER_C007_DELAY_QUEUE:

    case TIMER_C008_DELAY_QUEUE:

    case TIMER_C009_DELAY_QUEUE:

    case TIMER_C010_DELAY_QUEUE:

    case TIMER_C011_DELAY_QUEUE:

    case TIMER_C012_DELAY_QUEUE:

    case TIMER_C013_DELAY_QUEUE:

      interval = 1000; break;

  }

  unsigned long timer = lasttimer;

  setNextTimeInterval(timer, interval);

  setNewTimerAt(getMixedId(CONST_INTERVAL_TIMER, id), timer);

}



void process_interval_timer(unsigned long id, unsigned long lasttimer) {





  setIntervalTimer(id, lasttimer);

  switch (id) {

    case TIMER_20MSEC:

      run50TimesPerSecond();

      break;

    case TIMER_100MSEC:

      if(!UseRTOSMultitasking)

        run10TimesPerSecond();

      break;

    case TIMER_1SEC:

      runOncePerSecond();

      break;

    case TIMER_30SEC:

      runEach30Seconds();

      break;

    case TIMER_MQTT:

      runPeriodicalMQTT();

      break;

    case TIMER_STATISTICS:

      logTimerStatistics();

      break;

    case TIMER_MQTT_DELAY_QUEUE:

      processMQTTdelayQueue();

      break;

  #ifdef USES_C001

    case TIMER_C001_DELAY_QUEUE:

      process_c001_delay_queue();

      break;

  #endif

  #ifdef USES_C003

    case TIMER_C003_DELAY_QUEUE:

      process_c003_delay_queue();

      break;

  #endif

  #ifdef USES_C004

    case TIMER_C004_DELAY_QUEUE:

      process_c004_delay_queue();

      break;

  #endif

  #ifdef USES_C007

    case TIMER_C007_DELAY_QUEUE:

      process_c007_delay_queue();

      break;

  #endif

  #ifdef USES_C008

    case TIMER_C008_DELAY_QUEUE:

      process_c008_delay_queue();

      break;

  #endif

  #ifdef USES_C009

    case TIMER_C009_DELAY_QUEUE:

      process_c009_delay_queue();

      break;

  #endif

  #ifdef USES_C010

    case TIMER_C010_DELAY_QUEUE:

      process_c010_delay_queue();

      break;

  #endif

  #ifdef USES_C011

    case TIMER_C011_DELAY_QUEUE:

      process_c011_delay_queue();

      break;

  #endif

  #ifdef USES_C012

    case TIMER_C012_DELAY_QUEUE:

      process_c012_delay_queue();

      break;

  #endif
# 413 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
  }

}
# 427 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
unsigned long createPluginTaskTimerId(byte plugin, int Par1) {

  const unsigned long mask = (1 << TIMER_ID_SHIFT) -1;

  const unsigned long mixed = (Par1 << 8) + plugin;

  return (mixed & mask);

}
# 455 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
void setPluginTaskTimer(unsigned long timer, byte plugin, short taskIndex, int Par1, int Par2, int Par3, int Par4, int Par5)

{



  const unsigned long systemTimerId = createPluginTaskTimerId(plugin, Par1);

  systemTimerStruct timer_data;

  timer_data.TaskIndex = taskIndex;

  timer_data.Par1 = Par1;

  timer_data.Par2 = Par2;

  timer_data.Par3 = Par3;

  timer_data.Par4 = Par4;

  timer_data.Par5 = Par5;

  systemTimers[systemTimerId] = timer_data;

  setTimer(PLUGIN_TASK_TIMER, systemTimerId, timer);

}



void process_plugin_task_timer(unsigned long id) {

  START_TIMER;

  const systemTimerStruct timer_data = systemTimers[id];

  struct EventStruct TempEvent;

  TempEvent.TaskIndex = timer_data.TaskIndex;

  TempEvent.Par1 = timer_data.Par1;

  TempEvent.Par2 = timer_data.Par2;

  TempEvent.Par3 = timer_data.Par3;

  TempEvent.Par4 = timer_data.Par4;

  TempEvent.Par5 = timer_data.Par5;



  TempEvent.Source = VALUE_SOURCE_SYSTEM;

  const int y = getPluginId(timer_data.TaskIndex);
# 529 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
  if (y >= 0) {

    String dummy;

    Plugin_ptr[y](PLUGIN_TIMER_IN, &TempEvent, dummy);

  }

  systemTimers.erase(id);

  STOP_TIMER(PROC_SYS_TIMER);

}
# 561 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
void schedule_task_device_timer_at_init(unsigned long task_index) {

  unsigned long runAt = millis();

  if (!isDeepSleepEnabled()) {







    runAt += (task_index * 37) + Settings.MessageDelay;

  } else {

    runAt += (task_index * 11) + 10;

  }

  schedule_task_device_timer(task_index, runAt);

}





void schedule_all_task_device_timers() {

  for (byte task = 0; task < TASKS_MAX; task++) {

    schedule_task_device_timer_at_init(task);

  }

}



void schedule_all_tasks_using_MQTT_controller() {

  int ControllerIndex = firstEnabledMQTTController();

  if (ControllerIndex < 0) return;

  for (byte task = 0; task < TASKS_MAX; task++) {

    if (Settings.TaskDeviceSendData[ControllerIndex][task] &&

        Settings.ControllerEnabled[ControllerIndex] &&

        Settings.Protocol[ControllerIndex])

    {

      schedule_task_device_timer_at_init(task);

    }

  }

}



void schedule_task_device_timer(unsigned long task_index, unsigned long runAt) {
# 651 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
  if (task_index >= TASKS_MAX) return;

  byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[task_index]);

  if (!Device[DeviceIndex].TimerOption) return;

  if (Device[DeviceIndex].TimerOptional && Settings.TaskDeviceTimer[task_index] == 0) {

    return;

  }

  if (Settings.TaskDeviceEnabled[task_index]) {

    setNewTimerAt(getMixedId(TASK_DEVICE_TIMER, task_index), runAt);

  }

}



void process_task_device_timer(unsigned long task_index, unsigned long lasttimer) {

  unsigned long newtimer = Settings.TaskDeviceTimer[task_index];

  if (newtimer != 0) {

    newtimer = lasttimer + (newtimer * 1000);

    schedule_task_device_timer(task_index, newtimer);

  }

  START_TIMER;

  SensorSendTask(task_index);

  STOP_TIMER(SENSOR_SEND_TASK);

}
# 707 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
void schedule_plugin_task_event_timer(byte DeviceIndex, byte Function, struct EventStruct* event) {

  schedule_event_timer(TaskPluginEnum, DeviceIndex, Function, event);

}



void schedule_controller_event_timer(byte ProtocolIndex, byte Function, struct EventStruct* event) {

  schedule_event_timer(ControllerPluginEnum, ProtocolIndex, Function, event);

}



void schedule_notification_event_timer(byte NotificationProtocolIndex, byte Function, struct EventStruct* event) {

  schedule_event_timer(NotificationPluginEnum, NotificationProtocolIndex, Function, event);

}



void schedule_command_timer(const char * cmd, struct EventStruct *event, const char* line) {

  String cmdStr;

  cmdStr += cmd;

  String lineStr;

  lineStr += line;





  const int crc = calc_CRC16(cmdStr) ^ calc_CRC16(lineStr);

  const unsigned long mixedId = createSystemEventMixedId(CommandTimerEnum, static_cast<uint16_t>(crc));

  EventStructCommandWrapper eventWrapper(mixedId, *event);

  eventWrapper.cmd = cmdStr;

  eventWrapper.line = lineStr;

  EventQueue.push_back(eventWrapper);

}



void schedule_event_timer(PluginPtrType ptr_type, byte Index, byte Function, struct EventStruct* event) {

  const unsigned long mixedId = createSystemEventMixedId(ptr_type, Index, Function);





  EventQueue.emplace_back(mixedId, *event);



}



unsigned long createSystemEventMixedId(PluginPtrType ptr_type, uint16_t crc16) {

  unsigned long subId = ptr_type;

  subId = (subId << 16) + crc16;

  return getMixedId(SYSTEM_EVENT_QUEUE, subId);

}



unsigned long createSystemEventMixedId(PluginPtrType ptr_type, byte Index, byte Function) {

  unsigned long subId = ptr_type;

  subId = (subId << 8) + Index;

  subId = (subId << 8) + Function;

  return getMixedId(SYSTEM_EVENT_QUEUE, subId);

}



void process_system_event_queue() {

  if (EventQueue.size() == 0) return;

  unsigned long id = EventQueue.front().id;

  byte Function = id & 0xFF;

  byte Index = (id >> 8) & 0xFF;

  PluginPtrType ptr_type = static_cast<PluginPtrType>((id >> 16) & 0xFF);
# 823 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Scheduler.ino"
  String tmpString;

  switch (ptr_type) {

    case TaskPluginEnum:

      LoadTaskSettings(EventQueue.front().event.TaskIndex);

      Plugin_ptr[Index](Function, &EventQueue.front().event, tmpString);

      break;

    case ControllerPluginEnum:

      CPlugin_ptr[Index](Function, &EventQueue.front().event, tmpString);

      break;

    case NotificationPluginEnum:

      NPlugin_ptr[Index](Function, &EventQueue.front().event, tmpString);

      break;

    case CommandTimerEnum:

      {

        String status = doExecuteCommand(

            EventQueue.front().cmd.c_str(),

            &EventQueue.front().event,

            EventQueue.front().line.c_str());

        yield();

        SendStatus(EventQueue.front().event.Source, status);

        yield();

        break;

      }

  }

  EventQueue.pop_front();

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/Serial.ino"






#define INPUT_BUFFER_SIZE 128



byte SerialInByte;

int SerialInByteCounter = 0;

char InputBuffer_Serial[INPUT_BUFFER_SIZE + 2];



void serial()

{

  while (Serial.available())

  {

    yield();

    SerialInByte = Serial.read();

    if (SerialInByte == 255)

    {

      Serial.flush();

      return;

    }



    if (isprint(SerialInByte))

    {

      if (SerialInByteCounter < INPUT_BUFFER_SIZE)

        InputBuffer_Serial[SerialInByteCounter++] = SerialInByte;

    }



    if (SerialInByte == '\r' || SerialInByte == '\n')

    {

      if (SerialInByteCounter == 0)

        break;

      InputBuffer_Serial[SerialInByteCounter] = 0;

      Serial.write('>');

      Serial.println(InputBuffer_Serial);

      String action = InputBuffer_Serial;

      struct EventStruct TempEvent;

      parseCommandString(&TempEvent, action);

      TempEvent.Source = VALUE_SOURCE_SERIAL;

      if (!PluginCall(PLUGIN_WRITE, &TempEvent, action))

        ExecuteCommand(VALUE_SOURCE_SERIAL, InputBuffer_Serial);

      SerialInByteCounter = 0;

      InputBuffer_Serial[0] = 0;

    }

  }

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
# 9 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
unsigned long str2int(char *string)

{

  unsigned long temp = atof(string);

  return temp;

}
# 27 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
bool string2float(const String& string, float& floatvalue) {

  if (!isFloat(string)) return false;

  floatvalue = atof(string.c_str());

  return true;

}
# 47 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
boolean str2ip(const String& string, byte* IP) {

  return str2ip(string.c_str(), IP);

}



boolean str2ip(const char *string, byte* IP)

{

  IPAddress tmpip;

  if (*string == 0 || tmpip.fromString(string)) {



    for (byte i = 0; i < 4; ++i)

      IP[i] = tmpip[i];

    return true;

  }

  return false;

}
# 85 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
void formatIP(const IPAddress& ip, char (&strIP)[20]) {

  sprintf_P(strIP, PSTR("%u.%u.%u.%u"), ip[0], ip[1], ip[2], ip[3]);

}



String formatIP(const IPAddress& ip) {

  char strIP[20];

  formatIP(ip, strIP);

  return String(strIP);

}



void formatMAC(const uint8_t* mac, char (&strMAC)[20]) {

  sprintf_P(strMAC, PSTR("%02X:%02X:%02X:%02X:%02X:%02X"), mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);

}



String formatMAC(const uint8_t* mac) {

  char str[20];

  formatMAC(mac, str);

  return String(str);

}



String formatToHex(unsigned long value, const String& prefix) {

  String result = prefix;

  String hex(value, HEX);

  hex.toUpperCase();

  result += hex;

  return result;

}



String formatToHex(unsigned long value) {

  return formatToHex(value, F("0x"));

}



String formatHumanReadable(unsigned long value, unsigned long factor) {

  String result = formatHumanReadable(value, factor, 2);

  result.replace(F(".00"), "");

  return result;

}



String formatHumanReadable(unsigned long value, unsigned long factor, int NrDecimals) {

  float floatValue(value);

  byte steps = 0;

  while (value >= factor) {

    value /= factor;

    ++steps;

    floatValue /= float(factor);

  }

  String result = toString(floatValue, NrDecimals);

  switch (steps) {

    case 0: return String(value);

    case 1: result += 'k'; break;

    case 2: result += 'M'; break;

    case 3: result += 'G'; break;

    case 4: result += 'T'; break;

    default:

      result += '*';

      result += factor;

      result += '^';

      result += steps;

      break;

  }

  return result;

}



String formatToHex_decimal(unsigned long value) {

  return formatToHex_decimal(value, 1);

}



String formatToHex_decimal(unsigned long value, unsigned long factor) {

  String result = formatToHex(value);

  result += F(" (");

  if (factor > 1) {

    result += formatHumanReadable(value, factor);

  } else {

    result += value;

  }

  result += ')';

  return result;

}
# 249 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
String toString(float value, byte decimals)

{

  String sValue = String(value, decimals);

  sValue.trim();

  return sValue;

}



String toString(WiFiMode_t mode)

{

  String result = F("Undefinited");

  switch (mode)

  {

    case WIFI_OFF:

      result = F("Off");

      break;

    case WIFI_STA:

      result = F("STA");

      break;

    case WIFI_AP:

      result = F("AP");

      break;

    case WIFI_AP_STA:

      result = F("AP+STA");

      break;

    default:

      break;

  }

  return result;

}



String toString(bool value) {

  return value ? F("true") : F("false");

}
# 323 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
String doFormatUserVar(byte TaskIndex, byte rel_index, bool mustCheck, bool& isvalid) {

  isvalid = true;

  const byte BaseVarIndex = TaskIndex * VARS_PER_TASK;

  const byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);

  if (Device[DeviceIndex].ValueCount <= rel_index) {

    isvalid = false;

    String log = F("No sensor value for TaskIndex: ");

    log += TaskIndex;

    log += F(" varnumber: ");

    log += rel_index;

    addLog(LOG_LEVEL_ERROR, log);

    return "";

  }

  if (Device[DeviceIndex].VType == SENSOR_TYPE_LONG) {

    return String((unsigned long)UserVar[BaseVarIndex] + ((unsigned long)UserVar[BaseVarIndex + 1] << 16));

  }

  float f(UserVar[BaseVarIndex + rel_index]);

  if (mustCheck && !isValidFloat(f)) {

    isvalid = false;

    String log = F("Invalid float value for TaskIndex: ");

    log += TaskIndex;

    log += F(" varnumber: ");

    log += rel_index;

    addLog(LOG_LEVEL_DEBUG, log);

    f = 0;

  }

  return toString(f, ExtraTaskSettings.TaskDeviceValueDecimals[rel_index]);

}



String formatUserVarNoCheck(byte TaskIndex, byte rel_index) {

  bool isvalid;

  return doFormatUserVar(TaskIndex, rel_index, false, isvalid);

}



String formatUserVar(byte TaskIndex, byte rel_index, bool& isvalid) {

  return doFormatUserVar(TaskIndex, rel_index, true, isvalid);

}



String formatUserVarNoCheck(struct EventStruct *event, byte rel_index)

{

  return formatUserVarNoCheck(event->TaskIndex, rel_index);

}



String formatUserVar(struct EventStruct *event, byte rel_index, bool& isvalid)

{

  return formatUserVar(event->TaskIndex, rel_index, isvalid);

}
# 425 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
String wrap_String(const String& string, const String& wrap) {

  String result;

  result.reserve(string.length() + 2* wrap.length());

  result = wrap;

  result += string;

  result += wrap;

  return result;

}
# 449 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
String to_json_object_value(const String& object, const String& value) {

  String result;

  result.reserve(object.length() + value.length() + 6);

  result = wrap_String(object, F("\""));

  result += F(":");

  if (value.length() == 0 || !isFloat(value)) {

    if (value.indexOf('\n') == -1 && value.indexOf('"') == -1 && value.indexOf(F("Pragma")) == -1) {

      result += wrap_String(value, F("\""));

    } else {

      String tmpValue(value);

      tmpValue.replace('\n', '^');

      tmpValue.replace('"', '\'');

      tmpValue.replace(F("Pragma"), F("Bugje!"));

      result += wrap_String(tmpValue, F("\""));

    }

  } else {

    result += value;

  }

  return result;

}
# 499 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
String stripWrappingChar(const String& text, char wrappingChar) {

  unsigned int length = text.length();

  if (length >= 2 && stringWrappedWithChar(text, wrappingChar)) {

    return text.substring(1, length -1);

  }

  return text;

}



bool stringWrappedWithChar(const String& text, char wrappingChar) {

  unsigned int length = text.length();

  if (length < 2) return false;

  if (text.charAt(0) != wrappingChar) return false;

  return (text.charAt(length - 1) == wrappingChar);

}



bool isQuoteChar(char c) {

  return (c == '\'' || c == '"');

}



bool isParameterSeparatorChar(char c) {

  return (c == ',' || c == ' ');

}



String stripQuotes(const String& text) {

  if (text.length() >= 2) {

    char c = text.charAt(0);

    if (isQuoteChar(c)) {

      return stripWrappingChar(text, c);

    }

  }

  return text;

}
# 571 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
String parseString(const String& string, byte indexFind, bool toEndOfString, bool toLowerCase) {

  int startpos = 0;

  if (indexFind > 0) {

    startpos = getParamStartPos(string, indexFind);

    if (startpos < 0) {

      return "";

    }

  }

  const int endpos = getParamStartPos(string, indexFind + 1);

  String result;

  if (toEndOfString || endpos <= 0) {

    result = string.substring(startpos);

  } else {

    result = string.substring(startpos, endpos - 1);

  }

  if (toLowerCase)

    result.toLowerCase();

  return stripQuotes(result);

}



String parseString(const String& string, byte indexFind) {

  return parseString(string, indexFind, false, true);

}



String parseStringKeepCase(const String& string, byte indexFind) {

  return parseString(string, indexFind, false, false);

}



String parseStringToEnd(const String& string, byte indexFind) {

  return parseString(string, indexFind, true, true);

}



String parseStringToEndKeepCase(const String& string, byte indexFind) {

  return parseString(string, indexFind, true, false);

}
# 649 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
int getParamStartPos(const String& string, byte indexFind)

{



  if (indexFind <= 1) return 0;

  byte count = 1;

  bool quotedStringActive = false;

  char quoteStartChar = '"';

  unsigned int lastParamStartPos = 0;

  const unsigned int strlength = string.length();

  if (strlength < indexFind) return -1;

  for (unsigned int x = 0; x < (strlength - 1); ++x)

  {

    const char c = string.charAt(x);



    if (!quotedStringActive) {

      if (isQuoteChar(c)) {



        if (lastParamStartPos == x ) {

          quotedStringActive = true;

          quoteStartChar = c;

        }

      }

    } else {

      if (c == quoteStartChar) {



        quotedStringActive = false;

      }

    }



    if (!quotedStringActive) {

      if (isParameterSeparatorChar(c))

      {

        lastParamStartPos = x + 1;

        ++count;

        if (count == indexFind) {

          return lastParamStartPos;

        }

      }

    }

  }

  return -1;

}





void htmlEscape(String & html)

{

  html.replace("&", F("&amp;"));

  html.replace("\"", F("&quot;"));

  html.replace("'", F("&#039;"));

  html.replace("<", F("&lt;"));

  html.replace(">", F("&gt;"));

}
# 761 "C:/Users/admin/Documents/GitHub/ESPEasy/src/StringConverter.ino"
void parseControllerVariables(String& s, struct EventStruct *event, boolean useURLencode) {

  parseSystemVariables(s, useURLencode);

  parseEventVariables(s, event, useURLencode);

  parseStandardConversions(s, useURLencode);

}





void repl(const String& key, const String& val, String& s, boolean useURLencode)

{

  if (useURLencode) {

    s.replace(key, URLEncode(val.c_str()));

  } else {

    s.replace(key, val);

  }

}



void parseSpecialCharacters(String& s, boolean useURLencode)

{

  bool no_accolades = s.indexOf('{') == -1 || s.indexOf('}') == -1;

  bool no_html_entity = s.indexOf('&') == -1 || s.indexOf(';') == -1;

  if (no_accolades && no_html_entity)

    return;



  {



    const char degree[3] = {0xc2, 0xb0, 0};

    const char degreeC[4] = {0xe2, 0x84, 0x83, 0};

    const char degree_C[4] = {0xc2, 0xb0, 'C', 0};

    repl(F("{D}"), degree, s, useURLencode);

    repl(F("&deg;"), degree, s, useURLencode);

    repl(degreeC, degree_C, s, useURLencode);

  }

  {



    const char laquo[3] = {0xc2, 0xab, 0};

    const char raquo[3] = {0xc2, 0xbb, 0};

    repl(F("{<<}"), laquo, s, useURLencode);

    repl(F("&laquo;"), laquo, s, useURLencode);

    repl(F("{>>}"), raquo, s, useURLencode);

    repl(F("&raquo;"), raquo, s, useURLencode);

  }

  {



    const char mu[3] = {0xc2, 0xb5, 0};

    repl(F("{u}"), mu, s, useURLencode);

    repl(F("&micro;"), mu, s, useURLencode);

  }

  {



    const char euro[4] = {0xe2, 0x82, 0xac, 0};

    const char yen[3] = {0xc2, 0xa5, 0};

    const char pound[3] = {0xc2, 0xa3, 0};

    const char cent[3] = {0xc2, 0xa2, 0};

    repl(F("{E}"), euro, s, useURLencode);

    repl(F("&euro;"), euro, s, useURLencode);

    repl(F("{Y}"), yen, s, useURLencode);

    repl(F("&yen;"), yen, s, useURLencode);

    repl(F("{P}"), pound, s, useURLencode);

    repl(F("&pound;"), pound, s, useURLencode);

    repl(F("{c}"), cent, s, useURLencode);

    repl(F("&cent;"), cent, s, useURLencode);

  }

  {



    const char sup1[3] = {0xc2, 0xb9, 0};

    const char sup2[3] = {0xc2, 0xb2, 0};

    const char sup3[3] = {0xc2, 0xb3, 0};

    const char frac14[3] = {0xc2, 0xbc, 0};

    const char frac12[3] = {0xc2, 0xbd, 0};

    const char frac34[3] = {0xc2, 0xbe, 0};

    const char plusmn[3] = {0xc2, 0xb1, 0};

    const char times[3] = {0xc3, 0x97, 0};

    const char divide[3] = {0xc3, 0xb7, 0};

    repl(F("{^1}"), sup1, s, useURLencode);

    repl(F("&sup1;"), sup1, s, useURLencode);

    repl(F("{^2}"), sup2, s, useURLencode);

    repl(F("&sup2;"), sup2, s, useURLencode);

    repl(F("{^3}"), sup3, s, useURLencode);

    repl(F("&sup3;"), sup3, s, useURLencode);

    repl(F("{1_4}"), frac14, s, useURLencode);

    repl(F("&frac14;"), frac14, s, useURLencode);

    repl(F("{1_2}"), frac12, s, useURLencode);

    repl(F("&frac12;"), frac12, s, useURLencode);

    repl(F("{3_4}"), frac34, s, useURLencode);

    repl(F("&frac34;"), frac34, s, useURLencode);

    repl(F("{+-}"), plusmn, s, useURLencode);

    repl(F("&plusmn;"), plusmn, s, useURLencode);

    repl(F("{x}"), times, s, useURLencode);

    repl(F("&times;"), times, s, useURLencode);

    repl(F("{..}"), divide, s, useURLencode);

    repl(F("&divide;"), divide, s, useURLencode);

  }

}





#define SMART_REPL(T,S) if (s.indexOf(T) != -1) { repl((T), (S), s, useURLencode);}

#define SMART_REPL_T(T,S) if (s.indexOf(T) != -1) { (S((T), s, useURLencode));}

void parseSystemVariables(String& s, boolean useURLencode)

{

  parseSpecialCharacters(s, useURLencode);

  if (s.indexOf('%') == -1)

    return;



  #if FEATURE_ADC_VCC

    repl(F("%vcc%"), String(vcc), s, useURLencode);

  #endif

  repl(F("%CR%"), F("\r"), s, useURLencode);

  repl(F("%LF%"), F("\n"), s, useURLencode);

  repl(F("%SP%"), F(" "), s, useURLencode);

  repl(F("%R%"), F("\\r"), s, useURLencode);

  repl(F("%N%"), F("\\n"), s, useURLencode);

  SMART_REPL(F("%ip4%"),WiFi.localIP().toString().substring(WiFi.localIP().toString().lastIndexOf('.')+1))

  SMART_REPL(F("%ip%"),WiFi.localIP().toString())

  SMART_REPL(F("%rssi%"), String((wifiStatus == ESPEASY_WIFI_DISCONNECTED) ? 0 : WiFi.RSSI()))

  SMART_REPL(F("%ssid%"), (wifiStatus == ESPEASY_WIFI_DISCONNECTED) ? F("--") : WiFi.SSID())

  SMART_REPL(F("%bssid%"), (wifiStatus == ESPEASY_WIFI_DISCONNECTED) ? F("00:00:00:00:00:00") : WiFi.BSSIDstr())

  SMART_REPL(F("%wi_ch%"), String((wifiStatus == ESPEASY_WIFI_DISCONNECTED) ? 0 : WiFi.channel()))

  SMART_REPL(F("%unit%"), String(Settings.Unit))

  SMART_REPL(F("%mac%"), String(WiFi.macAddress()))

  #if defined(ESP8266)

    SMART_REPL(F("%mac_int%"), String(ESP.getChipId()))

  #endif



  if (s.indexOf(F("%sys")) != -1) {

    SMART_REPL(F("%sysload%"), String(getCPUload()))

    SMART_REPL(F("%sysheap%"), String(ESP.getFreeHeap()));

    SMART_REPL(F("%systm_hm%"), getTimeString(':', false))

    SMART_REPL(F("%systm_hm_am%"), getTimeString_ampm(':', false))

    SMART_REPL(F("%systime%"), getTimeString(':'))

    SMART_REPL(F("%systime_am%"), getTimeString_ampm(':'))

    repl(F("%sysname%"), Settings.Name, s, useURLencode);





    char valueString[5];

    #define SMART_REPL_TIME(T,F,V) if (s.indexOf(T) != -1) { sprintf_P(valueString, (F), (V)); repl((T),valueString, s, useURLencode);}

    SMART_REPL_TIME(F("%sysyear%"), PSTR("%d"), year())

    SMART_REPL_TIME(F("%sysmonth%"),PSTR("%d"), month())

    SMART_REPL_TIME(F("%sysday%"), PSTR("%d"), day())

    SMART_REPL_TIME(F("%syshour%"), PSTR("%d"), hour())

    SMART_REPL_TIME(F("%sysmin%"), PSTR("%d"), minute())

    SMART_REPL_TIME(F("%syssec%"),PSTR("%d"), second())

    SMART_REPL_TIME(F("%syssec_d%"),PSTR("%d"), ((hour()*60) + minute())*60 + second());

    SMART_REPL(F("%sysweekday%"), String(weekday()))

    SMART_REPL(F("%sysweekday_s%"), weekday_str())





    SMART_REPL_TIME(F("%sysyears%"),PSTR("%02d"), year()%100)

    SMART_REPL_TIME(F("%sysyear_0%"), PSTR("%04d"), year())

    SMART_REPL_TIME(F("%syshour_0%"), PSTR("%02d"), hour())

    SMART_REPL_TIME(F("%sysday_0%"), PSTR("%02d"), day())

    SMART_REPL_TIME(F("%sysmin_0%"), PSTR("%02d"), minute())

    SMART_REPL_TIME(F("%syssec_0%"),PSTR("%02d"), second())

    SMART_REPL_TIME(F("%sysmonth_0%"),PSTR("%02d"), month())



    #undef SMART_REPL_TIME

  }

  SMART_REPL(F("%lcltime%"), getDateTimeString('-',':',' '))

  SMART_REPL(F("%lcltime_am%"), getDateTimeString_ampm('-',':',' '))

  SMART_REPL(F("%uptime%"), String(wdcounter / 2))

  SMART_REPL(F("%unixtime%"), String(getUnixTime()))

  SMART_REPL_T(F("%sunset"), replSunSetTimeString)

  SMART_REPL_T(F("%sunrise"), replSunRiseTimeString)

}



String getReplacementString(const String& format, String& s) {

  int startpos = s.indexOf(format);

  int endpos = s.indexOf('%', startpos + 1);

  String R = s.substring(startpos, endpos + 1);

  String log = F("ReplacementString SunTime: ");

  log += R;

  log += F(" offset: ");

  log += getSecOffset(R);

  addLog(LOG_LEVEL_DEBUG, log);

  return R;

}



void replSunRiseTimeString(const String& format, String& s, boolean useURLencode) {

  String R = getReplacementString(format, s);

  repl(R, getSunriseTimeString(':', getSecOffset(R)), s, useURLencode);

}



void replSunSetTimeString(const String& format, String& s, boolean useURLencode) {

  String R = getReplacementString(format, s);

  repl(R, getSunsetTimeString(':', getSecOffset(R)), s, useURLencode);

}



void parseEventVariables(String& s, struct EventStruct *event, boolean useURLencode)

{



  LoadTaskSettings(event->TaskIndex);

  SMART_REPL(F("%id%"), String(event->idx))

  if (s.indexOf(F("%val")) != -1) {

    if (event->sensorType == SENSOR_TYPE_LONG) {

      SMART_REPL(F("%val1%"), String((unsigned long)UserVar[event->BaseVarIndex] + ((unsigned long)UserVar[event->BaseVarIndex + 1] << 16)))

    } else {

      SMART_REPL(F("%val1%"), formatUserVarNoCheck(event, 0))

      SMART_REPL(F("%val2%"), formatUserVarNoCheck(event, 1))

      SMART_REPL(F("%val3%"), formatUserVarNoCheck(event, 2))

      SMART_REPL(F("%val4%"), formatUserVarNoCheck(event, 3))

    }

  }



  repl(F("%tskname%"), ExtraTaskSettings.TaskDeviceName, s, useURLencode);

  if (s.indexOf(F("%vname")) != -1) {

    repl(F("%vname1%"), ExtraTaskSettings.TaskDeviceValueNames[0], s, useURLencode);

    repl(F("%vname2%"), ExtraTaskSettings.TaskDeviceValueNames[1], s, useURLencode);

    repl(F("%vname3%"), ExtraTaskSettings.TaskDeviceValueNames[2], s, useURLencode);

    repl(F("%vname4%"), ExtraTaskSettings.TaskDeviceValueNames[3], s, useURLencode);

  }



}

#undef SMART_REPL_T

#undef SMART_REPL



bool getConvertArgument(const String& marker, const String& s, float& argument, int& startIndex, int& endIndex) {

  String argumentString;

  if (getConvertArgumentString(marker, s, argumentString, startIndex, endIndex)) {

    if (!isFloat(argumentString)) return false;

    argument = argumentString.toFloat();

    return true;

  }

  return false;

}



bool getConvertArgument2(const String& marker, const String& s, float& arg1, float& arg2, int& startIndex, int& endIndex) {

  String argumentString;

  if (getConvertArgumentString(marker, s, argumentString, startIndex, endIndex)) {

    int pos_comma = argumentString.indexOf(',');

    if (pos_comma == -1) return false;

    String arg1_s = argumentString.substring(0, pos_comma);

    if (!isFloat(arg1_s)) return false;

    String arg2_s = argumentString.substring(pos_comma+1);

    if (!isFloat(arg2_s)) return false;

    arg1 = arg1_s.toFloat();

    arg2 = arg2_s.toFloat();

    return true;

  }

  return false;

}





bool getConvertArgumentString(const String& marker, const String& s, String& argumentString, int& startIndex, int& endIndex) {

  startIndex = s.indexOf(marker);

  if (startIndex == -1) return false;



  int startIndexArgument = startIndex + marker.length();

  if (s.charAt(startIndexArgument) != '(') {

    return false;

  }

  ++startIndexArgument;

  endIndex = s.indexOf(')', startIndexArgument);

  if (endIndex == -1) return false;



  argumentString = s.substring(startIndexArgument, endIndex);

  if (argumentString.length() == 0) return false;

  ++endIndex;

  return true;

}







void parseStandardConversions(String& s, boolean useURLencode) {

  if (s.indexOf(F("%c_")) == -1)

    return;



  float arg1 = 0.0;

  int startIndex = 0;

  int endIndex = 0;







  #define SMART_CONV(T,FUN) while (getConvertArgument((T), s, arg1, startIndex, endIndex)) { repl(s.substring(startIndex, endIndex), (FUN), s, useURLencode); }

  SMART_CONV(F("%c_w_dir%"), getBearing(arg1))

  SMART_CONV(F("%c_c2f%"), toString(CelsiusToFahrenheit(arg1), 2))

  SMART_CONV(F("%c_ms2Bft%"), String(m_secToBeaufort(arg1)))

  SMART_CONV(F("%c_cm2imp%"), centimeterToImperialLength(arg1))

  SMART_CONV(F("%c_mm2imp%"), millimeterToImperialLength(arg1))

  SMART_CONV(F("%c_m2day%"), toString(minutesToDay(arg1), 2))

  SMART_CONV(F("%c_m2dh%"), minutesToDayHour(arg1))

  SMART_CONV(F("%c_m2dhm%"), minutesToDayHourMinute(arg1))

  SMART_CONV(F("%c_s2dhms%"), secondsToDayHourMinuteSecond(arg1))

  #undef SMART_CONV



  #define SMART_CONV(T,FUN) while (getConvertArgument2((T), s, arg1, arg2, startIndex, endIndex)) { repl(s.substring(startIndex, endIndex), (FUN), s, useURLencode); }

  float arg2 = 0.0;

  SMART_CONV(F("%c_dew_th%"), toString(compute_dew_point_temp(arg1, arg2), 2))

  #undef SMART_CONV

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeESPeasy.ino"
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeESPeasy.ino"
#define SECS_PER_MIN (60UL)

#define SECS_PER_HOUR (3600UL)

#define SECS_PER_DAY (SECS_PER_HOUR * 24UL)

#define DAYS_PER_WEEK (7UL)

#define SECS_PER_WEEK (SECS_PER_DAY * DAYS_PER_WEEK)

#define SECS_PER_YEAR (SECS_PER_WEEK * 52UL)

#define SECS_YR_2000 (946684800UL)

#define LEAP_YEAR(Y) ( ((1970+Y)>0) && !((1970+Y)%4) && ( ((1970+Y)%100) || !((1970+Y)%400) ) )



timeStruct tm;

uint32_t syncInterval = 3600;

uint32_t sysTime = 0;

uint32_t prevMillis = 0;

uint32_t nextSyncTime = 0;

timeStruct tsRise, tsSet;

timeStruct sunRise;

timeStruct sunSet;



byte PrevMinutes = 0;



float sunDeclination(int doy) {





 return 0.409526325277017 * sin(0.0169060504029192 * (doy - 80.0856919827619));

}



float diurnalArc(float dec, float lat) {



 float rad = 0.0174532925;

 float height = -50.0 / 60.0 * rad;

 float latRad = lat * rad;

 return 12.0 * acos((sin(height) - sin(latRad) * sin(dec)) / (cos(latRad) * cos(dec))) / 3.1415926536;

}



float equationOfTime(int doy) {





 return -0.170869921174742 * sin(0.0336997028793971 * doy + 0.465419984181394) - 0.129890681040717 * sin(0.0178674832556871 * doy - 0.167936777524864);

}



int dayOfYear(int year, int month, int day) {



 int z = 14 - month;

 z /= 12;

 int y = year + 4800 - z;

 int m = month + 12 * z - 3;

 int j = 153 * m + 2;

 j = j / 5 + day + y * 365 + y / 4 - y / 100 + y / 400 - 32045;

 y = year + 4799;

 int k = y * 365 + y / 4 - y / 100 + y / 400 - 31738;

 return j - k + 1;

}



void calcSunRiseAndSet() {

 int doy = dayOfYear(tm.Year, tm.Month, tm.Day);

 float eqt = equationOfTime(doy);

 float dec = sunDeclination(doy);

 float da = diurnalArc(dec, Settings.Latitude);

 float rise = 12 - da - eqt;

 float set = 12 + da - eqt;

  tsRise.Hour = (int)rise;

  tsRise.Minute = (rise - (int)rise) * 60.0;

  tsSet.Hour = (int)set;

  tsSet.Minute = (set - (int)set) * 60.0;

  tsRise.Day = tsSet.Day = tm.Day;

  tsRise.Month = tsSet.Month = tm.Month;

  tsRise.Year = tsSet.Year = tm.Year;



 int secOffset_longitude = -1.0 * (Settings.Longitude / 15.0) * 3600;

 tsSet = addSeconds(tsSet, secOffset_longitude, false);

 tsRise = addSeconds(tsRise, secOffset_longitude, false);

  breakTime(toLocal(makeTime(tsRise)), sunRise);

  breakTime(toLocal(makeTime(tsSet)), sunSet);

}



timeStruct getSunRise(int secOffset) {

 return addSeconds(tsRise, secOffset, true);

}



timeStruct getSunSet(int secOffset) {

 return addSeconds(tsSet, secOffset, true);

}



timeStruct addSeconds(const timeStruct& ts, int seconds, bool toLocalTime) {

 unsigned long time = makeTime(ts);

 time += seconds;

 if (toLocalTime) {

  time = toLocal(time);

 }

 timeStruct result;

 breakTime(time, result);

 return result;

}



void breakTime(unsigned long timeInput, struct timeStruct &tm) {

  uint8_t year;

  uint8_t month, monthLength;

  uint32_t time;

  unsigned long days;

  const uint8_t monthDays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};



  time = (uint32_t)timeInput;

  tm.Second = time % 60;

  time /= 60;

  tm.Minute = time % 60;

  time /= 60;

  tm.Hour = time % 24;

  time /= 24;

  tm.Wday = ((time + 4) % 7) + 1;



  year = 0;

  days = 0;

  while ((unsigned)(days += (LEAP_YEAR(year) ? 366 : 365)) <= time) {

    year++;

  }

  tm.Year = year;



  days -= LEAP_YEAR(year) ? 366 : 365;

  time -= days;



  days = 0;

  month = 0;

  monthLength = 0;

  for (month = 0; month < 12; month++) {

    if (month == 1) {

      if (LEAP_YEAR(year)) {

        monthLength = 29;

      } else {

        monthLength = 28;

      }

    } else {

      monthLength = monthDays[month];

    }



    if (time >= monthLength) {

      time -= monthLength;

    } else {

      break;

    }

  }

  tm.Month = month + 1;

  tm.Day = time + 1;

}



void setTime(unsigned long t) {

  sysTime = (uint32_t)t;

  applyTimeZone(t);

  nextSyncTime = (uint32_t)t + syncInterval;

  prevMillis = millis();

  if (Settings.UseRules)

  {

    static bool firstUpdate = true;

    String event = firstUpdate ? F("Time#Initialized") : F("Time#Set");

    firstUpdate = false;

    rulesProcessing(event);

  }

}



uint32_t getUnixTime() {

  return sysTime;

}



int getSecOffset(const String& format) {

 int position_minus = format.indexOf('-');

 int position_plus = format.indexOf('+');

 if (position_minus == -1 && position_plus == -1)

   return 0;

 int sign_position = _max(position_minus, position_plus);

 int position_percent = format.indexOf('%', sign_position);

 if (position_percent == -1) {

  return 0;

 }

 String valueStr = getNumerical(format.substring(sign_position, position_percent), true);

 if (!isInt(valueStr)) return 0;

 int value = valueStr.toInt();

 switch (format.charAt(position_percent - 1)) {

  case 'm':

  case 'M':

    return value * 60;

  case 'h':

  case 'H':

   return value * 3600;

 }

 return value;

}



String getSunriseTimeString(char delimiter) {

  return getTimeString(sunRise, delimiter, false, false);

}



String getSunsetTimeString(char delimiter) {

  return getTimeString(sunSet, delimiter, false, false);

}



String getSunriseTimeString(char delimiter, int secOffset) {

 if (secOffset == 0)

  return getSunriseTimeString(delimiter);

  return getTimeString(getSunRise(secOffset), delimiter, false, false);

}



String getSunsetTimeString(char delimiter, int secOffset) {

 if (secOffset == 0)

  return getSunsetTimeString(delimiter);

  return getTimeString(getSunSet(secOffset), delimiter, false, false);

}





unsigned long now() {



  bool timeSynced = false;

  const long msec_passed = timePassedSince(prevMillis);

  const long seconds_passed = msec_passed / 1000;

  sysTime += seconds_passed;

  prevMillis += seconds_passed * 1000;

  if (nextSyncTime <= sysTime) {



    unsigned long t = getNtpTime();

    if (t != 0) {

      timeSynced = true;

      setTime(t);

    }

  }

  uint32_t localSystime = toLocal(sysTime);

  breakTime(localSystime, tm);

  if (timeSynced) {

    calcSunRiseAndSet();

  }

  return (unsigned long)localSystime;

}



int year(unsigned long t) {

  timeStruct tmp;

  breakTime(t, tmp);

  return 1970 + tmp.Year;

}



int weekday(unsigned long t) {

  timeStruct tmp;

  breakTime(t, tmp);

  return tmp.Wday;

}







int year()

{

  return 1970 + tm.Year;

}



byte month()

{

 return tm.Month;

}



byte day()

{

 return tm.Day;

}



byte hour()

{

  return tm.Hour;

}



byte minute()

{

  return tm.Minute;

}



byte second()

{

 return tm.Second;

}





int weekday()

{

  return tm.Wday;

}



String weekday_str()

{

  const int wday(weekday() - 1);

  const String weekDays = F("SunMonTueWedThuFriSat");

  return weekDays.substring(wday * 3, wday * 3 + 3);

}



void initTime()

{

  nextSyncTime = 0;

  now();

}



void checkTime()

{

  now();

  if (tm.Minute != PrevMinutes)

  {

    PluginCall(PLUGIN_CLOCK_IN, 0, dummyString);

    PrevMinutes = tm.Minute;

    if (Settings.UseRules)

    {

      String event;

      event.reserve(21);

      event = F("Clock#Time=");

      event += weekday_str();

      event += ",";

      if (hour() < 10)

        event += "0";

      event += hour();

      event += ":";

      if (minute() < 10)

        event += "0";

      event += minute();

      rulesProcessing(event);

    }

  }

}





unsigned long getNtpTime()

{

  if (!Settings.UseNTP || !WiFiConnected(10)) {

    return 0;

  }

  IPAddress timeServerIP;

  String log = F("NTP  : NTP host ");

  if (Settings.NTPHost[0] != 0) {

    WiFi.hostByName(Settings.NTPHost, timeServerIP);

    log += Settings.NTPHost;



    nextSyncTime = sysTime + 20;

  }

  else {



    String ntpServerName = String(random(0, 3));

    ntpServerName += F(".pool.ntp.org");

    WiFi.hostByName(ntpServerName.c_str(), timeServerIP);

    log += ntpServerName;



    nextSyncTime = sysTime + 5;

  }



  log += F(" (");

  log += timeServerIP.toString();

  log += F(")");



  if (!hostReachable(timeServerIP)) {

    log += F(" unreachable");

    addLog(LOG_LEVEL_INFO, log);

    return 0;

  }



  WiFiUDP udp;

 if (!beginWiFiUDP_randomPort(udp))

   return 0;



  const int NTP_PACKET_SIZE = 48;

  byte packetBuffer[NTP_PACKET_SIZE];



  log += F(" queried");

  addLog(LOG_LEVEL_DEBUG_MORE, log);



  while (udp.parsePacket() > 0) ;



  memset(packetBuffer, 0, NTP_PACKET_SIZE);

  packetBuffer[0] = 0b11100011;

  packetBuffer[1] = 0;

  packetBuffer[2] = 6;

  packetBuffer[3] = 0xEC;

  packetBuffer[12] = 49;

  packetBuffer[13] = 0x4E;

  packetBuffer[14] = 49;

  packetBuffer[15] = 52;

 if (udp.beginPacket(timeServerIP, 123) == 0) {

  udp.stop();

  return 0;

 }

  udp.write(packetBuffer, NTP_PACKET_SIZE);

  udp.endPacket();



  uint32_t beginWait = millis();

  while (!timeOutReached(beginWait + 1000)) {

    int size = udp.parsePacket();

  int remotePort = udp.remotePort();

    if (size >= NTP_PACKET_SIZE && remotePort == 123) {

      udp.read(packetBuffer, NTP_PACKET_SIZE);

      unsigned long secsSince1900;



      secsSince1900 = (unsigned long)packetBuffer[40] << 24;

      secsSince1900 |= (unsigned long)packetBuffer[41] << 16;

      secsSince1900 |= (unsigned long)packetBuffer[42] << 8;

      secsSince1900 |= (unsigned long)packetBuffer[43];

   if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE)) {

       String log = F("NTP  : NTP replied: ");

       log += timePassedSince(beginWait);

       log += F(" mSec");

       addLog(LOG_LEVEL_DEBUG_MORE, log);

   }

   udp.stop();

      return secsSince1900 - 2208988800UL;

    }

    delay(10);

  }

  addLog(LOG_LEVEL_DEBUG_MORE, F("NTP  : No reply"));

 udp.stop();

  return 0;

}
# 847 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeESPeasy.ino"
long timeDiff(const unsigned long prev, const unsigned long next)

{

 unsigned long start = ESP.getCycleCount();

  long signed_diff = 0;



  const unsigned long half_max_unsigned_long = 2147483647u;

  if (next >= prev) {

    const unsigned long diff = next - prev;

    if (diff <= half_max_unsigned_long) {





      signed_diff = static_cast<long>(diff);

    } else {



      signed_diff = static_cast<long>((ULONG_MAX - next) + prev + 1u);

      signed_diff = -1 * signed_diff;

    }

  } else {



    const unsigned long diff = prev - next;

    if (diff <= half_max_unsigned_long) {



      signed_diff = static_cast<long>(diff);

      signed_diff = -1 * signed_diff;

    } else {



      signed_diff = static_cast<long>((ULONG_MAX - prev) + next + 1u);

    }

  }

 unsigned long end = ESP.getCycleCount();

 if (end > start) {

  ++timediff_calls;

  timediff_cpu_cycles_total += (end - start);

 }

  return signed_diff;

}







long timePassedSince(unsigned long timestamp) {

  return timeDiff(timestamp, millis());

}



long usecPassedSince(unsigned long timestamp) {

  return timeDiff(timestamp, micros());

}





boolean timeOutReached(unsigned long timer) {

  const long passed = timePassedSince(timer);

  return passed >= 0;

}



boolean usecTimeOutReached(unsigned long timer) {

  const long passed = usecPassedSince(timer);

  return passed >= 0;

}



void setNextTimeInterval(unsigned long& timer, const unsigned long step) {

  timer += step;

  const long passed = timePassedSince(timer);

  if (passed < 0) {



    return;

  }

  if (static_cast<unsigned long>(passed) > step) {



    timer = millis() + step;

    return;

  }



  timer = millis() + (step - passed);

}
# 1003 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeESPeasy.ino"
String timeLong2String(unsigned long lngTime)

{

  unsigned long x = 0;

  String time = "";



  x = (lngTime >> 16) & 0xf;

  if (x == 0x0f)

    x = 0;

  String weekDays = F("AllSunMonTueWedThuFriSatWrkWkd");

  time = weekDays.substring(x * 3, x * 3 + 3);

  time += ",";



  x = (lngTime >> 12) & 0xf;

  if (x == 0xf)

    time += "*";

  else if (x == 0xe)

    time += "-";

  else

    time += x;



  x = (lngTime >> 8) & 0xf;

  if (x == 0xf)

    time += "*";

  else if (x == 0xe)

    time += "-";

  else

    time += x;



  time += ":";



  x = (lngTime >> 4) & 0xf;

  if (x == 0xf)

    time += "*";

  else if (x == 0xe)

    time += "-";

  else

    time += x;



  x = (lngTime) & 0xf;

  if (x == 0xf)

    time += "*";

  else if (x == 0xe)

    time += "-";

  else

    time += x;



  return time;

}







String getDateString(const timeStruct& ts, char delimiter) {

  char DateString[20];

  const int year = 1970 + ts.Year;

  sprintf_P(DateString, PSTR("%4d%c%02d%c%02d"), year, delimiter, ts.Month, delimiter, ts.Day);

  return DateString;

}



String getDateString(char delimiter)

{

  return getDateString(tm, delimiter);

}







String getDateString()

{

 return getDateString('\0');

}







String getTimeString(const timeStruct& ts, char delimiter, bool am_pm, bool show_seconds)

{

  char TimeString[20];

  if (am_pm) {

    uint8_t hour(ts.Hour % 12);

    if (hour == 0) { hour = 12; }

    const char a_or_p = ts.Hour < 12 ? 'A' : 'P';

    if (show_seconds) {

      sprintf_P(TimeString, PSTR("%d%c%02d%c%02d %cM"),

        hour, delimiter, ts.Minute, delimiter, ts.Second, a_or_p);

    } else {

      sprintf_P(TimeString, PSTR("%d%c%02d %cM"),

        hour, delimiter, ts.Minute, a_or_p);

    }

  } else {

    if (show_seconds) {

      sprintf_P(TimeString, PSTR("%02d%c%02d%c%02d"),

        ts.Hour, delimiter, ts.Minute, delimiter, ts.Second);

    } else {

      sprintf_P(TimeString, PSTR("%d%c%02d"),

        ts.Hour, delimiter, ts.Minute);

    }

  }

  return TimeString;

}



String getTimeString(char delimiter, bool show_seconds )

{

  return getTimeString(tm, delimiter, false, show_seconds);

}



String getTimeString_ampm(char delimiter, bool show_seconds )

{

  return getTimeString(tm, delimiter, true, show_seconds);

}







String getTimeString()

{

 return getTimeString('\0');

}



String getTimeString_ampm()

{

 return getTimeString_ampm('\0');

}
# 1249 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeESPeasy.ino"
String getDateTimeString(const timeStruct& ts, char dateDelimiter, char timeDelimiter, char dateTimeDelimiter, bool am_pm)

{

 String ret = getDateString(ts, dateDelimiter);

 if (dateTimeDelimiter != '\0')

  ret += dateTimeDelimiter;

 ret += getTimeString(ts, timeDelimiter, am_pm, true);

 return ret;

}



String getDateTimeString(char dateDelimiter, char timeDelimiter, char dateTimeDelimiter) {

  return getDateTimeString(tm, dateDelimiter, timeDelimiter, dateTimeDelimiter, false);

}



String getDateTimeString_ampm(char dateDelimiter, char timeDelimiter, char dateTimeDelimiter) {

  return getDateTimeString(tm, dateDelimiter, timeDelimiter, dateTimeDelimiter, true);

}
# 1289 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeESPeasy.ino"
unsigned long string2TimeLong(const String &str)

{







 #define TmpStr1Length 10

  char command[20];

  char TmpStr1[TmpStr1Length];

  int w, x, y;

  unsigned long a;

  {



    String tmpString(str);

    tmpString.toLowerCase();

    tmpString.toCharArray(command, 20);

  }

  unsigned long lngTime = 0;



  if (GetArgv(command, TmpStr1, TmpStr1Length, 1))

  {

    String day = TmpStr1;

    String weekDays = F("allsunmontuewedthufrisatwrkwkd");

    y = weekDays.indexOf(TmpStr1) / 3;

    if (y == 0)

      y = 0xf;

    lngTime |= (unsigned long)y << 16;

  }



  if (GetArgv(command, TmpStr1, TmpStr1Length, 2))

  {

    y = 0;

    for (x = strlen(TmpStr1) - 1; x >= 0; x--)

    {

      w = TmpStr1[x];

      if ( (w >= '0' && w <= '9') || w == '*')

      {

        a = 0xffffffff ^ (0xfUL << y);

        lngTime &= a;

        if (w == '*')

          lngTime |= (0xFUL << y);

        else

          lngTime |= (w - '0') << y;

        y += 4;

      }

      else

        if (w == ':');

      else

      {

        break;

      }

    }

  }

 #undef TmpStr1Length

  return lngTime;

}
# 1407 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeESPeasy.ino"
boolean matchClockEvent(unsigned long clockEvent, unsigned long clockSet)

{

  unsigned long Mask;

  for (byte y = 0; y < 8; y++)

  {

    if (((clockSet >> (y * 4)) & 0xf) == 0xf)

    {

      Mask = 0xffffffff ^ (0xFUL << (y * 4));

      clockEvent &= Mask;

      clockEvent |= (0xFUL << (y * 4));

    }

  }



  if (((clockSet >> (16)) & 0xf) == 0x8)

    if (weekday() >= 2 and weekday() <= 6)

    {

      Mask = 0xffffffff ^ (0xFUL << (16));

      clockEvent &= Mask;

      clockEvent |= (0x8UL << (16));

    }



  if (((clockSet >> (16)) & 0xf) == 0x9)

    if (weekday() == 1 or weekday() == 7)

    {

      Mask = 0xffffffff ^ (0xFUL << (16));

      clockEvent &= Mask;

      clockEvent |= (0x9UL << (16));

    }



  if (clockEvent == clockSet)

    return true;

  return false;

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeZoneESPeasy.ino"
# 15 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeZoneESPeasy.ino"
TimeChangeRule m_dst;

TimeChangeRule m_std;

uint32_t m_dstUTC = 0;

uint32_t m_stdUTC = 0;

uint32_t m_dstLoc = 0;

uint32_t m_stdLoc = 0;
# 119 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeZoneESPeasy.ino"
void getDefaultDst_flash_values(uint16_t& start, uint16_t& end) {





  TimeChangeRule CEST(Last, Sun, Mar, 2, Settings.TimeZone);

  TimeChangeRule CET(Last, Sun, Oct, 3, Settings.TimeZone);

  start = CEST.toFlashStoredValue();

  end = CET.toFlashStoredValue();

}



void applyTimeZone(uint32_t curTime) {

  int dst_offset = Settings.DST ? 60 : 0;

  uint16_t tmpStart(Settings.DST_Start);

  uint16_t tmpEnd(Settings.DST_End);

  for (int i = 0; i < 2; ++i) {

    TimeChangeRule start(tmpStart, Settings.TimeZone + dst_offset);

    TimeChangeRule end(tmpEnd, Settings.TimeZone);

    if (start.isValid() && end.isValid()) {

      setTimeZone(start, end, curTime);

      return;

    }

    getDefaultDst_flash_values(tmpStart, tmpEnd);

  }

}



void setTimeZone(const TimeChangeRule& dstStart, const TimeChangeRule& stdStart, uint32_t curTime) {

  m_dst = dstStart;

  m_std = stdStart;

  if (calcTimeChanges(year(curTime))) {

    logTimeZoneInfo();

  }

}



void logTimeZoneInfo() {

  String log = F("Current Time Zone: ");

  if (m_std.offset != m_dst.offset) {



    log += F(" DST time start: ");

    if (m_dstLoc != 0) {

      timeStruct tmp;

      breakTime(m_dstLoc, tmp);

      log += getDateTimeString(tmp, '-', ':', ' ', false);

    }

    log += F(" offset: ");

    log += m_dst.offset;

    log += F(" min");

  }



  log += F("STD time start: ");

  if (m_stdLoc != 0) {

    timeStruct tmp;

    breakTime(m_stdLoc, tmp);

    log += getDateTimeString(tmp, '-', ':', ' ', false);

  }

  log += F(" offset: ");

  log += m_std.offset;

  log += F(" min");

  addLog(LOG_LEVEL_INFO, log);

}



uint32_t makeTime(const timeStruct &tm) {







  const uint8_t monthDays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

  int i;

  uint32_t seconds;





  seconds= tm.Year*(SECS_PER_DAY * 365);

  for (i = 0; i < tm.Year; i++) {

    if (LEAP_YEAR(i)) {

      seconds += SECS_PER_DAY;

    }

  }





  for (i = 1; i < tm.Month; i++) {

    if ( (i == 2) && LEAP_YEAR(tm.Year)) {

      seconds += SECS_PER_DAY * 29;

    } else {

      seconds += SECS_PER_DAY * monthDays[i-1];

    }

  }

  seconds+= (tm.Day-1) * SECS_PER_DAY;

  seconds+= tm.Hour * SECS_PER_HOUR;

  seconds+= tm.Minute * SECS_PER_MIN;

  seconds+= tm.Second;

  return (uint32_t)seconds;

}
# 309 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeZoneESPeasy.ino"
uint32_t calcTimeChangeForRule(const TimeChangeRule& r, int yr)

{

    uint8_t m = r.month;

    uint8_t w = r.week;

    if (w == 0)

    {

        if (++m > 12)

        {

            m = 1;

            ++yr;

        }

        w = 1;

    }





    timeStruct tm;

    tm.Hour = r.hour;

    tm.Minute = 0;

    tm.Second = 0;

    tm.Day = 1;

    tm.Month = m;

    tm.Year = yr - 1970;

    uint32_t t = makeTime(tm);





    t += ( (r.dow - weekday(t) + 7) % 7 + (w - 1) * 7 ) * SECS_PER_DAY;



    if (r.week == 0) t -= 7 * SECS_PER_DAY;

    return t;

}
# 381 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeZoneESPeasy.ino"
bool calcTimeChanges(int yr)

{

  uint32_t dstLoc = calcTimeChangeForRule(m_dst, yr);

  uint32_t stdLoc = calcTimeChangeForRule(m_std, yr);

  bool changed = (m_dstLoc != dstLoc) || (m_stdLoc != stdLoc);

  m_dstLoc = dstLoc;

  m_stdLoc = stdLoc;

  m_dstUTC = m_dstLoc - m_std.offset * SECS_PER_MIN;

  m_stdUTC = m_stdLoc - m_dst.offset * SECS_PER_MIN;

  return changed;

}
# 413 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeZoneESPeasy.ino"
uint32_t toLocal(uint32_t utc)

{



    if (year(utc) != year(m_dstUTC)) calcTimeChanges(year(utc));



    if (utcIsDST(utc))

        return utc + m_dst.offset * SECS_PER_MIN;

    else

        return utc + m_std.offset * SECS_PER_MIN;

}
# 445 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeZoneESPeasy.ino"
bool utcIsDST(uint32_t utc)

{



    if (year(utc) != year(m_dstUTC)) calcTimeChanges(year(utc));



    if (m_stdUTC == m_dstUTC)

        return false;

    else if (m_stdUTC > m_dstUTC)

        return (utc >= m_dstUTC && utc < m_stdUTC);

    else

        return !(utc >= m_stdUTC && utc < m_dstUTC);

}
# 479 "C:/Users/admin/Documents/GitHub/ESPEasy/src/TimeZoneESPeasy.ino"
bool locIsDST(uint32_t local)

{



    if (year(local) != year(m_dstLoc)) calcTimeChanges(year(local));



    if (m_stdUTC == m_dstUTC)

        return false;

    else if (m_stdLoc > m_dstLoc)

        return (local >= m_dstLoc && local < m_stdLoc);

    else

        return !(local >= m_stdLoc && local < m_dstLoc);

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"






#define ALL_ALLOWED 0

#define LOCAL_SUBNET_ALLOWED 1

#define ONLY_IP_RANGE_ALLOWED 2

#define _HEAD false

#define _TAIL true

#define CHUNKED_BUFFER_SIZE 400



void sendContentBlocking(String& data);

void sendHeaderBlocking(bool json);



class StreamingBuffer {

private:

  bool lowMemorySkip;



public:

  uint32_t initialRam;

  uint32_t beforeTXRam;

  uint32_t duringTXRam;

  uint32_t finalRam;

  uint32_t maxCoreUsage;

  uint32_t maxServerUsage;

  unsigned int sentBytes;

  uint32_t flashStringCalls;

  uint32_t flashStringData;

  String buf;



  StreamingBuffer(void) : lowMemorySkip(false),

    initialRam(0), beforeTXRam(0), duringTXRam(0), finalRam(0), maxCoreUsage(0),

    maxServerUsage(0), sentBytes(0), flashStringCalls(0), flashStringData(0)

  {

    buf.reserve(CHUNKED_BUFFER_SIZE + 50);

    buf = "";

  }

  StreamingBuffer operator= (String& a) { flush(); return addString(a); }

  StreamingBuffer operator= (const String& a) { flush(); return addString(a); }

  StreamingBuffer operator+= (char a) { return addString(String(a)); }

  StreamingBuffer operator+= (long unsigned int a) { return addString(String(a)); }

  StreamingBuffer operator+= (float a) { return addString(String(a)); }

  StreamingBuffer operator+= (int a) { return addString(String(a)); }

  StreamingBuffer operator+= (uint32_t a) { return addString(String(a)); }

  StreamingBuffer operator+= (const String& a) { return addString(a); }



  StreamingBuffer operator+= (PGM_P str) {

    ++flashStringCalls;

    if (!str) return *this;

    if (lowMemorySkip) return *this;

    int flush_step = CHUNKED_BUFFER_SIZE - this->buf.length();

    if (flush_step < 1) flush_step = 0;

    unsigned int pos = 0;

    const unsigned int length = strlen_P((PGM_P)str);

    if (length == 0) return *this;

    flashStringData += length;

    while (pos < length) {

      if (flush_step == 0) {

        sendContentBlocking(this->buf);

        flush_step = CHUNKED_BUFFER_SIZE;

      }

      this->buf += (char)pgm_read_byte(&str[pos]);

      ++pos;

      --flush_step;

    }

    checkFull();

    return *this;

  }





  StreamingBuffer addString(const String& a) {

    if (lowMemorySkip) return *this;

    int flush_step = CHUNKED_BUFFER_SIZE - this->buf.length();

    if (flush_step < 1) flush_step = 0;

    int pos = 0;

    const int length = a.length();

    while (pos < length) {

      if (flush_step == 0) {

        sendContentBlocking(this->buf);

        flush_step = CHUNKED_BUFFER_SIZE;

      }

      this->buf += a[pos];

      ++pos;

      --flush_step;

    }

    checkFull();

    return *this;

  }



  void flush() {

    if (lowMemorySkip) {

      this->buf = "";

    } else {

      sendContentBlocking(this->buf);

    }

  }



  void checkFull(void) {

    if (lowMemorySkip) this->buf = "";

    if (this->buf.length() > CHUNKED_BUFFER_SIZE) {

      trackTotalMem();

      sendContentBlocking(this->buf);

    }

  }



  void startStream() {

    startStream(false);

  }



  void startJsonStream() {

    startStream(true);

  }



private:

  void startStream(bool json) {

    maxCoreUsage = maxServerUsage = 0;

    initialRam = ESP.getFreeHeap();

    beforeTXRam = initialRam;

    sentBytes = 0;

    buf = "";

    if (beforeTXRam < 3000) {

      lowMemorySkip = true;

      WebServer.send(200, "text/plain", "Low memory. Cannot display webpage :-(");

       #if defined(ESP8266)

         tcpCleanup();

       #endif

      return;

    } else

      sendHeaderBlocking(json);

  }



  void trackTotalMem() {

    beforeTXRam = ESP.getFreeHeap();

    if ((initialRam - beforeTXRam) > maxServerUsage)

      maxServerUsage = initialRam - beforeTXRam;

  }



public:



  void trackCoreMem() {

    duringTXRam = ESP.getFreeHeap();

    if ((initialRam - duringTXRam) > maxCoreUsage)

      maxCoreUsage = (initialRam - duringTXRam);

  }



  void endStream(void) {

    if (!lowMemorySkip) {

      if (buf.length() > 0) sendContentBlocking(buf);

      buf = "";

      sendContentBlocking(buf);

      finalRam = ESP.getFreeHeap();
# 319 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
    } else {

      addLog(LOG_LEVEL_DEBUG, String("Webpage skipped: low memory: ") + finalRam);

      lowMemorySkip = false;

    }

  }

} TXBuffer;



void sendContentBlocking(String& data) {

  checkRAM(F("sendContentBlocking"));

  uint32_t freeBeforeSend = ESP.getFreeHeap();

  const uint32_t length = data.length();

  addLog(LOG_LEVEL_DEBUG_DEV, String("sendcontent free: ") + freeBeforeSend + " chunk size:" + length);

  freeBeforeSend = ESP.getFreeHeap();

  if (TXBuffer.beforeTXRam > freeBeforeSend)

    TXBuffer.beforeTXRam = freeBeforeSend;

  TXBuffer.duringTXRam = freeBeforeSend;

#if defined(ESP8266) && defined(ARDUINO_ESP8266_RELEASE_2_3_0)

  String size = formatToHex(length) + "\r\n";



  WebServer.sendContent(size);

  if (length > 0) WebServer.sendContent(data);

  WebServer.sendContent("\r\n");

#else

  unsigned int timeout = 0;

  if (freeBeforeSend < 5000) timeout = 100;

  if (freeBeforeSend < 4000) timeout = 1000;

  const uint32_t beginWait = millis();

  WebServer.sendContent(data);

  while ((ESP.getFreeHeap() < freeBeforeSend) &&

         !timeOutReached(beginWait + timeout)) {

    if (ESP.getFreeHeap() < TXBuffer.duringTXRam)

      TXBuffer.duringTXRam = ESP.getFreeHeap();

    ;

    TXBuffer.trackCoreMem();

    checkRAM(F("duringDataTX"));

    delay(1);

  }

#endif



  TXBuffer.sentBytes += length;

  data = "";

  yield();

}



void sendHeaderBlocking(bool json) {

  checkRAM(F("sendHeaderBlocking"));

  WebServer.client().flush();

#if defined(ESP8266) && defined(ARDUINO_ESP8266_RELEASE_2_3_0)

  WebServer.setContentLength(CONTENT_LENGTH_UNKNOWN);

  WebServer.sendHeader(F("Content-Type"), json ? F("application/json") : F("text/html"), true);

  WebServer.sendHeader(F("Accept-Ranges"), F("none"));

  WebServer.sendHeader(F("Cache-Control"), F("no-cache"));

  WebServer.sendHeader(F("Transfer-Encoding"), F("chunked"));

  if (json)

    WebServer.sendHeader(F("Access-Control-Allow-Origin"),"*");

  WebServer.send(200);

#else

  unsigned int timeout = 0;

  uint32_t freeBeforeSend = ESP.getFreeHeap();

  if (freeBeforeSend < 5000) timeout = 100;

  if (freeBeforeSend < 4000) timeout = 1000;

  const uint32_t beginWait = millis();

  WebServer.setContentLength(CONTENT_LENGTH_UNKNOWN);

  WebServer.sendHeader(F("Content-Type"), json ? F("application/json") : F("text/html"), true);

  WebServer.sendHeader(F("Cache-Control"), F("no-cache"));

  if (json)

    WebServer.sendHeader(F("Access-Control-Allow-Origin"),"*");

  WebServer.send(200);



  while ((ESP.getFreeHeap() < freeBeforeSend) &&

         !timeOutReached(beginWait + timeout)) {

    checkRAM(F("duringHeaderTX"));

    delay(1);

  }

#endif

  yield();

}



void sendHeadandTail(const String& tmplName, boolean Tail = false) {

  String pageTemplate = "";

  int indexStart, indexEnd;

  String varName;

  String fileName = tmplName;

  fileName += F(".htm");

  fs::File f = SPIFFS.open(fileName, "r+");



  if (f) {

    pageTemplate.reserve(f.size());

    while (f.available()) pageTemplate += (char)f.read();

    f.close();

  } else {

    getWebPageTemplateDefault(tmplName, pageTemplate);

  }

  checkRAM(F("sendWebPage"));



  lastWeb = millis();



  if (Tail) {

    TXBuffer += pageTemplate.substring(

        11 +

        pageTemplate.indexOf(F("{{content}}")));

  } else {

    while ((indexStart = pageTemplate.indexOf(F("{{"))) >= 0) {

      TXBuffer += pageTemplate.substring(0, indexStart);

      pageTemplate = pageTemplate.substring(indexStart);

      if ((indexEnd = pageTemplate.indexOf(F("}}"))) > 0) {

        varName = pageTemplate.substring(2, indexEnd);

        pageTemplate = pageTemplate.substring(indexEnd + 2);

        varName.toLowerCase();



        if (varName == F("content")) {

          break;

        } else if (varName == F("error")) {

          getErrorNotifications();

        } else {

          getWebPageTemplateVar(varName);

        }

      } else {

        pageTemplate = pageTemplate.substring(2);

      }

    }

  }

  if (shouldReboot) {



    TXBuffer += jsReboot;

  }

}







boolean ipLessEqual(const IPAddress& ip, const IPAddress& high)

{

  for (byte i = 0; i < 4; ++i) {

    if (ip[i] > high[i]) return false;

  }

  return true;

}



boolean ipInRange(const IPAddress& ip, const IPAddress& low, const IPAddress& high)

{

  return (ipLessEqual(low, ip) && ipLessEqual(ip, high));

}



String describeAllowedIPrange() {

  String reply;

  switch (SecuritySettings.IPblockLevel) {

    case ALL_ALLOWED:

     reply += F("All Allowed");

      break;

    default:

    {

      IPAddress low, high;

      getIPallowedRange(low, high);

      reply += formatIP(low);

      reply += F(" - ");

      reply += formatIP(high);

    }

  }

  return reply;

}



bool getIPallowedRange(IPAddress& low, IPAddress& high)

{

  switch (SecuritySettings.IPblockLevel) {

    case LOCAL_SUBNET_ALLOWED:

      return getSubnetRange(low, high);

    case ONLY_IP_RANGE_ALLOWED:

      low = SecuritySettings.AllowedIPrangeLow;

      high = SecuritySettings.AllowedIPrangeHigh;

      break;

    default:

      low = IPAddress(0,0,0,0);

      high = IPAddress(255,255,255,255);

      return false;

  }

  return true;

}



boolean clientIPallowed()

{



  IPAddress low, high;

  if (!getIPallowedRange(low, high))

  {



    return true;

  }

  WiFiClient client(WebServer.client());

  if (ipInRange(client.remoteIP(), low, high))

    return true;



  if (WifiIsAP(WiFi.getMode())) {



    return true;

  }

  String response = F("IP blocked: ");

  response += formatIP(client.remoteIP());

  WebServer.send(403, "text/html", response);

  if (loglevelActiveFor(LOG_LEVEL_ERROR)) {

    response += F(" Allowed: ");

    response += formatIP(low);

    response += F(" - ");

    response += formatIP(high);

    addLog(LOG_LEVEL_ERROR, response);

  }

  return false;

}



void clearAccessBlock()

{

  SecuritySettings.IPblockLevel = ALL_ALLOWED;

}
# 753 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
#define HTML_SYMBOL_WARNING "&#9888;"



#if defined(ESP8266)

  #define TASKS_PER_PAGE 12

#endif

#if defined(ESP32)

  #define TASKS_PER_PAGE 32

#endif



int getFormItemInt(const String &key, int defaultValue) {

  int value = defaultValue;

  getCheckWebserverArg_int(key, value);

  return value;

}



bool getCheckWebserverArg_int(const String &key, int& value) {

  String valueStr = WebServer.arg(key);

  if (!isInt(valueStr)) return false;

  value = valueStr.toInt();

  return true;

}



#define update_whenset_FormItemInt(K,V) { int tmpVal; if (getCheckWebserverArg_int(K, tmpVal)) V=tmpVal;}





bool isFormItemChecked(const String& id)

{

  return WebServer.arg(id) == F("on");

}



int getFormItemInt(const String& id)

{

  return getFormItemInt(id, 0);

}



float getFormItemFloat(const String& id)

{

  String val = WebServer.arg(id);

  if (!isFloat(val)) return 0.0;

  return val.toFloat();

}



bool isFormItem(const String& id)

{

  return (WebServer.arg(id).length() != 0);

}
# 853 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addHtmlError(String error){

  if (error.length()>0)

  {

    TXBuffer += F("<div class=\"");

    if (error.startsWith(F("Warn"))) {

      TXBuffer += F("warning");

    } else {

      TXBuffer += F("alert");

    }

    TXBuffer += F("\"><span class=\"closebtn\" onclick=\"this.parentElement.style.display='none';\">&times;</span>");

    TXBuffer += error;

    TXBuffer += F("</div>");

  }

  else

  {

    TXBuffer += jsToastMessageBegin;



    TXBuffer += F("Submitted");

    TXBuffer += jsToastMessageEnd;

  }

}



void addHtml(const String html) {

  TXBuffer += html;

}



void WebServerInit()

{



  WebServer.on(F("/"), handle_root);

  WebServer.on(F("/config"), handle_config);

  WebServer.on(F("/controllers"), handle_controllers);

  WebServer.on(F("/hardware"), handle_hardware);

  WebServer.on(F("/devices"), handle_devices);

  WebServer.on(F("/notifications"), handle_notifications);

  WebServer.on(F("/log"), handle_log);

  WebServer.on(F("/logjson"), handle_log_JSON);

  WebServer.on(F("/tools"), handle_tools);

  WebServer.on(F("/i2cscanner"), handle_i2cscanner);

  WebServer.on(F("/wifiscanner"), handle_wifiscanner);

  WebServer.on(F("/login"), handle_login);

  WebServer.on(F("/control"), handle_control);

  WebServer.on(F("/download"), handle_download);

  WebServer.on(F("/upload"), HTTP_GET, handle_upload);

  WebServer.on(F("/upload"), HTTP_POST, handle_upload_post, handleFileUpload);

  WebServer.onNotFound(handleNotFound);

  WebServer.on(F("/filelist"), handle_filelist);

#ifdef FEATURE_SD

  WebServer.on(F("/SDfilelist"), handle_SDfilelist);

#endif

  WebServer.on(F("/advanced"), handle_advanced);

  WebServer.on(F("/setup"), handle_setup);

  WebServer.on(F("/json"), handle_json);

  WebServer.on(F("/rules"), handle_rules);

  WebServer.on(F("/sysinfo"), handle_sysinfo);

  WebServer.on(F("/pinstates"), handle_pinstates);

  WebServer.on(F("/sysvars"), handle_sysvars);

  WebServer.on(F("/favicon.ico"), handle_favicon);



  #if defined(ESP8266)

    if (getFlashRealSizeInBytes() > 524288)

      httpUpdater.setup(&WebServer);

  #endif



  #if defined(ESP8266)

  if (Settings.UseSSDP)

  {

    WebServer.on(F("/ssdp.xml"), HTTP_GET, []() {

      WiFiClient client(WebServer.client());

      SSDP_schema(client);

    });

    SSDP_begin();

  }

  #endif

}



void setWebserverRunning(bool state) {

  if (webserver_state == state)

    return;

  if (state) {

    if (!webserver_init) {

      WebServerInit();

      webserver_init = true;

    }

    WebServer.begin();

    addLog(LOG_LEVEL_INFO, F("Webserver: start"));

  } else {

    WebServer.stop();

    addLog(LOG_LEVEL_INFO, F("Webserver: stop"));

  }

  webserver_state = state;

}





void getWebPageTemplateDefault(const String& tmplName, String& tmpl)

{

  if (tmplName == F("TmplAP"))

  {

    tmpl += F(

              "<!DOCTYPE html><html lang='en'>"

              "<head>"

              "<meta charset='utf-8'/>"

              "<meta name='viewport' content='width=device-width, initial-scale=1.0'>"

              "<title>{{name}}</title>"

              "{{css}}"

              "</head>"

              "<body>"

              "<header class='apheader'>"

              "<h1>Welcome to ESP Easy Mega AP</h1>"

              "</header>"

              "<section>"

              "<span class='message error'>"

              "{{error}}"

              "</span>"

              "{{content}}"

              "</section>"

              "<footer>"

                "<br>"

                "<h6>Powered by <a href='http://www.letscontrolit.com' style='font-size: 15px; text-decoration: none'>www.letscontrolit.com</a></h6>"

              "</footer>"

              "</body>" );

  }

  else if (tmplName == F("TmplMsg"))

  {

    tmpl += F(

              "<!DOCTYPE html><html lang='en'>"

              "<head>"

              "<meta charset='utf-8'/>"

              "<meta name='viewport' content='width=device-width, initial-scale=1.0'>"

              "<title>{{name}}</title>"

              "{{css}}"

              "</head>"

              "<body>"

              "<header class='headermenu'>"

              "<h1>ESP Easy Mega: {{name}}</h1><BR>"

              "</header>"

              "<section>"

              "<span class='message error'>"

              "{{error}}"

              "</span>"

              "{{content}}"

              "</section>"

              "<footer>"

                "<br>"

                "<h6>Powered by <a href='http://www.letscontrolit.com' style='font-size: 15px; text-decoration: none'>www.letscontrolit.com</a></h6>"

              "</footer>"

              "</body>"

            );

  }

  else if (tmplName == F("TmplDsh"))

  {

    tmpl += F(

      "<!DOCTYPE html><html lang='en'>"

      "<head>"

        "<meta charset='utf-8'/>"

        "<title>{{name}}</title>"

        "<meta name='viewport' content='width=device-width, initial-scale=1.0'>"

        "{{js}}"

        "{{css}}"

        "</head>"

        "<body>"

        "{{content}}"

        "</body></html>"

            );

  }

  else

  {

    tmpl += F(

      "<!DOCTYPE html><html lang='en'>"

      "<head>"

        "<meta charset='utf-8'/>"

        "<title>{{name}}</title>"

        "<meta name='viewport' content='width=device-width, initial-scale=1.0'>"

        "{{js}}"

        "{{css}}"

      "</head>"

      "<body class='bodymenu'>"

        "<span class='message' id='rbtmsg'></span>"

        "<header class='headermenu'>"

          "<h1>ESP Easy Mega: {{name}} {{logo}}</h1><BR>"

          "{{menu}}"

        "</header>"

        "<section>"

        "<span class='message error'>"

        "{{error}}"

        "</span>"

        "{{content}}"

        "</section>"

        "<footer>"

          "<br>"

          "<h6>Powered by <a href='http://www.letscontrolit.com' style='font-size: 15px; text-decoration: none'>www.letscontrolit.com</a></h6>"

        "</footer>"

      "</body></html>"

            );

  }

}





void getErrorNotifications() {



  int nrMQTTenabled = 0;

  for (byte x = 0; x < CONTROLLER_MAX; x++) {

    if (Settings.Protocol[x] != 0) {

      byte ProtocolIndex = getProtocolIndex(Settings.Protocol[x]);

      if (Settings.ControllerEnabled[x] && Protocol[ProtocolIndex].usesMQTT) {

        ++nrMQTTenabled;

      }

    }

  }

  if (nrMQTTenabled > 1) {



    addHtmlError(F("Only one MQTT controller should be active."));

  }



}





static byte navMenuIndex = 0;



void getWebPageTemplateVar(const String& varName )

{







  if (varName == F("name"))

  {

    TXBuffer += Settings.Name;

  }



  else if (varName == F("unit"))

  {

    TXBuffer += String(Settings.Unit);

  }



  else if (varName == F("menu"))

  {

    static const __FlashStringHelper* gpMenu[8][3] = {





      F("&#8962;"), F("Main"), F("."),

      F("&#9881;"), F("Config"), F("config"),

      F("&#128172;"), F("Controllers"), F("controllers"),

      F("&#128204;"), F("Hardware"), F("hardware"),

      F("&#128268;"), F("Devices"), F("devices"),

      F("&#10740;"), F("Rules"), F("rules"),

      F("&#9993;"), F("Notifications"), F("notifications"),

      F("&#128295;"), F("Tools"), F("tools"),

    };



    TXBuffer += F("<div class='menubar'>");



    for (byte i = 0; i < 8; i++)

    {

      if (i == 5 && !Settings.UseRules)

        continue;



      TXBuffer += F("<a class='menu");

      if (i == navMenuIndex)

        TXBuffer += F(" active");

      TXBuffer += F("' href='");

      TXBuffer += gpMenu[i][2];

      TXBuffer += F("'>");

      TXBuffer += gpMenu[i][0];

      TXBuffer += F("<span class='showmenulabel'>");

      TXBuffer += gpMenu[i][1];

      TXBuffer += F("</span>");

      TXBuffer += F("</a>");

    }



    TXBuffer += F("</div>");

  }



  else if (varName == F("logo"))

  {

    if (SPIFFS.exists(F("esp.png")))

    {

      TXBuffer = F("<img src=\"esp.png\" width=48 height=48 align=right>");

    }

  }



  else if (varName == F("css"))

  {

    if (SPIFFS.exists(F("esp.css")))



    {

      TXBuffer = F("<link rel=\"stylesheet\" type=\"text/css\" href=\"esp.css\">");

    }

   else

    {

      TXBuffer += F("<style>");



      TXBuffer += pgDefaultCSS;

      TXBuffer += F("</style>");

    }

  }





  else if (varName == F("js"))

  {

    TXBuffer += F(

                  "<script><!--\n"

                  "function dept_onchange(frmselect) {frmselect.submit();}"

                  "\n//--></script>");

  }



  else if (varName == F("error"))

  {



  }



  else if (varName == F("debug"))

  {



  }



  else

  {

    if (loglevelActiveFor(LOG_LEVEL_ERROR)) {

      String log = F("Templ: Unknown Var : ");

      log += varName;

      addLog(LOG_LEVEL_ERROR, log);

    }



  }



 }





void writeDefaultCSS(void)

{

  return;



  if (!SPIFFS.exists(F("esp.css")))

  {

    String defaultCSS;



    fs::File f = SPIFFS.open(F("esp.css"), "w");

    if (f)

    {

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {

        String log = F("CSS  : Writing default CSS file to SPIFFS (");

        log += defaultCSS.length();

        log += F(" bytes)");

        addLog(LOG_LEVEL_INFO, log);

      }

      defaultCSS= PGMT(pgDefaultCSS);

      f.write((const unsigned char*)defaultCSS.c_str(), defaultCSS.length());

      f.close();

    }



  }

}
# 1567 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addHeader(boolean showMenu, String& str)

{



}
# 1585 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addFooter(String& str)

{



}
# 1603 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_root() {

  checkRAM(F("handle_root"));



  if (wifiSetup)

  {

    WebServer.send(200, "text/html", F("<meta HTTP-EQUIV='REFRESH' content='0; url=/setup'>"));

    return;

  }

   if (!isLoggedIn()) return;

   navMenuIndex = 0;

   TXBuffer.startStream();

   sendHeadandTail(F("TmplStd"),_HEAD);



  int freeMem = ESP.getFreeHeap();

  String sCommand = WebServer.arg(F("cmd"));



  if ((strcasecmp_P(sCommand.c_str(), PSTR("wifidisconnect")) != 0) && (strcasecmp_P(sCommand.c_str(), PSTR("reboot")) != 0)&& (strcasecmp_P(sCommand.c_str(), PSTR("reset")) != 0))

  {

    if (timerAPoff)

      timerAPoff = millis() + 2000L;







    printToWeb = true;

    printWebString = "";

    if (sCommand.length() > 0) {

      ExecuteCommand(VALUE_SOURCE_HTTP, sCommand.c_str());

    }



    IPAddress ip = WiFi.localIP();





    TXBuffer += printWebString;

    TXBuffer += F("<form>");

    TXBuffer += F("<table class='normal'><TH style='width:150px;' align='left'>System Info<TH align='left'>Value");



    html_TR_TD(); TXBuffer += F("Unit:<TD>");

    TXBuffer += String(Settings.Unit);



    html_TR_TD(); TXBuffer += F("GIT version:<TD>");

    TXBuffer += BUILD_GIT;



    html_TR_TD(); TXBuffer += F("Local Time:<TD>");

    if (Settings.UseNTP)

    {

      TXBuffer += getDateTimeString('-', ':', ' ');

    }

    else

      TXBuffer += F("<font color='red'>NTP disabled</font>");



    html_TR_TD(); TXBuffer += F("Uptime:<TD>");

    char strUpTime[40];

    int minutes = wdcounter / 2;

    int days = minutes / 1440;

    minutes = minutes % 1440;

    int hrs = minutes / 60;

    minutes = minutes % 60;

    sprintf_P(strUpTime, PSTR("%d days %d hours %d minutes"), days, hrs, minutes);

    TXBuffer += strUpTime;



    html_TR_TD(); TXBuffer += F("Load:<TD>");

    if (wdcounter > 0)

    {

      TXBuffer += String(getCPUload());

      TXBuffer += F("% (LC=");

      TXBuffer += String(getLoopCountPerSec());

      TXBuffer += F(")");

    }



    html_TR_TD(); TXBuffer += F("Free Mem:<TD>");

    TXBuffer += String(freeMem);

    TXBuffer += F(" (");

    TXBuffer += String(lowestRAM);

    TXBuffer += F(" - ");

    TXBuffer += String(lowestRAMfunction);

    TXBuffer += F(")");



    html_TR_TD(); TXBuffer += F("IP:<TD>");

    TXBuffer += formatIP(ip);



    html_TR_TD(); TXBuffer += F("Wifi RSSI:<TD>");

    if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED)

    {

      TXBuffer += String(WiFi.RSSI());

      TXBuffer += F(" dB");

    }



    #ifdef FEATURE_MDNS

      html_TR_TD();

      TXBuffer += F("mDNS:<TD><a href='http://");

      TXBuffer += WifiGetHostname();

      TXBuffer += F(".local'>");

      TXBuffer += WifiGetHostname();

      TXBuffer += F(".local</a>");

      html_TD(3);

    #endif

    html_TR_TD();

    html_TD();

    addButton(F("sysinfo"), F("More info"));



    TXBuffer += F("</table><BR><BR><table class='multirow'><TR><TH>Node List:<TH>Name<TH>Build<TH>Type<TH>IP<TH>Age");

    for (NodesMap::iterator it = Nodes.begin(); it != Nodes.end(); ++it)

    {

      if (it->second.ip[0] != 0)

      {

        char url[80];

        sprintf_P(url, PSTR("<a class='button link' href='http://%u.%u.%u.%u'>%u.%u.%u.%u</a>"), it->second.ip[0], it->second.ip[1], it->second.ip[2], it->second.ip[3], it->second.ip[0], it->second.ip[1], it->second.ip[2], it->second.ip[3]);

        bool isThisUnit = it->first == Settings.Unit;

        if (isThisUnit)

          html_TR_TD_highlight();

        else

          html_TR_TD();



        TXBuffer += F("Unit ");

        TXBuffer += String(it->first);

        html_TD();

        if (isThisUnit)

          TXBuffer += Settings.Name;

        else

          TXBuffer += it->second.nodeName;

        html_TD();

        if (it->second.build)

          TXBuffer += String(it->second.build);

        html_TD();

        if (it->second.nodeType)

          switch (it->second.nodeType)

          {

            case NODE_TYPE_ID_ESP_EASY_STD:

              TXBuffer += F("ESP Easy");

              break;

            case NODE_TYPE_ID_ESP_EASYM_STD:

              TXBuffer += F("ESP Easy Mega");

              break;

            case NODE_TYPE_ID_ESP_EASY32_STD:

              TXBuffer += F("ESP Easy 32");

              break;

            case NODE_TYPE_ID_ARDUINO_EASY_STD:

              TXBuffer += F("Arduino Easy");

              break;

            case NODE_TYPE_ID_NANO_EASY_STD:

              TXBuffer += F("Nano Easy");

              break;

          }

        html_TD();

        TXBuffer += url;

        html_TD();

        TXBuffer += String( it->second.age);

      }

    }



    TXBuffer += F("</table></form>");



    printWebString = "";

    printToWeb = false;

    sendHeadandTail(F("TmplStd"),_TAIL);

    TXBuffer.endStream();



  }

  else

  {
# 1933 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
    if (strcasecmp_P(sCommand.c_str(), PSTR("wifidisconnect")) == 0)

    {

      addLog(LOG_LEVEL_INFO, F("WIFI : Disconnecting..."));

      cmd_within_mainloop = CMD_WIFI_DISCONNECT;

    }



    if (strcasecmp_P(sCommand.c_str(), PSTR("reboot")) == 0)

    {

      addLog(LOG_LEVEL_INFO, F("     : Rebooting..."));

      cmd_within_mainloop = CMD_REBOOT;

    }

   if (strcasecmp_P(sCommand.c_str(), PSTR("reset")) == 0)

    {

      addLog(LOG_LEVEL_INFO, F("     : factory reset..."));

      cmd_within_mainloop = CMD_REBOOT;

      TXBuffer+= F("OK. Please wait > 1 min and connect to Acces point.<BR><BR>PW=configesp<BR>URL=<a href='http://192.168.4.1'>192.168.4.1</a>");

      TXBuffer.endStream();

      ExecuteCommand(VALUE_SOURCE_HTTP, sCommand.c_str());

    }



    TXBuffer+= "OK";

    TXBuffer.endStream();



  }

}
# 1993 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_config() {



   checkRAM(F("handle_config"));

   if (!isLoggedIn()) return;



   navMenuIndex = 1;

   TXBuffer.startStream();

   sendHeadandTail(F("TmplStd"),_HEAD);



  if (timerAPoff)

    timerAPoff = millis() + 2000L;





  String name = WebServer.arg(F("name"));



  String ssid = WebServer.arg(F("ssid"));



  String ssid2 = WebServer.arg(F("ssid2"));



  String iprangelow = WebServer.arg(F("iprangelow"));

  String iprangehigh = WebServer.arg(F("iprangehigh"));



  Settings.Delay = getFormItemInt(F("delay"), Settings.Delay);

  Settings.deepSleep = getFormItemInt(F("deepsleep"), Settings.deepSleep);

  String espip = WebServer.arg(F("espip"));

  String espgateway = WebServer.arg(F("espgateway"));

  String espsubnet = WebServer.arg(F("espsubnet"));

  String espdns = WebServer.arg(F("espdns"));

  Settings.Unit = getFormItemInt(F("unit"), Settings.Unit);







  if (ssid[0] != 0)

  {

    if (strcmp(Settings.Name, name.c_str()) != 0) {

      addLog(LOG_LEVEL_INFO, F("Unit Name changed."));

      MQTTclient_should_reconnect = true;

    }

    strncpy(Settings.Name, name.c_str(), sizeof(Settings.Name));

    Settings.appendUnitToHostname(isFormItemChecked(F("appendunittohostname")));



    copyFormPassword(F("password"), SecuritySettings.Password, sizeof(SecuritySettings.Password));

    strncpy(SecuritySettings.WifiSSID, ssid.c_str(), sizeof(SecuritySettings.WifiSSID));



    copyFormPassword(F("key"), SecuritySettings.WifiKey, sizeof(SecuritySettings.WifiKey));

    strncpy(SecuritySettings.WifiSSID2, ssid2.c_str(), sizeof(SecuritySettings.WifiSSID2));



    copyFormPassword(F("key2"), SecuritySettings.WifiKey2, sizeof(SecuritySettings.WifiKey2));



    copyFormPassword(F("apkey"), SecuritySettings.WifiAPKey, sizeof(SecuritySettings.WifiAPKey));







    SecuritySettings.IPblockLevel = getFormItemInt(F("ipblocklevel"));

    switch (SecuritySettings.IPblockLevel) {

      case LOCAL_SUBNET_ALLOWED:

      {

        IPAddress low, high;

        getSubnetRange(low, high);

        for (byte i=0; i < 4; ++i) {

          SecuritySettings.AllowedIPrangeLow[i] = low[i];

          SecuritySettings.AllowedIPrangeHigh[i] = high[i];

        }

        break;

      }

      case ONLY_IP_RANGE_ALLOWED:

      case ALL_ALLOWED:



        str2ip(iprangelow, SecuritySettings.AllowedIPrangeLow);



        str2ip(iprangehigh, SecuritySettings.AllowedIPrangeHigh);

        break;

    }



    Settings.deepSleepOnFail = isFormItemChecked(F("deepsleeponfail"));

    str2ip(espip, Settings.IP);

    str2ip(espgateway, Settings.Gateway);

    str2ip(espsubnet, Settings.Subnet);

    str2ip(espdns, Settings.DNS);

    addHtmlError(SaveSettings());

  }



  TXBuffer += F("<form name='frmselect' method='post'><table class='normal'>");



  addFormHeader(F("Main Settings"));



  Settings.Name[25] = 0;

  SecuritySettings.Password[25] = 0;

  addFormTextBox( F("Unit Name"), F("name"), Settings.Name, 25);

  addFormNumericBox( F("Unit Number"), F("unit"), Settings.Unit, 0, UNIT_NUMBER_MAX);

  addFormCheckBox(F("Append Unit Number to hostname"), F("appendunittohostname"), Settings.appendUnitToHostname());

  addFormPasswordBox(F("Admin Password"), F("password"), SecuritySettings.Password, 25);



  addFormSubHeader(F("Wifi Settings"));



  addFormTextBox( F("SSID"), F("ssid"), SecuritySettings.WifiSSID, 31);

  addFormPasswordBox(F("WPA Key"), F("key"), SecuritySettings.WifiKey, 63);

  addFormTextBox( F("Fallback SSID"), F("ssid2"), SecuritySettings.WifiSSID2, 31);

  addFormPasswordBox( F("Fallback WPA Key"), F("key2"), SecuritySettings.WifiKey2, 63);

  addFormSeparator(2);

  addFormPasswordBox(F("WPA AP Mode Key"), F("apkey"), SecuritySettings.WifiAPKey, 63);





  addFormSubHeader(F("Client IP filtering"));

  {

    IPAddress low, high;

    getIPallowedRange(low, high);

    byte iplow[4];

    byte iphigh[4];

    for (byte i = 0; i < 4; ++i) {

      iplow[i] = low[i];

      iphigh[i] = high[i];

    }

    addFormIPaccessControlSelect(F("Client IP block level"), F("ipblocklevel"), SecuritySettings.IPblockLevel);

    addFormIPBox(F("Access IP lower range"), F("iprangelow"), iplow);

    addFormIPBox(F("Access IP upper range"), F("iprangehigh"), iphigh);

  }



  addFormSubHeader(F("IP Settings"));



  addFormIPBox(F("ESP IP"), F("espip"), Settings.IP);

  addFormIPBox(F("ESP GW"), F("espgateway"), Settings.Gateway);

  addFormIPBox(F("ESP Subnet"), F("espsubnet"), Settings.Subnet);

  addFormIPBox(F("ESP DNS"), F("espdns"), Settings.DNS);

  addFormNote(F("Leave empty for DHCP"));





  addFormSubHeader(F("Sleep Mode"));



  addFormNumericBox( F("Sleep awake time"), F("deepsleep"), Settings.deepSleep, 0, 255);

  addUnit(F("sec"));

  addHelpButton(F("SleepMode"));

  addFormNote(F("0 = Sleep Disabled, else time awake from sleep"));



  addFormNumericBox( F("Sleep time"), F("delay"), Settings.Delay, 0, 4294);

  addUnit(F("sec"));



  addFormCheckBox(F("Sleep on connection failure"), F("deepsleeponfail"), Settings.deepSleepOnFail);



  addFormSeparator(2);



  TXBuffer += F("<TR><TD style='width:150px;' align='left'><TD>");

  addSubmitButton();

  TXBuffer += F("</table></form>");



  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

}
# 2299 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_controllers() {

  checkRAM(F("handle_controllers"));

  if (!isLoggedIn()) return;

  navMenuIndex = 2;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);



  struct EventStruct TempEvent;



  byte controllerindex = getFormItemInt(F("index"), 0);

  boolean controllerNotSet = controllerindex == 0;

  --controllerindex;



  String usedns = WebServer.arg(F("usedns"));

  String controllerip = WebServer.arg(F("controllerip"));

  String controllerhostname = WebServer.arg(F("controllerhostname"));

  const int controllerport = getFormItemInt(F("controllerport"), 0);

  const int protocol = getFormItemInt(F("protocol"), -1);

  String controlleruser = WebServer.arg(F("controlleruser"));

  String controllerpassword = WebServer.arg(F("controllerpassword"));

  String controllersubscribe = WebServer.arg(F("controllersubscribe"));

  String controllerpublish = WebServer.arg(F("controllerpublish"));

  String MQTTLwtTopic = WebServer.arg(F("mqttlwttopic"));

  String lwtmessageconnect = WebServer.arg(F("lwtmessageconnect"));

  String lwtmessagedisconnect = WebServer.arg(F("lwtmessagedisconnect"));

  const int minimumsendinterval = getFormItemInt(F("minimumsendinterval"), 100);

  const int maxqueuedepth = getFormItemInt(F("maxqueuedepth"), 10);

  const int maxretry = getFormItemInt(F("maxretry"), 10);

  String deleteoldest = WebServer.arg(F("deleteoldest"));







  if (protocol != -1 && !controllerNotSet)

  {

    ControllerSettingsStruct ControllerSettings;



    if (Settings.Protocol[controllerindex] != protocol)

    {



      Settings.Protocol[controllerindex] = protocol;





      if (Settings.Protocol[controllerindex]!=0)

      {



        byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controllerindex]);

        ControllerSettings.Port = Protocol[ProtocolIndex].defaultPort;

        ControllerSettings.MinimalTimeBetweenMessages = 100;



        if (Protocol[ProtocolIndex].usesTemplate)

          CPlugin_ptr[ProtocolIndex](CPLUGIN_PROTOCOL_TEMPLATE, &TempEvent, dummyString);

        strncpy(ControllerSettings.Subscribe, TempEvent.String1.c_str(), sizeof(ControllerSettings.Subscribe));

        strncpy(ControllerSettings.Publish, TempEvent.String2.c_str(), sizeof(ControllerSettings.Publish));

        strncpy(ControllerSettings.MQTTLwtTopic, TempEvent.String3.c_str(), sizeof(ControllerSettings.MQTTLwtTopic));

        strncpy(ControllerSettings.LWTMessageConnect, TempEvent.String4.c_str(), sizeof(ControllerSettings.LWTMessageConnect));

        strncpy(ControllerSettings.LWTMessageDisconnect, TempEvent.String5.c_str(), sizeof(ControllerSettings.LWTMessageDisconnect));

        TempEvent.String1 = "";

        TempEvent.String2 = "";

        TempEvent.String3 = "";

        TempEvent.String4 = "";

        TempEvent.String5 = "";
# 2433 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
        ClearCustomControllerSettings(controllerindex);

      }



    }





    else

    {



      if (Settings.Protocol != 0)

      {



        byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controllerindex]);

        TempEvent.ControllerIndex = controllerindex;

        TempEvent.ProtocolIndex = ProtocolIndex;

        CPlugin_ptr[ProtocolIndex](CPLUGIN_WEBFORM_SAVE, &TempEvent, dummyString);

        ControllerSettings.UseDNS = usedns.toInt();

        if (ControllerSettings.UseDNS)

        {

          strncpy(ControllerSettings.HostName, controllerhostname.c_str(), sizeof(ControllerSettings.HostName));

          IPAddress IP;

          WiFi.hostByName(ControllerSettings.HostName, IP);

          for (byte x = 0; x < 4; x++)

            ControllerSettings.IP[x] = IP[x];

        }



        else

        {

          str2ip(controllerip, ControllerSettings.IP);

        }



        Settings.ControllerEnabled[controllerindex] = isFormItemChecked(F("controllerenabled"));

        ControllerSettings.Port = controllerport;

        strncpy(SecuritySettings.ControllerUser[controllerindex], controlleruser.c_str(), sizeof(SecuritySettings.ControllerUser[0]));



        copyFormPassword(F("controllerpassword"), SecuritySettings.ControllerPassword[controllerindex], sizeof(SecuritySettings.ControllerPassword[0]));

        strncpy(ControllerSettings.Subscribe, controllersubscribe.c_str(), sizeof(ControllerSettings.Subscribe));

        strncpy(ControllerSettings.Publish, controllerpublish.c_str(), sizeof(ControllerSettings.Publish));

        strncpy(ControllerSettings.MQTTLwtTopic, MQTTLwtTopic.c_str(), sizeof(ControllerSettings.MQTTLwtTopic));

        strncpy(ControllerSettings.LWTMessageConnect, lwtmessageconnect.c_str(), sizeof(ControllerSettings.LWTMessageConnect));

        strncpy(ControllerSettings.LWTMessageDisconnect, lwtmessagedisconnect.c_str(), sizeof(ControllerSettings.LWTMessageDisconnect));

        ControllerSettings.MinimalTimeBetweenMessages = minimumsendinterval;

        ControllerSettings.MaxQueueDepth = maxqueuedepth;

        ControllerSettings.MaxRetry = maxretry;

        ControllerSettings.DeleteOldest = deleteoldest.toInt();





        CPlugin_ptr[ProtocolIndex](CPLUGIN_INIT, &TempEvent, dummyString);

      }

    }

    addHtmlError(SaveControllerSettings(controllerindex, ControllerSettings));

    addHtmlError(SaveSettings());

  }



  TXBuffer += F("<form name='frmselect' method='post'>");



  if (controllerNotSet)

  {

    TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TR><TH style='width:70px;'>");

    TXBuffer += F("<TH style='width:50px;'>Nr<TH style='width:100px;'>Enabled<TH>Protocol<TH>Host<TH>Port");



    ControllerSettingsStruct ControllerSettings;

    for (byte x = 0; x < CONTROLLER_MAX; x++)

    {

      LoadControllerSettings(x, ControllerSettings);

      html_TR_TD();

      TXBuffer += F("<a class='button link' href=\"controllers?index=");

      TXBuffer += x + 1;

      TXBuffer += F("\">Edit</a>");

      html_TD();

      TXBuffer += getControllerSymbol(x);

      html_TD();

      if (Settings.Protocol[x] != 0)

      {

        addEnabled(Settings.ControllerEnabled[x]);



        html_TD();

        byte ProtocolIndex = getProtocolIndex(Settings.Protocol[x]);

        String ProtocolName = "";

        CPlugin_ptr[ProtocolIndex](CPLUGIN_GET_DEVICENAME, 0, ProtocolName);

        TXBuffer += ProtocolName;



        html_TD();

        TXBuffer += ControllerSettings.getHost();

        html_TD();

        TXBuffer += ControllerSettings.Port;

      }

      else {

        html_TD(3);

      }

    }

    TXBuffer += F("</table></form>");

  }

  else

  {

    TXBuffer += F("<table class='normal'><TR><TH style='width:150px;' align='left'>Controller Settings<TH>");

    html_TR_TD(); TXBuffer += F("Protocol:");

    byte choice = Settings.Protocol[controllerindex];

    html_TD();

    addSelector_Head(F("protocol"), true);

    addSelector_Item(F("- Standalone -"), 0, false, false, F(""));

    for (byte x = 0; x <= protocolCount; x++)

    {

      String ProtocolName = "";

      CPlugin_ptr[x](CPLUGIN_GET_DEVICENAME, 0, ProtocolName);

      boolean disabled = false;

      addSelector_Item(ProtocolName,

                       Protocol[x].Number,

                       choice == Protocol[x].Number,

                       disabled,

                       F(""));

    }

    addSelector_Foot();



    addHelpButton(F("EasyProtocols"));





    if (Settings.Protocol[controllerindex])

    {

      ControllerSettingsStruct ControllerSettings;

      LoadControllerSettings(controllerindex, ControllerSettings);

      byte choice = ControllerSettings.UseDNS;

      String options[2];

      options[0] = F("Use IP address");

      options[1] = F("Use Hostname");



      byte choice_delete_oldest = ControllerSettings.DeleteOldest;

      String options_delete_oldest[2];

      options_delete_oldest[0] = F("Ignore New");

      options_delete_oldest[1] = F("Delete Oldest");





      byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controllerindex]);

      if (!Protocol[ProtocolIndex].Custom)

      {



        addFormSelector(F("Locate Controller"), F("usedns"), 2, options, NULL, NULL, choice, true);

        if (ControllerSettings.UseDNS)

        {

          addFormTextBox( F("Controller Hostname"), F("controllerhostname"), ControllerSettings.HostName, sizeof(ControllerSettings.HostName)-1);

        }

        else

        {

          addFormIPBox(F("Controller IP"), F("controllerip"), ControllerSettings.IP);

        }



        addFormNumericBox( F("Controller Port"), F("controllerport"), ControllerSettings.Port, 1, 65535);

        addFormNumericBox( F("Minimum Send Interval"), F("minimumsendinterval"), ControllerSettings.MinimalTimeBetweenMessages, 1, CONTROLLER_DELAY_QUEUE_DELAY_MAX);

        addUnit(F("ms"));

        addFormNumericBox( F("Max Queue Depth"), F("maxqueuedepth"), ControllerSettings.MaxQueueDepth, 1, CONTROLLER_DELAY_QUEUE_DEPTH_MAX);

        addFormNumericBox( F("Max Retries"), F("maxretry"), ControllerSettings.MaxRetry, 1, CONTROLLER_DELAY_QUEUE_RETRY_MAX);

        addFormSelector(F("Full Queue Action"), F("deleteoldest"), 2, options_delete_oldest, NULL, NULL, choice_delete_oldest, true);





        if (Protocol[ProtocolIndex].usesAccount)

        {

          String protoDisplayName;

          if (!getControllerProtocolDisplayName(ProtocolIndex, CONTROLLER_USER, protoDisplayName)) {

            protoDisplayName = F("Controller User");

          }

          addFormTextBox(protoDisplayName, F("controlleruser"), SecuritySettings.ControllerUser[controllerindex], sizeof(SecuritySettings.ControllerUser[0])-1);

        }

        if (Protocol[ProtocolIndex].usesPassword)

        {

          String protoDisplayName;

          if (getControllerProtocolDisplayName(ProtocolIndex, CONTROLLER_PASS, protoDisplayName)) {



            addFormTextBox(protoDisplayName, F("controllerpassword"), SecuritySettings.ControllerPassword[controllerindex], sizeof(SecuritySettings.ControllerPassword[0])-1);

          } else {

            addFormPasswordBox(F("Controller Password"), F("controllerpassword"), SecuritySettings.ControllerPassword[controllerindex], sizeof(SecuritySettings.ControllerPassword[0])-1);

          }

        }



        if (Protocol[ProtocolIndex].usesTemplate || Protocol[ProtocolIndex].usesMQTT)

        {

          String protoDisplayName;

          if (!getControllerProtocolDisplayName(ProtocolIndex, CONTROLLER_SUBSCRIBE, protoDisplayName)) {

            protoDisplayName = F("Controller Subscribe");

          }

          addFormTextBox(protoDisplayName, F("controllersubscribe"), ControllerSettings.Subscribe, sizeof(ControllerSettings.Subscribe)-1);

        }



        if (Protocol[ProtocolIndex].usesTemplate || Protocol[ProtocolIndex].usesMQTT)

        {

          String protoDisplayName;

          if (!getControllerProtocolDisplayName(ProtocolIndex, CONTROLLER_PUBLISH, protoDisplayName)) {

            protoDisplayName = F("Controller Publish");

          }

          addFormTextBox(protoDisplayName, F("controllerpublish"), ControllerSettings.Publish, sizeof(ControllerSettings.Publish)-1);

        }



        if (Protocol[ProtocolIndex].usesMQTT)

        {

          String protoDisplayName;

          if (!getControllerProtocolDisplayName(ProtocolIndex, CONTROLLER_LWT_TOPIC, protoDisplayName)) {

            protoDisplayName = F("Controller lwl topic");

          }

          addFormTextBox(protoDisplayName, F("mqttlwttopic"), ControllerSettings.MQTTLwtTopic, sizeof(ControllerSettings.MQTTLwtTopic)-1);

        }



        if (Protocol[ProtocolIndex].usesMQTT)

        {

          String protoDisplayName;

          if (!getControllerProtocolDisplayName(ProtocolIndex, CONTROLLER_LWT_CONNECT_MESSAGE, protoDisplayName)) {

            protoDisplayName = F("LWT Connect Message");

          }

          addFormTextBox(protoDisplayName, F("lwtmessageconnect"), ControllerSettings.LWTMessageConnect, sizeof(ControllerSettings.LWTMessageConnect)-1);

        }



        if (Protocol[ProtocolIndex].usesMQTT)

        {

          String protoDisplayName;

          if (!getControllerProtocolDisplayName(ProtocolIndex, CONTROLLER_LWT_DISCONNECT_MESSAGE, protoDisplayName)) {

            protoDisplayName = F("LWT Disconnect Message");

          }

          addFormTextBox(protoDisplayName, F("lwtmessagedisconnect"), ControllerSettings.LWTMessageDisconnect, sizeof(ControllerSettings.LWTMessageDisconnect)-1);

        }

      }



      addFormCheckBox(F("Enabled"), F("controllerenabled"), Settings.ControllerEnabled[controllerindex]);



      TempEvent.ControllerIndex = controllerindex;

      TempEvent.ProtocolIndex = ProtocolIndex;

      CPlugin_ptr[ProtocolIndex](CPLUGIN_WEBFORM_LOAD, &TempEvent,TXBuffer.buf);



    }



    addFormSeparator(2);

    html_TR_TD();

    html_TD();

    TXBuffer += F("<a class='button link' href=\"controllers\">Close</a>");

    addSubmitButton();

    TXBuffer += F("</table></form>");

  }



  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

}
# 2921 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void html_TR_TD_highlight() {

  TXBuffer += F("<TR class=\"highlight\">");

  html_TD();

}



void html_TR_TD() {

  TXBuffer += F("<TR>");

  html_TD();

}



void html_BR() {

  TXBuffer += F("<BR>");

}



void html_TR_TD_height(int height) {

  TXBuffer += F("<TR><TD HEIGHT=\"");

  TXBuffer += height;

  TXBuffer += F("\">");

}



void html_TD() {

  html_TD(1);

}



void html_TD(int td_cnt) {

  for (int i = 0; i < td_cnt; ++i) {

    TXBuffer += F("<TD>");

  }

}



void html_input(const String& displayStr, const String& intString, int size, const String& value) {

  html_TR_TD();

  TXBuffer += displayStr;

  TXBuffer += F(":<TD><input class='wide' type='text' name='");

  TXBuffer += intString;

  TXBuffer += F("' size=");

  TXBuffer += size;

  TXBuffer += F(" value='");

  TXBuffer += value;

  TXBuffer += F("'>");

}
# 3013 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_notifications() {

  checkRAM(F("handle_notifications"));

  if (!isLoggedIn()) return;

  navMenuIndex = 6;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);



  struct EventStruct TempEvent;







  byte notificationindex = getFormItemInt(F("index"), 0);

  boolean notificationindexNotSet = notificationindex == 0;

  --notificationindex;



  const int notification = getFormItemInt(F("notification"), -1);

  String domain = WebServer.arg(F("domain"));

  String server = WebServer.arg(F("server"));

  String sender = WebServer.arg(F("sender"));

  String receiver = WebServer.arg(F("receiver"));

  String subject = WebServer.arg(F("subject"));

  String user = WebServer.arg(F("user"));

  String pass = WebServer.arg(F("pass"));

  String body = WebServer.arg(F("body"));

  String notificationenabled = WebServer.arg(F("notificationenabled"));
# 3071 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
  if (notification != -1 && !notificationindexNotSet)

  {

    NotificationSettingsStruct NotificationSettings;

    if (Settings.Notification[notificationindex] != notification)

    {

      Settings.Notification[notificationindex] = notification;

    }

    else

    {

      if (Settings.Notification != 0)

      {

        byte NotificationProtocolIndex = getNotificationProtocolIndex(Settings.Notification[notificationindex]);

        if (NotificationProtocolIndex!=NPLUGIN_NOT_FOUND)

          NPlugin_ptr[NotificationProtocolIndex](NPLUGIN_WEBFORM_SAVE, 0, dummyString);

        NotificationSettings.Port = getFormItemInt(F("port"), 0);

        NotificationSettings.Pin1 = getFormItemInt(F("pin1"), 0);

        NotificationSettings.Pin2 = getFormItemInt(F("pin2"), 0);

        Settings.NotificationEnabled[notificationindex] = isFormItemChecked(F("notificationenabled"));

        strncpy(NotificationSettings.Domain, domain.c_str(), sizeof(NotificationSettings.Domain));

        strncpy(NotificationSettings.Server, server.c_str(), sizeof(NotificationSettings.Server));

        strncpy(NotificationSettings.Sender, sender.c_str(), sizeof(NotificationSettings.Sender));

        strncpy(NotificationSettings.Receiver, receiver.c_str(), sizeof(NotificationSettings.Receiver));

        strncpy(NotificationSettings.Subject, subject.c_str(), sizeof(NotificationSettings.Subject));

        strncpy(NotificationSettings.User, user.c_str(), sizeof(NotificationSettings.User));

        strncpy(NotificationSettings.Pass, pass.c_str(), sizeof(NotificationSettings.Pass));

        strncpy(NotificationSettings.Body, body.c_str(), sizeof(NotificationSettings.Body));

      }

    }



    addHtmlError(SaveNotificationSettings(notificationindex, (byte*)&NotificationSettings, sizeof(NotificationSettings)));

    addHtmlError(SaveSettings());

    if (WebServer.hasArg(F("test"))) {



      byte NotificationProtocolIndex = getNotificationProtocolIndex(Settings.Notification[notificationindex]);

      if (NotificationProtocolIndex != NPLUGIN_NOT_FOUND)

      {



        TempEvent.NotificationIndex = notificationindex;

        schedule_notification_event_timer(NotificationProtocolIndex, NPLUGIN_NOTIFY, &TempEvent);

      }

    }

  }



  TXBuffer += F("<form name='frmselect' method='post'>");



  if (notificationindexNotSet)

  {

    TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TR><TH style='width:70px;'>");

    TXBuffer += F("<TH style='width:50px;'>Nr<TH style='width:100px;'>Enabled<TH>Service<TH>Server<TH>Port");



    NotificationSettingsStruct NotificationSettings;

    for (byte x = 0; x < NOTIFICATION_MAX; x++)

    {

      LoadNotificationSettings(x, (byte*)&NotificationSettings, sizeof(NotificationSettings));

      html_TR_TD();

      TXBuffer += F("<a class='button link' href=\"notifications?index=");

      TXBuffer += x + 1;

      TXBuffer += F("\">Edit</a>");

      html_TD();

      TXBuffer += x + 1;

      html_TD();

      if (Settings.Notification[x] != 0)

      {

        addEnabled(Settings.NotificationEnabled[x]);



        html_TD();

        byte NotificationProtocolIndex = getNotificationProtocolIndex(Settings.Notification[x]);

        String NotificationName = F("(plugin not found?)");

        if (NotificationProtocolIndex!=NPLUGIN_NOT_FOUND)

        {

          NPlugin_ptr[NotificationProtocolIndex](NPLUGIN_GET_DEVICENAME, 0, NotificationName);

        }

        TXBuffer += NotificationName;

        html_TD();

        TXBuffer += NotificationSettings.Server;

        html_TD();

        TXBuffer += NotificationSettings.Port;

      }

      else {

        html_TD(3);

      }

    }

    TXBuffer += F("</table></form>");

  }

  else

  {

    TXBuffer += F("<table class='normal'><TR><TH style='width:150px;' align='left'>Notification Settings<TH>");

    html_TR_TD(); TXBuffer += F("Notification:");

    byte choice = Settings.Notification[notificationindex];

    html_TD();

    addSelector_Head(F("notification"), true);

    addSelector_Item(F("- None -"), 0, false, false, F(""));

    for (byte x = 0; x <= notificationCount; x++)

    {

      String NotificationName = "";

      NPlugin_ptr[x](NPLUGIN_GET_DEVICENAME, 0, NotificationName);

      addSelector_Item(NotificationName,

                       Notification[x].Number,

                       choice == Notification[x].Number,

                       false,

                       F(""));

    }

    addSelector_Foot();



    addHelpButton(F("EasyNotifications"));
# 3289 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
    if (Settings.Notification[notificationindex])

    {

      NotificationSettingsStruct NotificationSettings;

      LoadNotificationSettings(notificationindex, (byte*)&NotificationSettings, sizeof(NotificationSettings));



      byte NotificationProtocolIndex = getNotificationProtocolIndex(Settings.Notification[notificationindex]);

      if (NotificationProtocolIndex!=NPLUGIN_NOT_FOUND)

      {



        if (Notification[NotificationProtocolIndex].usesMessaging)

        {

          html_input(F("Domain"), F("domain"), 64, NotificationSettings.Domain);

          html_input(F("Server"), F("server"), 64, NotificationSettings.Server);

          html_input(F("Port"), F("port"), 5, String(NotificationSettings.Port));



          html_input(F("Sender"), F("sender"), 64, NotificationSettings.Sender);

          html_input(F("Receiver"), F("receiver"), 64, NotificationSettings.Receiver);

          html_input(F("Subject"), F("subject"), 64, NotificationSettings.Subject);



          html_input(F("User"), F("user"), 48, NotificationSettings.User);

          html_input(F("Pass"), F("pass"), 32, NotificationSettings.Pass);



          html_TR_TD(); TXBuffer += F("Body:<TD><textarea name='body' rows='20' size=512 wrap='off'>");

          TXBuffer += NotificationSettings.Body;

          TXBuffer += F("</textarea>");

        }



        if (Notification[NotificationProtocolIndex].usesGPIO > 0)

        {

          html_TR_TD(); TXBuffer += F("1st GPIO:<TD>");

          addPinSelect(false, "pin1", NotificationSettings.Pin1);

        }



        html_TR_TD(); TXBuffer += F("Enabled:<TD>");

        addCheckBox(F("notificationenabled"), Settings.NotificationEnabled[notificationindex]);



        TempEvent.NotificationIndex = notificationindex;

        NPlugin_ptr[NotificationProtocolIndex](NPLUGIN_WEBFORM_LOAD, &TempEvent,TXBuffer.buf);

      }

    }



    addFormSeparator(2);



    html_TR_TD();

    html_TD();

    TXBuffer += F("<a class='button link' href=\"notifications\">Close</a>");

    addSubmitButton();

    addSubmitButton(F("Test"), F("test"));

    TXBuffer += F("</table></form>");

  }

  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

}
# 3405 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_hardware() {

  checkRAM(F("handle_hardware"));

  if (!isLoggedIn()) return;

  navMenuIndex = 3;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);

  if (isFormItem(F("psda")))

  {

    Settings.Pin_status_led = getFormItemInt(F("pled"));

    Settings.Pin_status_led_Inversed = isFormItemChecked(F("pledi"));

    Settings.Pin_Reset = getFormItemInt(F("pres"));

    Settings.Pin_i2c_sda = getFormItemInt(F("psda"));

    Settings.Pin_i2c_scl = getFormItemInt(F("pscl"));

    Settings.InitSPI = isFormItemChecked(F("initspi"));

    Settings.Pin_sd_cs = getFormItemInt(F("sd"));

    Settings.PinBootStates[0] = getFormItemInt(F("p0"));

    Settings.PinBootStates[2] = getFormItemInt(F("p2"));

    Settings.PinBootStates[4] = getFormItemInt(F("p4"));

    Settings.PinBootStates[5] = getFormItemInt(F("p5"));

    Settings.PinBootStates[9] = getFormItemInt(F("p9"));

    Settings.PinBootStates[10] = getFormItemInt(F("p10"));

    Settings.PinBootStates[12] = getFormItemInt(F("p12"));

    Settings.PinBootStates[13] = getFormItemInt(F("p13"));

    Settings.PinBootStates[14] = getFormItemInt(F("p14"));

    Settings.PinBootStates[15] = getFormItemInt(F("p15"));

    Settings.PinBootStates[16] = getFormItemInt(F("p16"));



    addHtmlError(SaveSettings());

  }



  TXBuffer += F("<form  method='post'><table class='normal'><TR><TH style='width:150px;' align='left'>Hardware Settings<TH align='left'>");

  addHelpButton(F("ESPEasy#Hardware_page"));



  addFormSubHeader(F("Wifi Status LED"));

  addFormPinSelect(F("GPIO &rarr; LED"), "pled", Settings.Pin_status_led);

  addFormCheckBox(F("Inversed LED"), F("pledi"), Settings.Pin_status_led_Inversed);

  addFormNote(F("Use &rsquo;GPIO-2 (D4)&rsquo; with &rsquo;Inversed&rsquo; checked for onboard LED"));



  addFormSubHeader(F("Reset Pin"));

  addFormPinSelect(F("GPIO &larr; Switch"), "pres", Settings.Pin_Reset);

  addFormNote(F("Press about 10s for factory reset"));



  addFormSubHeader(F("I2C Interface"));

  addFormPinSelectI2C(F("GPIO &#8703; SDA"), F("psda"), Settings.Pin_i2c_sda);

  addFormPinSelectI2C(F("GPIO &#8702; SCL"), F("pscl"), Settings.Pin_i2c_scl);





  addFormSubHeader(F("SPI Interface"));

  addFormCheckBox(F("Init SPI"), F("initspi"), Settings.InitSPI);

  addFormNote(F("CLK=GPIO-14 (D5), MISO=GPIO-12 (D6), MOSI=GPIO-13 (D7)"));

  addFormNote(F("Chip Select (CS) config must be done in the plugin"));

#ifdef FEATURE_SD

  addFormPinSelect(F("GPIO &rarr; SD Card CS"), "sd", Settings.Pin_sd_cs);

#endif



  addFormSubHeader(F("GPIO boot states"));

  addFormPinStateSelect(F("Pin mode 0 (D3)"), F("p0"), Settings.PinBootStates[0]);

  addFormPinStateSelect(F("Pin mode 2 (D4)"), F("p2"), Settings.PinBootStates[2]);

  addFormPinStateSelect(F("Pin mode 4 (D2)"), F("p4"), Settings.PinBootStates[4]);

  addFormPinStateSelect(F("Pin mode 5 (D1)"), F("p5"), Settings.PinBootStates[5]);

  addFormPinStateSelect(F("Pin mode 9 (D11)"), F("p9"), Settings.PinBootStates[9]);

  addFormPinStateSelect(F("Pin mode 10 (D12)"), F("p10"), Settings.PinBootStates[10]);

  addFormPinStateSelect(F("Pin mode 12 (D6)"), F("p12"), Settings.PinBootStates[12]);

  addFormPinStateSelect(F("Pin mode 13 (D7)"), F("p13"), Settings.PinBootStates[13]);

  addFormPinStateSelect(F("Pin mode 14 (D5)"), F("p14"), Settings.PinBootStates[14]);

  addFormPinStateSelect(F("Pin mode 15 (D8)"), F("p15"), Settings.PinBootStates[15]);

  addFormPinStateSelect(F("Pin mode 16 (D0)"), F("p16"), Settings.PinBootStates[16]);

  addFormSeparator(2);



  html_TR_TD();

  html_TD();

  addSubmitButton();

  html_TR_TD();

  TXBuffer += F("</table></form>");



  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();



}
# 3571 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addFormPinStateSelect(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addPinStateSelect(id, choice);

}



void addPinStateSelect(String name, int choice)

{

  String options[4] = { F("Default"), F("Output Low"), F("Output High"), F("Input") };

  addSelector(name, 4, options, NULL, NULL, choice, false);

}
# 3601 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addFormIPaccessControlSelect(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addIPaccessControlSelect(id, choice);

}



void addIPaccessControlSelect(String name, int choice)

{

  String options[3] = { F("Allow All"), F("Allow Local Subnet"), F("Allow IP range") };

  addSelector(name, 3, options, NULL, NULL, choice, false);

}
# 3639 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_devices() {

  checkRAM(F("handle_devices"));

  if (!isLoggedIn()) return;

  navMenuIndex = 4;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);







  struct EventStruct TempEvent;







  byte taskdevicenumber;

  if (WebServer.hasArg(F("del")))

    taskdevicenumber=0;

  else

    taskdevicenumber = getFormItemInt(F("TDNUM"), 0);





  unsigned long taskdevicetimer = getFormItemInt(F("TDT"),0);
# 3777 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
  byte page = getFormItemInt(F("page"), 0);

  if (page == 0)

    page = 1;

  byte setpage = getFormItemInt(F("setpage"), 0);

  if (setpage > 0)

  {

    if (setpage <= (TASKS_MAX / TASKS_PER_PAGE))

      page = setpage;

    else

      page = TASKS_MAX / TASKS_PER_PAGE;

  }

  const int edit = getFormItemInt(F("edit"), 0);







  byte taskIndex = getFormItemInt(F("index"), 0);

  boolean taskIndexNotSet = taskIndex == 0;

  --taskIndex;



  byte DeviceIndex = 0;

  LoadTaskSettings(taskIndex);



  if (edit != 0 && !taskIndexNotSet)

  {

    if (Settings.TaskDeviceNumber[taskIndex] != taskdevicenumber)

    {



      TempEvent.TaskIndex = taskIndex;

      PluginCall(PLUGIN_EXIT, &TempEvent, dummyString);



      taskClear(taskIndex, false);

      ClearCustomTaskSettings(taskIndex);



      Settings.TaskDeviceNumber[taskIndex] = taskdevicenumber;

      if (taskdevicenumber != 0)

      {



        if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

          PluginCall(PLUGIN_GET_DEVICEVALUENAMES, &TempEvent, dummyString);

      } else {

        SaveTaskSettings(taskIndex);

        SaveSettings();

      }

    }

    else if (taskdevicenumber != 0)

    {

      Settings.TaskDeviceNumber[taskIndex] = taskdevicenumber;

      DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[taskIndex]);



      if (taskdevicetimer > 0)

        Settings.TaskDeviceTimer[taskIndex] = taskdevicetimer;

      else

      {

        if (!Device[DeviceIndex].TimerOptional)

          Settings.TaskDeviceTimer[taskIndex] = Settings.Delay;

        else

          Settings.TaskDeviceTimer[taskIndex] = 0;

      }



      Settings.TaskDeviceEnabled[taskIndex] = isFormItemChecked(F("TDE"));

      strcpy(ExtraTaskSettings.TaskDeviceName, WebServer.arg(F("TDN")).c_str());

      Settings.TaskDevicePort[taskIndex] = getFormItemInt(F("TDP"), 0);



      for (byte controllerNr = 0; controllerNr < CONTROLLER_MAX; controllerNr++)

      {



        Settings.TaskDeviceID[controllerNr][taskIndex] = getFormItemInt(String(F("TDID")) + (controllerNr + 1));

        Settings.TaskDeviceSendData[controllerNr][taskIndex] = isFormItemChecked(String(F("TDSD")) + (controllerNr + 1));

      }



      update_whenset_FormItemInt(F("taskdevicepin1"), Settings.TaskDevicePin1[taskIndex]);

      update_whenset_FormItemInt(F("taskdevicepin2"), Settings.TaskDevicePin2[taskIndex]);

      update_whenset_FormItemInt(F("taskdevicepin3"), Settings.TaskDevicePin3[taskIndex]);



      if (Device[DeviceIndex].PullUpOption)

        Settings.TaskDevicePin1PullUp[taskIndex] = isFormItemChecked(F("TDPPU"));



      if (Device[DeviceIndex].InverseLogicOption)

        Settings.TaskDevicePin1Inversed[taskIndex] = isFormItemChecked(F("TDPI"));



      for (byte varNr = 0; varNr < Device[DeviceIndex].ValueCount; varNr++)

      {



        strcpy(ExtraTaskSettings.TaskDeviceFormula[varNr], WebServer.arg(String(F("TDF")) + (varNr + 1)).c_str());

        ExtraTaskSettings.TaskDeviceValueDecimals[varNr] = getFormItemInt(String(F("TDVD")) + (varNr + 1));

        strcpy(ExtraTaskSettings.TaskDeviceValueNames[varNr], WebServer.arg(String(F("TDVN")) + (varNr + 1)).c_str());
# 3961 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
      }
# 3979 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
      TempEvent.TaskIndex = taskIndex;

      if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

        PluginCall(PLUGIN_GET_DEVICEVALUENAMES, &TempEvent, dummyString);





      PluginCall(PLUGIN_WEBFORM_SAVE, &TempEvent, dummyString);





      for (byte x=0; x < CONTROLLER_MAX; x++)

        {

          TempEvent.ControllerIndex = x;

          if (Settings.TaskDeviceSendData[TempEvent.ControllerIndex][TempEvent.TaskIndex] &&

            Settings.ControllerEnabled[TempEvent.ControllerIndex] && Settings.Protocol[TempEvent.ControllerIndex])

            {

              TempEvent.ProtocolIndex = getProtocolIndex(Settings.Protocol[TempEvent.ControllerIndex]);

              CPlugin_ptr[TempEvent.ProtocolIndex](CPLUGIN_TASK_CHANGE_NOTIFICATION, &TempEvent, dummyString);

            }

        }

    }

    addHtmlError(SaveTaskSettings(taskIndex));



    addHtmlError(SaveSettings());



    if (taskdevicenumber != 0 && Settings.TaskDeviceEnabled[taskIndex])

      PluginCall(PLUGIN_INIT, &TempEvent, dummyString);

  }





  if (taskIndexNotSet)

  {

    TXBuffer += jsUpdateSensorValuesDevicePage;



    TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TR><TH style='width:70px;'>");



    if (TASKS_MAX != TASKS_PER_PAGE)

    {

      TXBuffer += F("<a class='button link' href=\"devices?setpage=");

      if (page > 1)

        TXBuffer += page - 1;

      else

        TXBuffer += page;

      TXBuffer += F("\">&lt;</a>");

      TXBuffer += F("<a class='button link' href=\"devices?setpage=");

      if (page < (TASKS_MAX / TASKS_PER_PAGE))

        TXBuffer += page + 1;

      else

        TXBuffer += page;

      TXBuffer += F("\">&gt;</a>");

    }



    TXBuffer += F("<TH style='width:50px;'>Task<TH style='width:100px;'>Enabled<TH>Device<TH>Name<TH>Port<TH style='width:100px;'>Ctr (IDX)<TH style='width:70px;'>GPIO<TH>Values");



    String deviceName;



    for (byte x = (page - 1) * TASKS_PER_PAGE; x < ((page) * TASKS_PER_PAGE); x++)

    {

      html_TR_TD();

      TXBuffer += F("<a class='button link' href=\"devices?index=");

      TXBuffer += x + 1;

      TXBuffer += F("&page=");

      TXBuffer += page;

      TXBuffer += F("\">Edit</a>");

      html_TD();

      TXBuffer += x + 1;

      html_TD();



      if (Settings.TaskDeviceNumber[x] != 0)

      {

        LoadTaskSettings(x);

        DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[x]);

        TempEvent.TaskIndex = x;

        addEnabled( Settings.TaskDeviceEnabled[x]);



        html_TD();

        TXBuffer += getPluginNameFromDeviceIndex(DeviceIndex);

        html_TD();

        TXBuffer += ExtraTaskSettings.TaskDeviceName;

        html_TD();



        byte customConfig = false;

        customConfig = PluginCall(PLUGIN_WEBFORM_SHOW_CONFIG, &TempEvent,TXBuffer.buf);

        if (!customConfig)

          if (Device[DeviceIndex].Ports != 0)

            TXBuffer += formatToHex_decimal(Settings.TaskDevicePort[x]);



        html_TD();



        if (Device[DeviceIndex].SendDataOption)

        {

          boolean doBR = false;

          for (byte controllerNr = 0; controllerNr < CONTROLLER_MAX; controllerNr++)

          {

            byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controllerNr]);

            if (Settings.TaskDeviceSendData[controllerNr][x])

            {

              if (doBR)

                TXBuffer += F("<BR>");

              TXBuffer += getControllerSymbol(controllerNr);

              if (Protocol[ProtocolIndex].usesID && Settings.Protocol[controllerNr] != 0)

              {

                TXBuffer += F(" (");

                TXBuffer += Settings.TaskDeviceID[controllerNr][x];

                TXBuffer += F(")");

                if (Settings.TaskDeviceID[controllerNr][x] == 0)

                  TXBuffer += F(" " HTML_SYMBOL_WARNING);

              }

              doBR = true;

            }

          }

        }



        html_TD();



        if (Settings.TaskDeviceDataFeed[x] == 0)

        {

          if (Device[DeviceIndex].Type == DEVICE_TYPE_I2C)

          {

            TXBuffer += F("GPIO-");

            TXBuffer += Settings.Pin_i2c_sda;

            TXBuffer += F("<BR>GPIO-");

            TXBuffer += Settings.Pin_i2c_scl;

          }

          if (Device[DeviceIndex].Type == DEVICE_TYPE_ANALOG)

            TXBuffer += F("ADC (TOUT)");



          if (Settings.TaskDevicePin1[x] != -1)

          {

            TXBuffer += F("GPIO-");

            TXBuffer += Settings.TaskDevicePin1[x];

          }



          if (Settings.TaskDevicePin2[x] != -1)

          {

            TXBuffer += F("<BR>GPIO-");

            TXBuffer += Settings.TaskDevicePin2[x];

          }



          if (Settings.TaskDevicePin3[x] != -1)

          {

            TXBuffer += F("<BR>GPIO-");

            TXBuffer += Settings.TaskDevicePin3[x];

          }

        }



        html_TD();

        byte customValues = false;

        customValues = PluginCall(PLUGIN_WEBFORM_SHOW_VALUES, &TempEvent,TXBuffer.buf);

        if (!customValues)

        {

          for (byte varNr = 0; varNr < Device[DeviceIndex].ValueCount; varNr++)

          {

            if (Settings.TaskDeviceNumber[x] != 0)

            {

              if (varNr > 0)

                TXBuffer += F("<div class='div_br'></div>");

              TXBuffer += F("<div class='div_l' id='valuename_");

              TXBuffer += x;

              TXBuffer += '_';

              TXBuffer += varNr;

              TXBuffer += F("'>");

              TXBuffer += ExtraTaskSettings.TaskDeviceValueNames[varNr];

              TXBuffer += F(":</div><div class='div_r' id='value_");

              TXBuffer += x;

              TXBuffer += '_';

              TXBuffer += varNr;

              TXBuffer += F("'>");

              TXBuffer += formatUserVarNoCheck(x, varNr);

              TXBuffer += "</div>";

            }

          }

        }

      }

      else {

        html_TD(6);

      }



    }

    TXBuffer += F("</table></form>");



  }



  else

  {

    LoadTaskSettings(taskIndex);

    DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[taskIndex]);

    TempEvent.TaskIndex = taskIndex;



    TXBuffer += F("<form name='frmselect' method='post'><table class='normal'>");

    addFormHeader(F("Task Settings"));





    TXBuffer += F("<TR><TD style='width:150px;' align='left'>Device:<TD>");





    if (Settings.TaskDeviceNumber[taskIndex] == 0 )

    {



      addDeviceSelect("TDNUM", Settings.TaskDeviceNumber[taskIndex]);



    }



    else

    {



      TXBuffer += F("<input type='hidden' name='TDNUM' value='");

      TXBuffer += Settings.TaskDeviceNumber[taskIndex];

      TXBuffer += F("'>");





      TXBuffer += getPluginNameFromDeviceIndex(DeviceIndex);



      addHelpButton(String(F("Plugin")) + Settings.TaskDeviceNumber[taskIndex]);



      if (Device[DeviceIndex].Number == 3 && taskIndex >= 4)

        {

          addFormNote(F("This plugin is only supported on task 1-4 for now"));

        }



      addFormTextBox( F("Name"), F("TDN"), ExtraTaskSettings.TaskDeviceName, NAME_FORMULA_LENGTH_MAX);



      addFormCheckBox(F("Enabled"), F("TDE"), Settings.TaskDeviceEnabled[taskIndex]);





      if (!Device[DeviceIndex].Custom && Settings.TaskDeviceDataFeed[taskIndex] == 0 &&

          ((Device[DeviceIndex].Ports != 0) ||

           (Device[DeviceIndex].PullUpOption) ||

           (Device[DeviceIndex].InverseLogicOption) ||

           (Device[DeviceIndex].connectedToGPIOpins())) )

      {

        addFormSubHeader((Device[DeviceIndex].SendDataOption) ? F("Sensor") : F("Actuator"));



        if (Device[DeviceIndex].Ports != 0)

          addFormNumericBox(F("Port"), F("TDP"), Settings.TaskDevicePort[taskIndex]);



        if (Device[DeviceIndex].PullUpOption)

        {

          addFormCheckBox(F("Internal PullUp"), F("TDPPU"), Settings.TaskDevicePin1PullUp[taskIndex]);

          if ((Settings.TaskDevicePin1[taskIndex] == 16) || (Settings.TaskDevicePin2[taskIndex] == 16) || (Settings.TaskDevicePin3[taskIndex] == 16))

            addFormNote(F("GPIO-16 (D0) does not support PullUp"));

        }



        if (Device[DeviceIndex].InverseLogicOption)

        {

          addFormCheckBox(F("Inversed Logic"), F("TDPI"), Settings.TaskDevicePin1Inversed[taskIndex]);

          addFormNote(F("Will go into effect on next input change."));

        }





        TempEvent.String1 = F("1st GPIO");

        TempEvent.String2 = F("2nd GPIO");

        TempEvent.String3 = F("3rd GPIO");

        PluginCall(PLUGIN_GET_DEVICEGPIONAMES, &TempEvent, dummyString);



        if (Device[DeviceIndex].connectedToGPIOpins()) {

          if (Device[DeviceIndex].Type >= DEVICE_TYPE_SINGLE)

            addFormPinSelect(TempEvent.String1, F("taskdevicepin1"), Settings.TaskDevicePin1[taskIndex]);

          if (Device[DeviceIndex].Type >= DEVICE_TYPE_DUAL)

            addFormPinSelect( TempEvent.String2, F("taskdevicepin2"), Settings.TaskDevicePin2[taskIndex]);

          if (Device[DeviceIndex].Type == DEVICE_TYPE_TRIPLE)

            addFormPinSelect(TempEvent.String3, F("taskdevicepin3"), Settings.TaskDevicePin3[taskIndex]);

        }

      }





      if (Settings.TaskDeviceDataFeed[taskIndex] == 0) {

        String webformLoadString;

        PluginCall(PLUGIN_WEBFORM_LOAD, &TempEvent,webformLoadString);

        if (webformLoadString.length() > 0) {

          String errorMessage;

          PluginCall(PLUGIN_GET_DEVICENAME, &TempEvent, errorMessage);

          errorMessage += F(": Bug in PLUGIN_WEBFORM_LOAD, should not append to string, use addHtml() instead");

          addHtmlError(errorMessage);

        }

      }





      if (Device[DeviceIndex].SendDataOption)

      {

        addFormSubHeader(F("Data Acquisition"));



        for (byte controllerNr = 0; controllerNr < CONTROLLER_MAX; controllerNr++)

        {

          if (Settings.Protocol[controllerNr] != 0)

          {

            String id = F("TDSD");

            id += controllerNr + 1;



            html_TR_TD(); TXBuffer += F("Send to Controller ");

            TXBuffer += getControllerSymbol(controllerNr);

            html_TD();

            addCheckBox(id, Settings.TaskDeviceSendData[controllerNr][taskIndex]);



            byte ProtocolIndex = getProtocolIndex(Settings.Protocol[controllerNr]);

            if (Protocol[ProtocolIndex].usesID && Settings.Protocol[controllerNr] != 0)

            {

              html_TR_TD(); TXBuffer += F("IDX:<TD>");

              id = F("TDID");

              id += controllerNr + 1;

              addNumericBox(id, Settings.TaskDeviceID[controllerNr][taskIndex], 0, DOMOTICZ_MAX_IDX);

            }

          }

        }

      }



      addFormSeparator(2);



      if (Device[DeviceIndex].TimerOption)

      {



        addFormNumericBox( F("Interval"), F("TDT"), Settings.TaskDeviceTimer[taskIndex], 0, 65535);

        addUnit(F("sec"));

        if (Device[DeviceIndex].TimerOptional)

          TXBuffer += F(" (Optional for this Device)");

      }





      if (!Device[DeviceIndex].Custom && Device[DeviceIndex].ValueCount > 0)

      {

        addFormSubHeader(F("Values"));

        TXBuffer += F("</table><table class='normal'>");





        TXBuffer += F("<TR><TH style='width:30px;' align='center'>#");

        TXBuffer += F("<TH align='left'>Name");



        if (Device[DeviceIndex].FormulaOption)

        {

          TXBuffer += F("<TH align='left'>Formula");

          addHelpButton(F("EasyFormula"));

        }



        if (Device[DeviceIndex].FormulaOption || Device[DeviceIndex].DecimalsOnly)

        {

          TXBuffer += F("<TH style='width:30px;' align='left'>Decimals");

        }





        for (byte varNr = 0; varNr < Device[DeviceIndex].ValueCount; varNr++)

        {

          html_TR_TD();

          TXBuffer += varNr + 1;

          html_TD();

          String id = F("TDVN");

          id += (varNr + 1);

          addTextBox(id, ExtraTaskSettings.TaskDeviceValueNames[varNr], NAME_FORMULA_LENGTH_MAX);



          if (Device[DeviceIndex].FormulaOption)

          {

            html_TD();

            String id = F("TDF");

            id += (varNr + 1);

            addTextBox(id, ExtraTaskSettings.TaskDeviceFormula[varNr], NAME_FORMULA_LENGTH_MAX);

          }



          if (Device[DeviceIndex].FormulaOption || Device[DeviceIndex].DecimalsOnly)

          {

            html_TD();

            String id = F("TDVD");

            id += (varNr + 1);

            addNumericBox(id, ExtraTaskSettings.TaskDeviceValueDecimals[varNr], 0, 6);

          }

        }

      }

    }



    addFormSeparator(4);



    html_TR_TD();

    TXBuffer += F("<TD colspan='3'><a class='button link' href=\"devices?setpage=");

    TXBuffer += page;

    TXBuffer += F("\">Close</a>");

    addSubmitButton();

    TXBuffer += F("<input type='hidden' name='edit' value='1'>");

    TXBuffer += F("<input type='hidden' name='page' value='1'>");





    if (Settings.TaskDeviceNumber[taskIndex] != 0 )

      addSubmitButton(F("Delete"), F("del"));



    TXBuffer += F("</table></form>");

  }





  checkRAM(F("handle_devices"));

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_DEV)) {

    String log = F("DEBUG: String size:");

    log += String(TXBuffer.sentBytes);

    addLog(LOG_LEVEL_DEBUG_DEV, log);

  }

  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

}





byte sortedIndex[DEVICES_MAX + 1];







void addDeviceSelect(String name, int choice)

{



  for (byte x = 0; x <= deviceCount; x++)

    sortedIndex[x] = x;

  sortDeviceArray();



  String deviceName;



  addSelector_Head(name, true);

  addSelector_Item(F("- None -"), 0, false, false, F(""));

  for (byte x = 0; x <= deviceCount; x++)

  {

    byte deviceIndex = sortedIndex[x];

    if (Plugin_id[deviceIndex] != 0)

      deviceName = getPluginNameFromDeviceIndex(deviceIndex);



#ifdef PLUGIN_BUILD_DEV

    int num = Plugin_id[deviceIndex];

    String plugin = F("P");

    if (num < 10) plugin += F("0");

    if (num < 100) plugin += F("0");

    plugin += num;

    plugin += F(" - ");

    deviceName = plugin + deviceName;

#endif



    addSelector_Item(deviceName,

                     Device[deviceIndex].Number,

                     choice == Device[deviceIndex].Number,

                     false,

                     F(""));

  }

  addSelector_Foot();

}
# 4853 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void switchArray(byte value)

{

  byte temp;

  temp = sortedIndex[value - 1];

  sortedIndex[value - 1] = sortedIndex[value];

  sortedIndex[value] = temp;

}
# 4877 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
boolean arrayLessThan(const String& ptr_1, const String& ptr_2)

{

  unsigned int i = 0;

  while (i < ptr_1.length())

  {

    if (ptr_2.length() < i)

    {

      return true;

    }

    else

    {

      const char check1 = (char)ptr_1[i];

      const char check2 = (char)ptr_2[i];

      if (check1 == check2) {



        i++;

      } else {

        return (check2 > check1);

      }

    }

  }

  return false;

}
# 4933 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void sortDeviceArray()

{

  int innerLoop ;

  int mainLoop ;

  for ( mainLoop = 1; mainLoop <= deviceCount; mainLoop++)

  {

    innerLoop = mainLoop;

    while (innerLoop >= 1)

    {

      if (arrayLessThan(

        getPluginNameFromDeviceIndex(sortedIndex[innerLoop]),

        getPluginNameFromDeviceIndex(sortedIndex[innerLoop - 1])))

      {

        switchArray(innerLoop);

      }

      innerLoop--;

    }

  }

}



void addFormPinSelect(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addPinSelect(false, id, choice);

}





void addFormPinSelectI2C(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addPinSelect(true, id, choice);

}
# 5007 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
#if defined(ESP8285)
# 5019 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addPinSelect(boolean forI2C, String name, int choice)

{

  String options[18];

  options[0] = F("- None -");

  options[1] = F("GPIO-0 (D3)");

  options[2] = F("GPIO-1 (D10)");

  options[3] = F("GPIO-2 (D4)");

  options[4] = F("GPIO-3 (D9)");

  options[5] = F("GPIO-4 (D2)");

  options[6] = F("GPIO-5 (D1)");

  options[7] = F("GPIO-6");

  options[8] = F("GPIO-7");

  options[9] = F("GPIO-8");

  options[10] = F("GPIO-9 (D11)");

  options[11] = F("GPIO-10 (D12)");

  options[12] = F("GPIO-11");

  options[13] = F("GPIO-12 (D6)");

  options[14] = F("GPIO-13 (D7)");

  options[15] = F("GPIO-14 (D5)");

  options[16] = F("GPIO-15 (D8)");

  options[17] = F("GPIO-16 (D0)");

  int optionValues[18];

  optionValues[0] = -1;

  optionValues[1] = 0;

  optionValues[2] = 1;

  optionValues[3] = 2;

  optionValues[4] = 3;

  optionValues[5] = 4;

  optionValues[6] = 5;

  optionValues[7] = 6;

  optionValues[8] = 7;

  optionValues[9] = 8;

  optionValues[10] = 9;

  optionValues[11] = 10;

  optionValues[12] = 11;

  optionValues[13] = 12;

  optionValues[14] = 13;

  optionValues[15] = 14;

  optionValues[16] = 15;

  optionValues[17] = 16;

  renderHTMLForPinSelect(options, optionValues, forI2C, name, choice, 18);



}



#else

#if defined(ESP8266)
# 5121 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addPinSelect(boolean forI2C, String name, int choice)

{

  String options[14];

  options[0] = F("- None -");

  options[1] = F("GPIO-0 (D3)");

  options[2] = F("GPIO-1 (D10)");

  options[3] = F("GPIO-2 (D4)");

  options[4] = F("GPIO-3 (D9)");

  options[5] = F("GPIO-4 (D2)");

  options[6] = F("GPIO-5 (D1)");

  options[7] = F("GPIO-9 (D11) " HTML_SYMBOL_WARNING);

  options[8] = F("GPIO-10 (D12)");

  options[9] = F("GPIO-12 (D6)");

  options[10] = F("GPIO-13 (D7)");

  options[11] = F("GPIO-14 (D5)");

  options[12] = F("GPIO-15 (D8)");

  options[13] = F("GPIO-16 (D0)");

  int optionValues[14];

  optionValues[0] = -1;

  optionValues[1] = 0;

  optionValues[2] = 1;

  optionValues[3] = 2;

  optionValues[4] = 3;

  optionValues[5] = 4;

  optionValues[6] = 5;

  optionValues[7] = 9;

  optionValues[8] = 10;

  optionValues[9] = 12;

  optionValues[10] = 13;

  optionValues[11] = 14;

  optionValues[12] = 15;

  optionValues[13] = 16;

  renderHTMLForPinSelect(options, optionValues, forI2C, name, choice, 14);

}

#endif



#if defined(ESP32)







void addPinSelect(boolean forI2C, String name, int choice)

{

  String * options = new String[PIN_D_MAX+1];

  int * optionValues = new int[PIN_D_MAX+1];

  options[0] = F("- None -");

  optionValues[0] = -1;

  for(byte x=1; x < PIN_D_MAX+1; x++)

  {

    options[x] = F("GPIO-");

    options[x] += x;

    optionValues[x] = x;

  }

  renderHTMLForPinSelect(options, optionValues, forI2C, name, choice, PIN_D_MAX+1);

  delete[] optionValues;

  delete[] options;

}

#endif





#endif
# 5249 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void renderHTMLForPinSelect(String options[], int optionValues[], boolean forI2C, String name, int choice, int count) {

  addSelector_Head(name, false);

  for (byte x = 0; x < count; x++)

  {

    boolean disabled = false;



    if (optionValues[x] != -1)

    {

      if (!forI2C && ((optionValues[x] == Settings.Pin_i2c_sda) || (optionValues[x] == Settings.Pin_i2c_scl)))

        disabled = true;

      if (Settings.UseSerial && ((optionValues[x] == 1) || (optionValues[x] == 3)))

        disabled = true;

    }

    addSelector_Item(options[x],

                     optionValues[x],

                     choice == optionValues[x],

                     disabled,

                     F(""));

  }

  addSelector_Foot();

}





void addFormSelectorI2C(const String& id, int addressCount, const int addresses[], int selectedIndex)

{

  String options[addressCount];

  for (byte x = 0; x < addressCount; x++)

  {

    options[x] = formatToHex_decimal(addresses[x]);

    if (x == 0)

      options[x] += F(" - (default)");

  }

  addFormSelector(F("I2C Address"), id, addressCount, options, addresses, NULL, selectedIndex, false);

}



void addFormSelector(const String& label, const String& id, int optionCount, const String options[], const int indices[], int selectedIndex)

{

  addFormSelector(label, id, optionCount, options, indices, NULL, selectedIndex, false);

}



void addFormSelector(const String& label, const String& id, int optionCount, const String options[], const int indices[], const String attr[], int selectedIndex, boolean reloadonchange)

{

  addRowLabel(label);

  addSelector(id, optionCount, options, indices, attr, selectedIndex, reloadonchange);

}



void addSelector(const String& id, int optionCount, const String options[], const int indices[], const String attr[], int selectedIndex, boolean reloadonchange)

{

  int index;



  TXBuffer += F("<select id='selectwidth' name='");

  TXBuffer += id;

  TXBuffer += F("'");

  if (reloadonchange)

    TXBuffer += F(" onchange='return dept_onchange(frmselect)'>");

  TXBuffer += F(">");

  for (byte x = 0; x < optionCount; x++)

  {

    if (indices)

      index = indices[x];

    else

      index = x;

    TXBuffer += F("<option value=");

    TXBuffer += index;

    if (selectedIndex == index)

      TXBuffer += F(" selected");

    if (attr)

    {

      TXBuffer += F(" ");

      TXBuffer += attr[x];

    }

    TXBuffer += ">";

    TXBuffer += options[x];

    TXBuffer += F("</option>");

  }

  TXBuffer += F("</select>");

}





void addSelector_Head(const String& id, boolean reloadonchange)

{

  TXBuffer += F("<select id='selectwidth' name='");

  TXBuffer += id;

  TXBuffer += F("'");

  if (reloadonchange)

    TXBuffer += F(" onchange='return dept_onchange(frmselect)'>");

  TXBuffer += F(">");

}



void addSelector_Item(const String& option, int index, boolean selected, boolean disabled, const String& attr)

{

  TXBuffer += F("<option value=");

  TXBuffer += index;

  if (selected)

    TXBuffer += F(" selected");

  if (disabled)

    TXBuffer += F(" disabled");

  if (attr && attr.length() > 0)

  {

    TXBuffer += F(" ");

    TXBuffer += attr;

  }

  TXBuffer += ">";

  TXBuffer += option;

  TXBuffer += F("</option>");

}





void addSelector_Foot()

{

  TXBuffer += F("</select>");

}





void addUnit(const String& unit)

{

  TXBuffer += F(" [");

  TXBuffer += unit;

  TXBuffer += F("]");

}





void addRowLabel(const String& label)

{

  html_TR_TD();

  TXBuffer += label;

  TXBuffer += F(":<TD>");

}



void addButton(const String &url, const String &label)

{

  TXBuffer += F("<a class='button link' href='");

  TXBuffer += url;

  TXBuffer += F("'>");

  TXBuffer += label;

  TXBuffer += F("</a>");

}



void addWideButton(const String &url, const String &label, const String &color)

{

  TXBuffer += F("<a class='button link wide");

  TXBuffer += color;

  TXBuffer += F("' href='");

  TXBuffer += url;

  TXBuffer += F("'>");

  TXBuffer += label;

  TXBuffer += F("</a>");

}



void addSubmitButton()

{

  TXBuffer += F("<input class='button link' type='submit' value='Submit'><div id='toastmessage'></div><script type='text/javascript'>toasting();</script>");

}





void addSubmitButton(const String &value, const String &name)

{

  TXBuffer += F("<input class='button link' type='submit' value='");

  TXBuffer += value;

  TXBuffer += F("' name='");

  TXBuffer += name;

  TXBuffer += F("'><div id='toastmessage'></div><script type='text/javascript'>toasting();</script>");

}





void addCopyButton(const String &value, const String &delimiter, const String &name)

{

  TXBuffer += jsClipboardCopyPart1;

  TXBuffer += value;

  TXBuffer += jsClipboardCopyPart2;

  TXBuffer += delimiter;

  TXBuffer += jsClipboardCopyPart3;



  TXBuffer += F("<button class='button link' onclick='setClipboard()'>");

  TXBuffer += name;

  TXBuffer += F("</button>");

}
# 5613 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addTableSeparator(const String& label, int colspan, int h_size) {

  addTableSeparator(label, colspan, h_size, "");

}



void addTableSeparator(const String& label, int colspan, int h_size, const String& helpButton) {

  TXBuffer += F("<TR><TD colspan=");

  TXBuffer += colspan;

  TXBuffer += "><H";

  TXBuffer += h_size;

  TXBuffer += '>';

  TXBuffer += label;

  if (helpButton.length() > 0)

    addHelpButton(helpButton);

  TXBuffer += "</H";

  TXBuffer += h_size;

  TXBuffer += F("></TD></TR>");

}



void addFormHeader(const String& header1, const String& header2)

{

  TXBuffer += F("<TR><TH>");

  TXBuffer += header1;

  TXBuffer += F("<TH>");

  TXBuffer += header2;

  TXBuffer += F("");

}



void addFormHeader(const String& header)

{

  addTableSeparator(header, 2, 2);

}
# 5685 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addFormSubHeader(const String& header)

{

  addTableSeparator(header, 2, 3);

}
# 5703 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addFormNote(const String& text)

{

  html_TR_TD();

  html_TD();

  TXBuffer += F("<div class='note'>Note: ");

  TXBuffer += text;

  TXBuffer += F("</div>");

}
# 5729 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addFormSeparator(int clspan)

{

 TXBuffer += F("<TR><TD colspan='");

 TXBuffer += clspan;

 TXBuffer += F("'><hr>");

}
# 5749 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addCheckBox(const String& id, boolean checked)

{

  TXBuffer += F("<label class='container'>&nbsp;");

  TXBuffer += F("<input type='checkbox' id='");

  TXBuffer += id;

  TXBuffer += F("' name='");

  TXBuffer += id;

  TXBuffer += F("'");

  if (checked)

    TXBuffer += F(" checked");

  TXBuffer += F("><span class='checkmark'></span></label>");

}



void addFormCheckBox(const String& label, const String& id, boolean checked)

{

  addRowLabel(label);

  addCheckBox(id, checked);

}
# 5795 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addNumericBox(const String& id, int value, int min, int max)

{

  TXBuffer += F("<input class='widenumber' type='number' name='");

  TXBuffer += id;

  TXBuffer += F("'");

  if (min != INT_MIN)

  {

    TXBuffer += F(" min=");

    TXBuffer += min;

  }

  if (max != INT_MAX)

  {

    TXBuffer += F(" max=");

    TXBuffer += max;

  }

  TXBuffer += F(" value=");

  TXBuffer += value;

  TXBuffer += F(">");

}



void addNumericBox(const String& id, int value)

{

  addNumericBox(id, value, INT_MIN, INT_MAX);

}



void addFormNumericBox(const String& label, const String& id, int value, int min, int max)

{

  addRowLabel(label);

  addNumericBox(id, value, min, max);

}



void addFormNumericBox(const String& label, const String& id, int value)

{

  addFormNumericBox(label, id, value, INT_MIN, INT_MAX);

}



void addFloatNumberBox(const String& id, float value, float min, float max)

{

  TXBuffer += F("<input type='number' name='");

  TXBuffer += id;

  TXBuffer += F("'");

  TXBuffer += F(" min=");

  TXBuffer += min;

  TXBuffer += F(" max=");

  TXBuffer += max;

  TXBuffer += F(" step=0.01");

  TXBuffer += F(" style='width:5em;' value=");

  TXBuffer += value;

  TXBuffer += F(">");

}



void addFormFloatNumberBox(const String& label, const String& id, float value, float min, float max)

{

  addRowLabel(label);

  addFloatNumberBox(id, value, min, max);

}





void addTextBox(const String& id, const String& value, int maxlength)

{

  TXBuffer += F("<input class='wide' type='text' name='");

  TXBuffer += id;

  TXBuffer += F("' maxlength=");

  TXBuffer += maxlength;

  TXBuffer += F(" value='");

  TXBuffer += value;

  TXBuffer += F("'>");

}



void addFormTextBox(const String& label, const String& id, const String& value, int maxlength)

{

  addRowLabel(label);

  addTextBox(id, value, maxlength);

}





void addFormPasswordBox(const String& label, const String& id, const String& password, int maxlength)

{

  addRowLabel(label);

  TXBuffer += F("<input class='wide' type='password' name='");

  TXBuffer += id;

  TXBuffer += F("' maxlength=");

  TXBuffer += maxlength;

  TXBuffer += F(" value='");

  if (password != F(""))

    TXBuffer += F("*****");



  TXBuffer += F("'>");

}



void copyFormPassword(const String& id, char* pPassword, int maxlength)

{

  String password = WebServer.arg(id);

  if (password == F("*****"))

    return;

  strncpy(pPassword, password.c_str(), maxlength);

}



void addFormIPBox(const String& label, const String& id, const byte ip[4])

{

  char strip[20];

  if (ip[0] == 0 && ip[1] == 0 && ip[2] == 0 && ip[3] == 0)

    strip[0] = 0;

  else {

    formatIP(ip, strip);

  }



  addRowLabel(label);

  TXBuffer += F("<input class='wide' type='text' name='");

  TXBuffer += id;

  TXBuffer += F("' value='");

  TXBuffer += strip;

  TXBuffer += F("'>");

}





void addHelpButton(const String& url)

{

  TXBuffer += F(" <a class='button help' href='");

  if (!url.startsWith(F("http"))) {

    TXBuffer += F("http://www.letscontrolit.com/wiki/index.php/");

  }

  TXBuffer += url;

  TXBuffer += F("' target='_blank'>&#10068;</a>");

}



void addEnabled(boolean enabled)

{

  if (enabled)

    TXBuffer += F("<span class='enabled on'>&#10004;</span>");

  else

    TXBuffer += F("<span class='enabled off'>&#10060;</span>");

}
# 6071 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addTaskSelect(String name, int choice)

{

  String deviceName;



  TXBuffer += F("<select id='selectwidth' name='");

  TXBuffer += name;

  TXBuffer += F("' onchange='return dept_onchange(frmselect)'>");



  for (byte x = 0; x < TASKS_MAX; x++)

  {

    deviceName = "";

    if (Settings.TaskDeviceNumber[x] != 0 )

    {

      byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[x]);



      if (Plugin_id[DeviceIndex] != 0)

        deviceName = getPluginNameFromDeviceIndex(DeviceIndex);

    }

    LoadTaskSettings(x);

    TXBuffer += F("<option value='");

    TXBuffer += x;

    TXBuffer += "'";

    if (choice == x)

      TXBuffer += F(" selected");

    if (Settings.TaskDeviceNumber[x] == 0)

      TXBuffer += F(" disabled");

    TXBuffer += ">";

    TXBuffer += x + 1;

    TXBuffer += F(" - ");

    TXBuffer += deviceName;

    TXBuffer += F(" - ");

    TXBuffer += ExtraTaskSettings.TaskDeviceName;

    TXBuffer += F("</option>");

  }

}
# 6153 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void addTaskValueSelect(String name, int choice, byte TaskIndex)

{

  TXBuffer += F("<select id='selectwidth' name='");

  TXBuffer += name;

  TXBuffer += "'>";



  byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);



  for (byte x = 0; x < Device[DeviceIndex].ValueCount; x++)

  {

    TXBuffer += F("<option value='");

    TXBuffer += x;

    TXBuffer += "'";

    if (choice == x)

      TXBuffer += F(" selected");

    TXBuffer += ">";

    TXBuffer += ExtraTaskSettings.TaskDeviceValueNames[x];

    TXBuffer += F("</option>");

  }

}
# 6205 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_log() {

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);



  TXBuffer += F("<table class=\"normal\"><TR><TH id=\"headline\" align=\"left\">Log");

  addCopyButton(F("copyText"), F(""), F("Copy log to clipboard"));

  TXBuffer += F("</TR></table><div  id='current_loglevel' style='font-weight: bold;'>Logging: </div><div class='logviewer' id='copyText_1'></div>");

  TXBuffer += F("Autoscroll: ");

  addCheckBox(F("autoscroll"), true);

  TXBuffer += F("<BR></body>");



  TXBuffer += jsFetchAndParseLog;



  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

  }
# 6249 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_log_JSON() {

  if (!isLoggedIn()) return;

  TXBuffer.startJsonStream();

  String webrequest = WebServer.arg(F("view"));

  TXBuffer += F("{\"Log\": {");

  if (webrequest == F("legend")) {

    TXBuffer += F("\"Legend\": [");

    for (byte i = 0; i < LOG_LEVEL_NRELEMENTS; ++i) {

      if (i != 0)

        TXBuffer += ',';

      TXBuffer += '{';

      int loglevel;

      stream_next_json_object_value(F("label"), getLogLevelDisplayString(i, loglevel));

      stream_last_json_object_value(F("loglevel"), String(loglevel));

    }

    TXBuffer += F("],\n");

  }

  TXBuffer += F("\"Entries\": [");

  bool logLinesAvailable = true;

  int nrEntries = 0;

  unsigned long firstTimeStamp = 0;

  unsigned long lastTimeStamp = 0;

  while (logLinesAvailable) {

    String reply = Logging.get_logjson_formatted(logLinesAvailable, lastTimeStamp);

    if (reply.length() > 0) {

      TXBuffer += reply;

      if (nrEntries == 0) {

        firstTimeStamp = lastTimeStamp;

      }

      ++nrEntries;

    }



  }

  TXBuffer += F("],\n");

  long logTimeSpan = timeDiff(firstTimeStamp, lastTimeStamp);

  long refreshSuggestion = 1000;

  long newOptimum = 1000;

  if (nrEntries > 2 && logTimeSpan > 1) {





    newOptimum = logTimeSpan * (LOG_STRUCT_MESSAGE_LINES / 2);

    newOptimum = newOptimum / (nrEntries - 1);

  }

  if (newOptimum < refreshSuggestion) refreshSuggestion = newOptimum;

  if (refreshSuggestion < 100) {



    refreshSuggestion = 100;

  }

  stream_next_json_object_value(F("TTL"), String(refreshSuggestion));

  stream_next_json_object_value(F("timeHalfBuffer"), String(newOptimum));

  stream_next_json_object_value(F("nrEntries"), String(nrEntries));

  stream_next_json_object_value(F("SettingsWebLogLevel"), String(Settings.WebLogLevel));

  stream_last_json_object_value(F("logTimeSpan"), String(logTimeSpan));

  TXBuffer += F("}\n");

  TXBuffer.endStream();

}
# 6369 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_tools() {

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);





  String webrequest = WebServer.arg(F("cmd"));



  TXBuffer += F("<form>");

  TXBuffer += F("<table class='normal'>");



  addFormHeader(F("Tools"));



  addFormSubHeader(F("Command"));

    TXBuffer += F("<TR><TD style='width: 180px'>");

    TXBuffer += F("<input class='wide' type='text' name='cmd' value='");

    TXBuffer += webrequest;

    TXBuffer += F("'>");

    html_TD();

    addSubmitButton();

    addHelpButton(F("ESPEasy_Command_Reference"));

    html_TR_TD();



    printToWeb = true;

    printWebString = "";



    if (webrequest.length() > 0)

    {

      struct EventStruct TempEvent;

      parseCommandString(&TempEvent, webrequest);

      TempEvent.Source = VALUE_SOURCE_WEB_FRONTEND;

      if (!PluginCall(PLUGIN_WRITE, &TempEvent, webrequest))

        ExecuteCommand(VALUE_SOURCE_WEB_FRONTEND, webrequest.c_str());

    }



    if (printWebString.length() > 0)

    {

      TXBuffer += F("<TR><TD colspan='2'>Command Output<BR><textarea readonly rows='10' wrap='on'>");

      TXBuffer += printWebString;

      TXBuffer += F("</textarea>");

    }



  addFormSubHeader(F("System"));



  html_TR_TD_height(30);

  addWideButton(F("/?cmd=reboot"), F("Reboot"), F(""));

  html_TD();

  TXBuffer += F("Reboots ESP");



  html_TR_TD_height(30);

  addWideButton(F("log"), F("Log"), F(""));

  html_TD();

  TXBuffer += F("Open log output");



  html_TR_TD_height(30);

  addWideButton(F("sysinfo"), F("Info"), F(""));

  html_TD();

  TXBuffer += F("Open system info page");



  html_TR_TD_height(30);

  addWideButton(F("advanced"), F("Advanced"), F(""));

  html_TD();

  TXBuffer += F("Open advanced settings");



  html_TR_TD_height(30);

  addWideButton(F("json"), F("Show JSON"), F(""));

  html_TD();

  TXBuffer += F("Open JSON output");



  html_TR_TD_height(30);

  addWideButton(F("pinstates"), F("Pin state buffer"), F(""));

  html_TD();

  TXBuffer += F("Show Pin state buffer");



  html_TR_TD_height(30);

  addWideButton(F("sysvars"), F("System Variables"), F(""));

  html_TD();

  TXBuffer += F("Show all system variables and conversions");



  addFormSubHeader(F("Wifi"));



  html_TR_TD_height(30);

  addWideButton(F("/?cmd=wificonnect"), F("Connect"), F(""));

  html_TD();

  TXBuffer += F("Connects to known Wifi network");



  html_TR_TD_height(30);

  addWideButton(F("/?cmd=wifidisconnect"), F("Disconnect"), F(""));

  html_TD();

  TXBuffer += F("Disconnect from wifi network");



  html_TR_TD_height(30);

  addWideButton(F("wifiscanner"), F("Scan"), F(""));

  html_TD();

  TXBuffer += F("Scan for wifi networks");



  addFormSubHeader(F("Interfaces"));



  html_TR_TD_height(30);

  addWideButton(F("i2cscanner"), F("I2C Scan"), F(""));

  html_TD();

  TXBuffer += F("Scan for I2C devices");



  addFormSubHeader(F("Settings"));



  html_TR_TD_height(30);

  addWideButton(F("upload"), F("Load"), F(""));

  html_TD();

  TXBuffer += F("Loads a settings file");

  addFormNote(F("(File MUST be renamed to \"config.dat\" before upload!)"));



  html_TR_TD_height(30);

  addWideButton(F("download"), F("Save"), F(""));

  html_TD();

  TXBuffer += F("Saves a settings file");



#if defined(ESP8266)

  {

    const uint32_t flashSize = getFlashRealSizeInBytes();

    if (flashSize > 524288)

    {

      addFormSubHeader(F("Firmware"));

      html_TR_TD_height(30);

      addWideButton(F("update"), F("Load"), F(""));

      addHelpButton(F("EasyOTA"));

      html_TD();

      TXBuffer += F("Load a new firmware");

      if (flashSize <= 1048576) {

        TXBuffer += F(" <b>WARNING</b> only use 2-step OTA update and sketch < 604 kB");

      }

    }

  }

#endif



  addFormSubHeader(F("Filesystem"));



  html_TR_TD_height(30);

  addWideButton(F("filelist"), F("Flash"), F(""));

  html_TD();

  TXBuffer += F("Show files on internal flash");



  html_TR_TD_height(30);

  addWideButton(F("/?cmd=reset"), F("Factory Reset"), F(" red"));

  html_TD();

  TXBuffer += F("Erase all settings files");



#ifdef FEATURE_SD

  html_TR_TD_height(30);

  addWideButton(F("SDfilelist"), F("SD Card"), F(""));

  html_TD();

  TXBuffer += F("Show files on SD-Card");

#endif



  TXBuffer += F("</table></form>");

  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

  printWebString = "";

  printToWeb = false;

}
# 6699 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_pinstates() {

  checkRAM(F("handle_pinstates"));

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);
# 6725 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
  TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TH>Plugin");

  addHelpButton(F("Official_plugin_list"));

  TXBuffer += F("<TH>GPIO<TH>Mode<TH>Value/State");

  for (byte x = 0; x < PINSTATE_TABLE_MAX; x++)

    if (pinStates[x].plugin != 0)

    {

      html_TR_TD(); TXBuffer += F("P");

      if (pinStates[x].plugin < 100)

      {

        TXBuffer += F("0");

      }

      if (pinStates[x].plugin < 10)

      {

        TXBuffer += F("0");

      }

      TXBuffer += pinStates[x].plugin;

      html_TD();

      TXBuffer += pinStates[x].index;

      html_TD();

      byte mode = pinStates[x].mode;

      switch (mode)

      {

        case PIN_MODE_UNDEFINED:

          TXBuffer += F("undefined");

          break;

        case PIN_MODE_INPUT:

          TXBuffer += F("input");

          break;

        case PIN_MODE_OUTPUT:

          TXBuffer += F("output");

          break;

        case PIN_MODE_PWM:

          TXBuffer += F("PWM");

          break;

        case PIN_MODE_SERVO:

          TXBuffer += F("servo");

          break;

      }

      html_TD();

      TXBuffer += pinStates[x].value;

    }



  TXBuffer += F("</table>");

    sendHeadandTail(F("TmplStd"),_TAIL);

    TXBuffer.endStream();

}
# 6827 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_i2cscanner() {

  checkRAM(F("handle_i2cscanner"));

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);



  char *TempString = (char*)malloc(80);







  TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TH>I2C Addresses in use<TH>Supported devices");



  byte error, address;

  int nDevices;

  nDevices = 0;

  for (address = 1; address <= 127; address++ )

  {

    Wire.beginTransmission(address);

    error = Wire.endTransmission();

    if (error == 0)

    {

      TXBuffer += "<TR><TD>";

      TXBuffer += formatToHex(address);

      TXBuffer += "<TD>";

      switch (address)

      {

        case 0x20:

        case 0x21:

        case 0x22:

        case 0x25:

        case 0x26:

        case 0x27:

          TXBuffer += F("PCF8574<BR>MCP23017<BR>LCD");

          break;

        case 0x23:

          TXBuffer += F("PCF8574<BR>MCP23017<BR>LCD<BR>BH1750");

          break;

        case 0x24:

          TXBuffer += F("PCF8574<BR>MCP23017<BR>LCD<BR>PN532");

          break;

        case 0x29:

          TXBuffer += F("TSL2561");

          break;

        case 0x38:

        case 0x3A:

        case 0x3B:

        case 0x3E:

        case 0x3F:

          TXBuffer += F("PCF8574A");

          break;

        case 0x39:

          TXBuffer += F("PCF8574A<BR>TSL2561<BR>APDS9960");

          break;

        case 0x3C:

        case 0x3D:

          TXBuffer += F("PCF8574A<BR>OLED");

          break;

        case 0x40:

          TXBuffer += F("SI7021<BR>HTU21D<BR>INA219<BR>PCA9685");

          break;

        case 0x41:

        case 0x42:

        case 0x43:

          TXBuffer += F("INA219");

          break;

        case 0x44:

        case 0x45:

          TXBuffer += F("SHT30/31/35");

          break;

        case 0x48:

        case 0x4A:

        case 0x4B:

          TXBuffer += F("PCF8591<BR>ADS1115<BR>LM75A");

          break;

        case 0x49:

          TXBuffer += F("PCF8591<BR>ADS1115<BR>TSL2561<BR>LM75A");

          break;

        case 0x4C:

        case 0x4E:

        case 0x4F:

          TXBuffer += F("PCF8591<BR>LM75A");

          break;

        case 0x4D:

          TXBuffer += F("PCF8591<BR>MCP3221<BR>LM75A");

          break;

        case 0x5A:

          TXBuffer += F("MLX90614<BR>MPR121");

          break;

        case 0x5B:

          TXBuffer += F("MPR121");

          break;

        case 0x5C:

          TXBuffer += F("DHT12<BR>AM2320<BR>BH1750<BR>MPR121");

          break;

        case 0x5D:

          TXBuffer += F("MPR121");

          break;

        case 0x60:

          TXBuffer += F("Adafruit Motorshield v2<BR>SI1145");

          break;

        case 0x70:

          TXBuffer += F("Adafruit Motorshield v2 (Catchall)<BR>HT16K33");

          break;

        case 0x71:

        case 0x72:

        case 0x73:

        case 0x74:

        case 0x75:

          TXBuffer += F("HT16K33");

          break;

        case 0x76:

          TXBuffer += F("BME280<BR>BMP280<BR>MS5607<BR>MS5611<BR>HT16K33");

          break;

        case 0x77:

          TXBuffer += F("BMP085<BR>BMP180<BR>BME280<BR>BMP280<BR>MS5607<BR>MS5611<BR>HT16K33");

          break;

        case 0x7f:

          TXBuffer += F("Arduino PME");

          break;

      }

      nDevices++;

    }

    else if (error == 4)

    {

      html_TR_TD(); TXBuffer += F("Unknown error at address ");

      TXBuffer += formatToHex(address);

    }

  }



  if (nDevices == 0)

    TXBuffer += F("<TR>No I2C devices found");



  TXBuffer += F("</table>");

  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

  free(TempString);

}
# 7113 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_wifiscanner() {

  checkRAM(F("handle_wifiscanner"));

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);

  TXBuffer += F("<table class='multirow'><TR><TH>SSID<TH>BSSID<TH>info");



  int n = WiFi.scanNetworks(false, true);

  if (n == 0)

    TXBuffer += F("No Access Points found");

  else

  {

    for (int i = 0; i < n; ++i)

    {

      html_TR_TD();

      TXBuffer += formatScanResult(i, "<TD>");

    }

  }



  TXBuffer += F("</table>");

  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

}
# 7171 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_login() {

  checkRAM(F("handle_login"));

  if (!clientIPallowed()) return;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"),_HEAD);



  String webrequest = WebServer.arg(F("password"));

  char command[80];

  command[0] = 0;

  webrequest.toCharArray(command, 80);





  TXBuffer += F("<form method='post'>");

  TXBuffer += F("<table class='normal'><TR><TD>Password<TD>");

  TXBuffer += F("<input class='wide' type='password' name='password' value='");

  TXBuffer += webrequest;

  TXBuffer += F("'>");

  html_TR_TD();

  html_TD();

  addSubmitButton();

  html_TR_TD();

  TXBuffer += F("</table></form>");



  if (webrequest.length() != 0)

  {



    if ((strcasecmp(command, SecuritySettings.Password) == 0) || (SecuritySettings.Password[0] == 0))

    {

      WebLoggedIn = true;

      WebLoggedInTimer = 0;

      TXBuffer = F("<script>window.location = '.'</script>");

    }

    else

    {

      TXBuffer += F("Invalid password!");

      if (Settings.UseRules)

      {

        String event = F("Login#Failed");

        rulesProcessing(event);

      }

    }

  }



  sendHeadandTail(F("TmplStd"),_TAIL);

  TXBuffer.endStream();

  printWebString = "";

  printToWeb = false;

}
# 7277 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_control() {

  checkRAM(F("handle_control"));

  if (!clientIPallowed()) return;





  String webrequest = WebServer.arg(F("cmd"));





  String command = parseString(webrequest, 1);

  if (command == F("event"))

  {

    eventBuffer = webrequest.substring(6);

    WebServer.send(200, "text/html", "OK");

    return;

  }

  else if (command.equalsIgnoreCase(F("taskrun")) ||

           command.equalsIgnoreCase(F("taskvalueset")) ||

           command.equalsIgnoreCase(F("rules"))) {

    addLog(LOG_LEVEL_INFO,String(F("HTTP : ")) + webrequest);

    ExecuteCommand(VALUE_SOURCE_HTTP,webrequest.c_str());

    WebServer.send(200, "text/html", "OK");

    return;

  }



  struct EventStruct TempEvent;

  parseCommandString(&TempEvent, webrequest);

  TempEvent.Source = VALUE_SOURCE_HTTP;



  printToWeb = true;

  printWebString = "";



  if (printToWebJSON)

    TXBuffer.startJsonStream();

  else

    TXBuffer.startStream();



  if (PluginCall(PLUGIN_WRITE, &TempEvent, webrequest));

  else if (remoteConfig(&TempEvent, webrequest));

  else

    TXBuffer += F("Unknown or restricted command!");



  TXBuffer += printWebString;

  TXBuffer.endStream();



  printWebString = "";

  printToWeb = false;

  printToWebJSON = false;

}
# 7383 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void stream_to_json_object_value(const String& object, const String& value) {

  TXBuffer += F("\"");

  TXBuffer += object;

  TXBuffer += F("\":");

  if (value.length() == 0 || !isFloat(value)) {

    TXBuffer += F("\"");

    TXBuffer += value;

    TXBuffer += F("\"");

  } else {

    TXBuffer += value;

  }

}



String jsonBool(bool value) {

  return toString(value);

}





void stream_next_json_object_value(const String& object, const String& value) {

  TXBuffer += to_json_object_value(object, value);

  TXBuffer += ",\n";

}





void stream_last_json_object_value(const String& object, const String& value) {

  TXBuffer += to_json_object_value(object, value);

  TXBuffer += "\n}";

}
# 7449 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_json()

{

  const int taskNr = getFormItemInt(F("tasknr"), -1);

  const bool showSpecificTask = taskNr > 0;

  bool showSystem = true;

  bool showWifi = true;

  bool showDataAcquisition = true;

  bool showTaskDetails = true;

  bool showNodes = true;

  {

    String view = WebServer.arg("view");

    if (view.length() != 0) {

      if (view == F("sensorupdate")) {

        showSystem = false;

        showWifi = false;

        showDataAcquisition = false;

        showTaskDetails = false;

        showNodes =false;

      }

    }

  }

  TXBuffer.startJsonStream();

  if (!showSpecificTask)

  {

    TXBuffer += '{';

    if (showSystem) {

      TXBuffer += F("\"System\":{\n");

      stream_next_json_object_value(F("Build"), String(BUILD));

      stream_next_json_object_value(F("Git Build"), String(BUILD_GIT));

      stream_next_json_object_value(F("System libraries"), getSystemLibraryString());

      stream_next_json_object_value(F("Plugins"), String(deviceCount + 1));

      stream_next_json_object_value(F("Plugin description"), getPluginDescriptionString());

      stream_next_json_object_value(F("Local time"), getDateTimeString('-',':',' '));

      stream_next_json_object_value(F("Unit"), String(Settings.Unit));

      stream_next_json_object_value(F("Name"), String(Settings.Name));

      stream_next_json_object_value(F("Uptime"), String(wdcounter / 2));

      stream_next_json_object_value(F("Last boot cause"), getLastBootCauseString());

      stream_next_json_object_value(F("Reset Reason"), getResetReasonString());



      if (wdcounter > 0)

      {

          stream_next_json_object_value(F("Load"), String(getCPUload()));

          stream_next_json_object_value(F("Load LC"), String(getLoopCountPerSec()));

      }



      stream_last_json_object_value(F("Free RAM"), String(ESP.getFreeHeap()));

      TXBuffer += F(",\n");

    }

    if (showWifi) {

      TXBuffer += F("\"WiFi\":{\n");

      #if defined(ESP8266)

        stream_next_json_object_value(F("Hostname"), WiFi.hostname());

      #endif

      stream_next_json_object_value(F("IP config"), useStaticIP() ? F("Static") : F("DHCP"));

      stream_next_json_object_value(F("IP"), WiFi.localIP().toString());

      stream_next_json_object_value(F("Subnet Mask"), WiFi.subnetMask().toString());

      stream_next_json_object_value(F("Gateway IP"), WiFi.gatewayIP().toString());

      stream_next_json_object_value(F("MAC address"), WiFi.macAddress());

      stream_next_json_object_value(F("DNS 1"), WiFi.dnsIP(0).toString());

      stream_next_json_object_value(F("DNS 2"), WiFi.dnsIP(1).toString());

      stream_next_json_object_value(F("SSID"), WiFi.SSID());

      stream_next_json_object_value(F("BSSID"), WiFi.BSSIDstr());

      stream_next_json_object_value(F("Channel"), String(WiFi.channel()));

      stream_next_json_object_value(F("Connected msec"), String(timeDiff(lastConnectMoment, millis())));

      stream_next_json_object_value(F("Last Disconnect Reason"), String(lastDisconnectReason));

      stream_next_json_object_value(F("Last Disconnect Reason str"), getLastDisconnectReason());

      stream_next_json_object_value(F("Number reconnects"), String(wifi_reconnects));

      stream_last_json_object_value(F("RSSI"), String(WiFi.RSSI()));

      TXBuffer += F(",\n");

    }

    if(showNodes) {

      bool comma_between=false;

      for (NodesMap::iterator it = Nodes.begin(); it != Nodes.end(); ++it)

      {

        if (it->second.ip[0] != 0)

        {



          char ip[20];



          sprintf_P(ip, PSTR("%u.%u.%u.%u"), it->second.ip[0], it->second.ip[1], it->second.ip[2], it->second.ip[3]);



          if( comma_between ) {

            TXBuffer += F(",");

          } else {

            comma_between=true;

            TXBuffer += F("\"nodes\":[\n");

          }



          TXBuffer += F("{");

          stream_next_json_object_value(F("nr"), String(it->first));

          stream_next_json_object_value(F("name"),

              (it->first != Settings.Unit) ? it->second.nodeName : Settings.Name);



          if (it->second.build) {

            stream_next_json_object_value(F("build"), String(it->second.build));

          }



          if (it->second.nodeType) {

            String platform;

            switch (it->second.nodeType)

            {

              case NODE_TYPE_ID_ESP_EASY_STD: platform = F("ESP Easy"); break;

              case NODE_TYPE_ID_ESP_EASYM_STD: platform = F("ESP Easy Mega"); break;

              case NODE_TYPE_ID_ESP_EASY32_STD: platform = F("ESP Easy 32"); break;

              case NODE_TYPE_ID_ARDUINO_EASY_STD: platform = F("Arduino Easy"); break;

              case NODE_TYPE_ID_NANO_EASY_STD: platform = F("Nano Easy"); break;

            }

            if (platform.length() > 0)

              stream_next_json_object_value(F("platform"), platform);

          }

          stream_next_json_object_value(F("ip"), ip);

          stream_last_json_object_value(F("age"), String( it->second.age ));

        }

      }

      if(comma_between) {

        TXBuffer += F("],\n");

      }

    }

  }



  byte firstTaskIndex = 0;

  byte lastTaskIndex = TASKS_MAX - 1;

  if (showSpecificTask)

  {

    firstTaskIndex = taskNr - 1;

    lastTaskIndex = taskNr - 1;

  }

  byte lastActiveTaskIndex = 0;

  for (byte TaskIndex = firstTaskIndex; TaskIndex <= lastTaskIndex; TaskIndex++) {

    if (Settings.TaskDeviceNumber[TaskIndex])

      lastActiveTaskIndex = TaskIndex;

  }



  if (!showSpecificTask) TXBuffer += F("\"Sensors\":[\n");

  unsigned long ttl_json = 60;

  for (byte TaskIndex = firstTaskIndex; TaskIndex <= lastActiveTaskIndex; TaskIndex++)

  {

    if (Settings.TaskDeviceNumber[TaskIndex])

    {

      byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[TaskIndex]);

      const unsigned long taskInterval = Settings.TaskDeviceTimer[TaskIndex];

      LoadTaskSettings(TaskIndex);

      TXBuffer += F("{\n");



      if (Device[DeviceIndex].ValueCount != 0) {

        if (ttl_json > taskInterval && taskInterval > 0 && Settings.TaskDeviceEnabled[TaskIndex]) {

          ttl_json = taskInterval;

        }

        TXBuffer += F("\"TaskValues\": [\n");

        for (byte x = 0; x < Device[DeviceIndex].ValueCount; x++)

        {

          TXBuffer += F("{");

          stream_next_json_object_value(F("ValueNumber"), String(x + 1));

          stream_next_json_object_value(F("Name"), String(ExtraTaskSettings.TaskDeviceValueNames[x]));

          stream_next_json_object_value(F("NrDecimals"), String(ExtraTaskSettings.TaskDeviceValueDecimals[x]));

          stream_last_json_object_value(F("Value"), formatUserVarNoCheck(TaskIndex, x));

          if (x < (Device[DeviceIndex].ValueCount - 1))

            TXBuffer += F(",\n");

        }

        TXBuffer += F("],\n");

      }

      if (showSpecificTask) {

        stream_next_json_object_value(F("TTL"), String(ttl_json * 1000));

      }

      if (showDataAcquisition) {

        TXBuffer += F("\"DataAcquisition\": [\n");

        for (byte x = 0; x < CONTROLLER_MAX; x++)

        {

          TXBuffer += F("{");

          stream_next_json_object_value(F("Controller"), String(x + 1));

          stream_next_json_object_value(F("IDX"), String(Settings.TaskDeviceID[x][TaskIndex]));

          stream_last_json_object_value(F("Enabled"), jsonBool(Settings.TaskDeviceSendData[x][TaskIndex]));

          if (x < (CONTROLLER_MAX - 1))

            TXBuffer += F(",\n");

        }

        TXBuffer += F("],\n");

      }

      if (showTaskDetails) {

        stream_next_json_object_value(F("TaskInterval"), String(taskInterval));

        stream_next_json_object_value(F("Type"), getPluginNameFromDeviceIndex(DeviceIndex));

        stream_next_json_object_value(F("TaskName"), String(ExtraTaskSettings.TaskDeviceName));

      }

      stream_next_json_object_value(F("TaskEnabled"), jsonBool(Settings.TaskDeviceEnabled[TaskIndex]));

      stream_last_json_object_value(F("TaskNumber"), String(TaskIndex + 1));

      if (TaskIndex != lastActiveTaskIndex)

        TXBuffer += F(",");

      TXBuffer += F("\n");

    }

  }

  if (!showSpecificTask) {

    TXBuffer += F("],\n");

    stream_last_json_object_value(F("TTL"), String(ttl_json * 1000));

  }



  TXBuffer.endStream();

}
# 7849 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_advanced() {

  checkRAM(F("handle_advanced"));

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));



  char tmpString[81];



  String ip = WebServer.arg(F("ip"));

  String syslogip = WebServer.arg(F("syslogip"));

  String ntphost = WebServer.arg(F("ntphost"));

  int timezone = getFormItemInt(F("timezone"));

  int dststartweek = getFormItemInt(F("dststartweek"));

  int dststartdow = getFormItemInt(F("dststartdow"));

  int dststartmonth = getFormItemInt(F("dststartmonth"));

  int dststarthour = getFormItemInt(F("dststarthour"));

  int dstendweek = getFormItemInt(F("dstendweek"));

  int dstenddow = getFormItemInt(F("dstenddow"));

  int dstendmonth = getFormItemInt(F("dstendmonth"));

  int dstendhour = getFormItemInt(F("dstendhour"));

  String edit = WebServer.arg(F("edit"));





  if (edit.length() != 0)

  {

    Settings.MessageDelay = getFormItemInt(F("messagedelay"));

    Settings.IP_Octet = ip.toInt();

    ntphost.toCharArray(tmpString, 64);

    strcpy(Settings.NTPHost, tmpString);

    Settings.TimeZone = timezone;

    TimeChangeRule dst_start(dststartweek, dststartdow, dststartmonth, dststarthour, timezone);

    if (dst_start.isValid()) { Settings.DST_Start = dst_start.toFlashStoredValue(); }

    TimeChangeRule dst_end(dstendweek, dstenddow, dstendmonth, dstendhour, timezone);

    if (dst_end.isValid()) { Settings.DST_End = dst_end.toFlashStoredValue(); }

    str2ip(syslogip.c_str(), Settings.Syslog_IP);

    Settings.UDPPort = getFormItemInt(F("udpport"));



    Settings.SyslogFacility = getFormItemInt(F("syslogfacility"));

    Settings.UseSerial = isFormItemChecked(F("useserial"));

    setLogLevelFor(LOG_TO_SYSLOG, getFormItemInt(F("sysloglevel")));

    setLogLevelFor(LOG_TO_SERIAL, getFormItemInt(F("serialloglevel")));

    setLogLevelFor(LOG_TO_WEBLOG, getFormItemInt(F("webloglevel")));

    setLogLevelFor(LOG_TO_SDCARD, getFormItemInt(F("sdloglevel")));

    Settings.UseValueLogger = isFormItemChecked(F("valuelogger"));

    Settings.BaudRate = getFormItemInt(F("baudrate"));

    Settings.UseNTP = isFormItemChecked(F("usentp"));

    Settings.DST = isFormItemChecked(F("dst"));

    Settings.WDI2CAddress = getFormItemInt(F("wdi2caddress"));

    Settings.UseSSDP = isFormItemChecked(F("usessdp"));

    Settings.WireClockStretchLimit = getFormItemInt(F("wireclockstretchlimit"));

    Settings.UseRules = isFormItemChecked(F("userules"));

    Settings.ConnectionFailuresThreshold = getFormItemInt(F("cft"));

    Settings.MQTTRetainFlag = isFormItemChecked(F("mqttretainflag"));

    Settings.ArduinoOTAEnable = isFormItemChecked(F("arduinootaenable"));

    Settings.UseRTOSMultitasking = isFormItemChecked(F("usertosmultitasking"));

    Settings.MQTTUseUnitNameAsClientId = isFormItemChecked(F("mqttuseunitnameasclientid"));

    Settings.Latitude = getFormItemFloat(F("latitude"));

    Settings.Longitude = getFormItemFloat(F("longitude"));



    addHtmlError(SaveSettings());

    if (Settings.UseNTP)

      initTime();

  }







  TXBuffer += F("<form  method='post'><table class='normal'>");



  addFormHeader(F("Advanced Settings"));



  addFormCheckBox(F("Rules"), F("userules"), Settings.UseRules);



  addFormSubHeader(F("Controller Settings"));



  addFormCheckBox(F("MQTT Retain Msg"), F("mqttretainflag"), Settings.MQTTRetainFlag);

  addFormNumericBox( F("Message Interval"), F("messagedelay"), Settings.MessageDelay, 0, INT_MAX);

  addUnit(F("ms"));

  addFormCheckBox(F("MQTT usage unit name as ClientId"), F("mqttuseunitnameasclientid"), Settings.MQTTUseUnitNameAsClientId);



  addFormSubHeader(F("NTP Settings"));



  addFormCheckBox(F("Use NTP"), F("usentp"), Settings.UseNTP);

  addFormTextBox( F("NTP Hostname"), F("ntphost"), Settings.NTPHost, 63);



  addFormSubHeader(F("DST Settings"));

  addFormDstSelect(true, Settings.DST_Start);

  addFormDstSelect(false, Settings.DST_End);

  addFormNumericBox(F("Timezone Offset (UTC +)"), F("timezone"), Settings.TimeZone, -720, 840);

  addUnit(F("minutes"));

  addFormCheckBox(F("DST"), F("dst"), Settings.DST);



  addFormSubHeader(F("Location Settings"));

  addFormFloatNumberBox(F("Latitude"), F("latitude"), Settings.Latitude, -90.0, 90.0);

  addUnit(F("&deg;"));

  addFormFloatNumberBox(F("Longitude"), F("longitude"), Settings.Longitude, -180.0, 180.0);

  addUnit(F("&deg;"));



  addFormSubHeader(F("Log Settings"));



  addFormIPBox(F("Syslog IP"), F("syslogip"), Settings.Syslog_IP);

  addFormLogLevelSelect(F("Syslog Level"), F("sysloglevel"), Settings.SyslogLevel);

  addFormLogFacilitySelect(F("Syslog Facility"),F("syslogfacility"), Settings.SyslogFacility);

  addFormLogLevelSelect(F("Serial log Level"), F("serialloglevel"), Settings.SerialLogLevel);

  addFormLogLevelSelect(F("Web log Level"), F("webloglevel"), Settings.WebLogLevel);



#ifdef FEATURE_SD

  addFormLogLevelSelect(F("SD Card log Level"), F("sdloglevel"), Settings.SDLogLevel);



  addFormCheckBox(F("SD Card Value Logger"), F("valuelogger"), Settings.UseValueLogger);

#endif





  addFormSubHeader(F("Serial Settings"));



  addFormCheckBox(F("Enable Serial port"), F("useserial"), Settings.UseSerial);

  addFormNumericBox(F("Baud Rate"), F("baudrate"), Settings.BaudRate, 0, 1000000);





  addFormSubHeader(F("Inter-ESPEasy Network"));



  addFormNumericBox(F("UDP port"), F("udpport"), Settings.UDPPort, 0, 65535);







  addFormSubHeader(F("Special and Experimental Settings"));



  addFormNumericBox(F("Fixed IP Octet"), F("ip"), Settings.IP_Octet, 0, 255);



  addFormNumericBox(F("WD I2C Address"), F("wdi2caddress"), Settings.WDI2CAddress, 0, 127);

  TXBuffer += F(" (decimal)");



  addFormCheckBox(F("Use SSDP"), F("usessdp"), Settings.UseSSDP);



  addFormNumericBox(F("Connection Failure Threshold"), F("cft"), Settings.ConnectionFailuresThreshold, 0, 100);



  addFormNumericBox(F("I2C ClockStretchLimit"), F("wireclockstretchlimit"), Settings.WireClockStretchLimit);

  #if defined(FEATURE_ARDUINO_OTA)

  addFormCheckBox(F("Enable Arduino OTA"), F("arduinootaenable"), Settings.ArduinoOTAEnable);

  #endif

  #if defined(ESP32)

    addFormCheckBox(F("Enable RTOS Multitasking"), F("usertosmultitasking"), Settings.UseRTOSMultitasking);

  #endif



  addFormSeparator(2);



  TXBuffer += F("<TR><TD style='width:150px;' align='left'><TD>");

  addSubmitButton();

  TXBuffer += F("<input type='hidden' name='edit' value='1'>");

  TXBuffer += F("</table></form>");

  sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();

}



void addFormDstSelect(bool isStart, uint16_t choice) {

  String weekid = isStart ? F("dststartweek") : F("dstendweek");

  String dowid = isStart ? F("dststartdow") : F("dstenddow");

  String monthid = isStart ? F("dststartmonth") : F("dstendmonth");

  String hourid = isStart ? F("dststarthour") : F("dstendhour");



  String weeklabel = isStart ? F("Start (week, dow, month)") : F("End (week, dow, month)");

  String hourlabel = isStart ? F("Start (localtime, e.g. 2h&rarr;3h)") : F("End (localtime, e.g. 3h&rarr;2h)");



  String week[5] = {F("Last"), F("1st"), F("2nd"), F("3rd"), F("4th")};

  int weekValues[5] = {0, 1, 2, 3, 4};

  String dow[7] = {F("Sun"), F("Mon"), F("Tue"), F("Wed"), F("Thu"), F("Fri"), F("Sat")};

  int dowValues[7] = {1, 2, 3, 4, 5, 6, 7};

  String month[12] = {F("Jan"), F("Feb"), F("Mar"), F("Apr"), F("May"), F("Jun"), F("Jul"), F("Aug"), F("Sep"), F("Oct"), F("Nov"), F("Dec")};

  int monthValues[12] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};



  uint16_t tmpstart(choice);

  uint16_t tmpend(choice);

  if (!TimeChangeRule(choice, 0).isValid()) {

    getDefaultDst_flash_values(tmpstart, tmpend);

  }

  TimeChangeRule rule(isStart ? tmpstart : tmpend, 0);

  addRowLabel(weeklabel);

  addSelector(weekid, 5, week, weekValues, NULL, rule.week, false);

  TXBuffer += F("<BR>");

  addSelector(dowid, 7, dow, dowValues, NULL, rule.dow, false);

  TXBuffer += F("<BR>");

  addSelector(monthid, 12, month, monthValues, NULL, rule.month, false);



  addFormNumericBox(hourlabel, hourid, rule.hour, 0, 23);

  addUnit(isStart ? F("hour &#x21b7;") : F("hour &#x21b6;"));

}



void addFormLogLevelSelect(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addLogLevelSelect(id, choice);

}



void addLogLevelSelect(String name, int choice)

{

  String options[LOG_LEVEL_NRELEMENTS + 1];

  int optionValues[LOG_LEVEL_NRELEMENTS + 1] = {0};

  options[0] = F("None");

  optionValues[0] = 0;

  for (int i = 0; i < LOG_LEVEL_NRELEMENTS; ++i) {

    options[i + 1] = getLogLevelDisplayString(i, optionValues[i + 1]);

  }

  addSelector(name, LOG_LEVEL_NRELEMENTS + 1, options, optionValues, NULL, choice, false);

}



void addFormLogFacilitySelect(const String& label, const String& id, int choice)

{

  addRowLabel(label);

  addLogFacilitySelect(id, choice);

}



void addLogFacilitySelect(String name, int choice)

{

  String options[12] = { F("Kernel"), F("User"), F("Daemon"), F("Message"), F("Local0"), F("Local1"), F("Local2"), F("Local3"), F("Local4"), F("Local5"), F("Local6"), F("Local7")};

  int optionValues[12] = { 0, 1, 3, 5, 16, 17, 18, 19, 20, 21, 22, 23 };

  addSelector(name, 12, options, optionValues, NULL, choice, false);

}
# 8293 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
boolean isLoggedIn()

{

  if (!clientIPallowed()) return false;

  if (SecuritySettings.Password[0] == 0)

    WebLoggedIn = true;



  if (!WebLoggedIn)

  {

    WebServer.sendContent(F("HTTP/1.1 302 \r\nLocation: /login\r\n"));

  }

  else

  {

    WebLoggedInTimer = 0;

  }



  return WebLoggedIn;

}
# 8337 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_download()

{

  checkRAM(F("handle_download"));

  if (!isLoggedIn()) return;

  navMenuIndex = 7;
# 8355 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
  fs::File dataFile = SPIFFS.open(F(FILE_CONFIG), "r");

  if (!dataFile)

    return;



  String str = F("attachment; filename=config_");

  str += Settings.Name;

  str += "_U";

  str += Settings.Unit;

  str += F("_Build");

  str += BUILD;

  str += F("_");

  if (Settings.UseNTP)

  {

    str += getDateTimeString('\0', '\0', '\0');

  }

  str += F(".dat");



  WebServer.sendHeader(F("Content-Disposition"), str);

  WebServer.streamFile(dataFile, F("application/octet-stream"));

}
# 8405 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
byte uploadResult = 0;

void handle_upload() {

  if (!isLoggedIn()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));



  TXBuffer += F("<form enctype='multipart/form-data' method='post'><p>Upload settings file:<br><input type='file' name='datafile' size='40'></p><div><input class='button link' type='submit' value='Upload'></div><input type='hidden' name='edit' value='1'></form>");

  sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();

  printWebString = "";

  printToWeb = false;

}
# 8441 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_upload_post() {

  checkRAM(F("handle_upload_post"));

  if (!isLoggedIn()) return;



  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));







  if (uploadResult == 1)

  {

    TXBuffer += F("Upload OK!<BR>You may need to reboot to apply all settings...");

    LoadSettings();

  }



  if (uploadResult == 2)

    TXBuffer += F("<font color=\"red\">Upload file invalid!</font>");



  if (uploadResult == 3)

    TXBuffer += F("<font color=\"red\">No filename!</font>");





  TXBuffer += F("Upload finished");

  sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();

  printWebString = "";

  printToWeb = false;

}
# 8509 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
fs::File uploadFile;

void handleFileUpload() {

  checkRAM(F("handleFileUpload"));

  if (!isLoggedIn()) return;



  static boolean valid = false;



  HTTPUpload& upload = WebServer.upload();



  if (upload.filename.c_str()[0] == 0)

  {

    uploadResult = 3;

    return;

  }



  if (upload.status == UPLOAD_FILE_START)

  {

    if (loglevelActiveFor(LOG_LEVEL_INFO)) {

      String log = F("Upload: START, filename: ");

      log += upload.filename;

      addLog(LOG_LEVEL_INFO, log);

    }

    valid = false;

    uploadResult = 0;

  }

  else if (upload.status == UPLOAD_FILE_WRITE)

  {



    if (upload.totalSize == 0)

    {

      if (strcasecmp(upload.filename.c_str(), FILE_CONFIG) == 0)

      {

        struct TempStruct {

          unsigned long PID;

          int Version;

        } Temp;

        for (unsigned int x = 0; x < sizeof(struct TempStruct); x++)

        {

          byte b = upload.buf[x];

          memcpy((byte*)&Temp + x, &b, 1);

        }

        if (Temp.Version == VERSION && Temp.PID == ESP_PROJECT_PID)

          valid = true;

      }

      else

      {



        valid = true;

      }

      if (valid)

      {



        SPIFFS.remove((char *)upload.filename.c_str());

        uploadFile = SPIFFS.open(upload.filename.c_str(), "w");



      }

    }

    if (uploadFile) uploadFile.write(upload.buf, upload.currentSize);

    if (loglevelActiveFor(LOG_LEVEL_INFO)) {

      String log = F("Upload: WRITE, Bytes: ");

      log += upload.currentSize;

      addLog(LOG_LEVEL_INFO, log);

    }

  }

  else if (upload.status == UPLOAD_FILE_END)

  {

    if (uploadFile) uploadFile.close();

    if (loglevelActiveFor(LOG_LEVEL_INFO)) {

      String log = F("Upload: END, Size: ");

      log += upload.totalSize;

      addLog(LOG_LEVEL_INFO, log);

    }

  }



  if (valid)

    uploadResult = 1;

  else

    uploadResult = 2;



}
# 8679 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
bool loadFromFS(boolean spiffs, String path) {

  checkRAM(F("loadFromFS"));

  if (!isLoggedIn()) return false;



  statusLED(true);



  String dataType = F("text/plain");

  if (path.endsWith(F("/"))) path += F("index.htm");



  if (path.endsWith(F(".src"))) path = path.substring(0, path.lastIndexOf("."));

  else if (path.endsWith(F(".htm"))) dataType = F("text/html");

  else if (path.endsWith(F(".css"))) dataType = F("text/css");

  else if (path.endsWith(F(".js"))) dataType = F("application/javascript");

  else if (path.endsWith(F(".png"))) dataType = F("image/png");

  else if (path.endsWith(F(".gif"))) dataType = F("image/gif");

  else if (path.endsWith(F(".jpg"))) dataType = F("image/jpeg");

  else if (path.endsWith(F(".ico"))) dataType = F("image/x-icon");

  else if (path.endsWith(F(".txt"))) dataType = F("application/octet-stream");

  else if (path.endsWith(F(".dat"))) dataType = F("application/octet-stream");

  else if (path.endsWith(F(".esp"))) return handle_custom(path);

  if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {

    String log = F("HTML : Request file ");

    log += path;

    addLog(LOG_LEVEL_DEBUG, log);

  }



  path = path.substring(1);

  if (spiffs)

  {

    fs::File dataFile = SPIFFS.open(path.c_str(), "r");

    if (!dataFile)

      return false;





    WebServer.sendHeader(F("Cache-Control"), F("max-age=3600, public"));

    WebServer.sendHeader(F("Vary"),"*");

    WebServer.sendHeader(F("ETag"), F("\"2.0.0\""));



    if (path.endsWith(F(".dat")))

      WebServer.sendHeader(F("Content-Disposition"), F("attachment;"));

    WebServer.streamFile(dataFile, dataType);

    dataFile.close();

  }

  else

  {

#ifdef FEATURE_SD

    File dataFile = SD.open(path.c_str());

    if (!dataFile)

      return false;

    if (path.endsWith(F(".DAT")))

      WebServer.sendHeader(F("Content-Disposition"), F("attachment;"));

    WebServer.streamFile(dataFile, dataType);

    dataFile.close();

#endif

  }

  statusLED(true);

  return true;

}
# 8803 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
boolean handle_custom(String path) {

  checkRAM(F("handle_custom"));

  if (!clientIPallowed()) return false;

  path = path.substring(1);





  fs::File dataFile = SPIFFS.open(path.c_str(), "r");

  const bool dashboardPage = path.startsWith(F("dashboard"));

  if (!dataFile && !dashboardPage) {

    return false;

  }



  if (dashboardPage)

  {



    byte unit = getFormItemInt(F("unit"));

    byte btnunit = getFormItemInt(F("btnunit"));

    if(!unit) unit = btnunit;

    if (unit && unit != Settings.Unit)

    {

      NodesMap::iterator it = Nodes.find(unit);

      if (it != Nodes.end()) {

        TXBuffer.startStream();

        sendHeadandTail(F("TmplDsh"),_HEAD);

        char url[40];

        sprintf_P(url, PSTR("http://%u.%u.%u.%u/dashboard.esp"), it->second.ip[0], it->second.ip[1], it->second.ip[2], it->second.ip[3]);

        TXBuffer += F("<meta http-equiv=\"refresh\" content=\"0; URL=");

        TXBuffer += url;

        TXBuffer += F("\">");

        sendHeadandTail(F("TmplDsh"),_TAIL);

        TXBuffer.endStream();

        return true;

      }

    }



    TXBuffer.startStream();

    sendHeadandTail(F("TmplDsh"),_HEAD);

    TXBuffer += F("<script><!--\n"

             "function dept_onchange(frmselect) {frmselect.submit();}"

             "\n//--></script>");



    TXBuffer += F("<form name='frmselect' method='post'>");





    addSelector_Head(F("unit"), true);

    byte choice = Settings.Unit;

    for (NodesMap::iterator it = Nodes.begin(); it != Nodes.end(); ++it)

    {

      if (it->second.ip[0] != 0 || it->first == Settings.Unit)

      {

        String name = String(it->first) + F(" - ");

        if (it->first != Settings.Unit)

          name += it->second.nodeName;

        else

          name += Settings.Name;

        addSelector_Item(name, it->first, choice == it->first, false, F(""));

      }

    }

    addSelector_Foot();





    byte prev=Settings.Unit;

    byte next=Settings.Unit;

    NodesMap::iterator it;

    for (byte x = Settings.Unit-1; x > 0; x--) {

      it = Nodes.find(x);

      if (it != Nodes.end()) {

        if (it->second.ip[0] != 0) {prev = x; break;}

      }

    }

    for (byte x = Settings.Unit+1; x < UNIT_MAX; x++) {

      it = Nodes.find(x);

      if (it != Nodes.end()) {

        if (it->second.ip[0] != 0) {next = x; break;}

      }

    }



    TXBuffer += F("<a class='button link' href=");

    TXBuffer += path;

    TXBuffer += F("?btnunit=");

    TXBuffer += prev;

    TXBuffer += F(">&lt;</a>");

    TXBuffer += F("<a class='button link' href=");

    TXBuffer += path;

    TXBuffer += F("?btnunit=");

    TXBuffer += next;

    TXBuffer += F(">&gt;</a>");

  }





  String webrequest = WebServer.arg(F("cmd"));

  if (webrequest.length() > 0 ){

    struct EventStruct TempEvent;

    parseCommandString(&TempEvent, webrequest);

    TempEvent.Source = VALUE_SOURCE_HTTP;



    if (PluginCall(PLUGIN_WRITE, &TempEvent, webrequest));

    else if (remoteConfig(&TempEvent, webrequest));

    else if (webrequest.startsWith(F("event")))

      ExecuteCommand(VALUE_SOURCE_HTTP, webrequest.c_str());





    PluginCall(PLUGIN_TEN_PER_SECOND, 0, dummyString);

  }





  if (dataFile)

  {

    String page = "";

    page.reserve(dataFile.size());

    while (dataFile.available())

      page += ((char)dataFile.read());



    TXBuffer += parseTemplate(page,0);

    dataFile.close();

  }

  else

  {

    if (dashboardPage)

    {



      TXBuffer += F("<meta name='viewport' content='width=width=device-width, initial-scale=1'><STYLE>* {font-family:sans-serif; font-size:16pt;}.button {margin:4px; padding:4px 16px; background-color:#07D; color:#FFF; text-decoration:none; border-radius:4px}</STYLE>");

      TXBuffer += F("<table class='normal'>");

      for (byte x = 0; x < TASKS_MAX; x++)

      {

        if (Settings.TaskDeviceNumber[x] != 0)

          {

            LoadTaskSettings(x);

            byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[x]);

            html_TR_TD();

            TXBuffer += ExtraTaskSettings.TaskDeviceName;

            for (byte varNr = 0; varNr < VARS_PER_TASK; varNr++)

              {

                if ((Settings.TaskDeviceNumber[x] != 0) && (varNr < Device[DeviceIndex].ValueCount) && ExtraTaskSettings.TaskDeviceValueNames[varNr][0] !=0)

                {

                  if (varNr > 0)

                    html_TR_TD();

                  html_TD();

                  TXBuffer += ExtraTaskSettings.TaskDeviceValueNames[varNr];

                  html_TD();

                  TXBuffer += String(UserVar[x * VARS_PER_TASK + varNr], ExtraTaskSettings.TaskDeviceValueDecimals[varNr]);

                }

              }

          }

      }

    }

  }

  sendHeadandTail(F("TmplDsh"),_TAIL);

  TXBuffer.endStream();

  return true;

}
# 9117 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_filelist() {

  checkRAM(F("handle_filelist"));

  if (!clientIPallowed()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));



#if defined(ESP8266)



  String fdelete = WebServer.arg(F("delete"));



  if (fdelete.length() > 0)

  {

    SPIFFS.remove(fdelete);

    checkRuleSets();

  }



  const int pageSize = 25;

  int startIdx = 0;



  String fstart = WebServer.arg(F("start"));

  if (fstart.length() > 0)

  {

    startIdx = atoi(fstart.c_str());

  }

  int endIdx = startIdx + pageSize - 1;



  TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TH style='width:50px;'><TH>Filename<TH style='width:80px;'>Size");



  fs::Dir dir = SPIFFS.openDir("");



  int count = -1;

  while (dir.next())

  {

    ++count;



    if (count < startIdx)

    {

      continue;

    }



    html_TR_TD();

    if (dir.fileName() != F(FILE_CONFIG) && dir.fileName() != F(FILE_SECURITY) && dir.fileName() != F(FILE_NOTIFICATION))

    {

      TXBuffer += F("<a class='button link' href=\"filelist?delete=");

      TXBuffer += dir.fileName();

      if (startIdx > 0)

      {

        TXBuffer += F("&start=");

        TXBuffer += startIdx;

      }

      TXBuffer += F("\">Del</a>");

    }



    TXBuffer += F("<TD><a href=\"");

    TXBuffer += dir.fileName();

    TXBuffer += F("\">");

    TXBuffer += dir.fileName();

    TXBuffer += F("</a>");

    fs::File f = dir.openFile("r");

    html_TD();

    TXBuffer += f.size();

    if (count >= endIdx)

    {

      break;

    }

  }

  TXBuffer += F("</table></form>");

  TXBuffer += F("<BR><a class='button link' href=\"/upload\">Upload</a>");

  if (startIdx > 0)

  {

    TXBuffer += F("<a class='button link' href=\"/filelist?start=");

    TXBuffer += max(0, startIdx - pageSize);

    TXBuffer += F("\">Previous</a>");

  }

  if (count >= endIdx and dir.next())

  {

    TXBuffer += F("<a class='button link' href=\"/filelist?start=");

    TXBuffer += endIdx + 1;

    TXBuffer += F("\">Next</a>");

  }

  TXBuffer += F("<BR><BR>");

  sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();

#endif

#if defined(ESP32)

  String fdelete = WebServer.arg(F("delete"));



  if (fdelete.length() > 0)

  {

    SPIFFS.remove(fdelete);



  }



  const int pageSize = 25;

  int startIdx = 0;



  String fstart = WebServer.arg(F("start"));

  if (fstart.length() > 0)

  {

    startIdx = atoi(fstart.c_str());

  }

  int endIdx = startIdx + pageSize - 1;



  TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TH><TH>Filename<TH>Size");



  File root = SPIFFS.open("/");

  File file = root.openNextFile();

  int count = -1;

  while (file and count < endIdx)

  {

    if(!file.isDirectory()){

      ++count;



      if (count >= startIdx)

      {

        html_TR_TD();

        if (strcmp(file.name(), FILE_CONFIG) != 0 && strcmp(file.name(), FILE_SECURITY) != 0 && strcmp(file.name(), FILE_NOTIFICATION) != 0)

        {

          TXBuffer += F("<a class='button link' href=\"filelist?delete=");

          TXBuffer += file.name();

          if (startIdx > 0)

          {

            TXBuffer += F("&start=");

            TXBuffer += startIdx;

          }

          TXBuffer += F("\">Del</a>");

        }



        TXBuffer += F("<TD><a href=\"");

        TXBuffer += file.name();

        TXBuffer += F("\">");

        TXBuffer += file.name();

        TXBuffer += F("</a>");

        html_TD();

        TXBuffer += file.size();

      }

    }

    file = root.openNextFile();

  }

  TXBuffer += F("</table></form>");

  TXBuffer += F("<BR><a class='button link' href=\"/upload\">Upload</a>");

  if (startIdx > 0)

  {

    TXBuffer += F("<a class='button link' href=\"/filelist?start=");

    TXBuffer += startIdx < pageSize ? 0 : startIdx - pageSize;

    TXBuffer += F("\">Previous</a>");

  }

  if (count >= endIdx and file)

  {

    TXBuffer += F("<a class='button link' href=\"/filelist?start=");

    TXBuffer += endIdx + 1;

    TXBuffer += F("\">Next</a>");

  }

  TXBuffer += F("<BR><BR>");

    sendHeadandTail(F("TmplStd"),true);

    TXBuffer.endStream();

#endif

}
# 9445 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
#ifdef FEATURE_SD

void handle_SDfilelist() {

  checkRAM(F("handle_SDfilelist"));

  if (!clientIPallowed()) return;

  navMenuIndex = 7;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));





  String fdelete = "";

  String ddelete = "";

  String change_to_dir = "";

  String current_dir = "";

  String parent_dir = "";

  char SDcardDir[80];



  for (uint8_t i = 0; i < WebServer.args(); i++) {

    if (WebServer.argName(i) == F("delete"))

    {

      fdelete = WebServer.arg(i);

    }

    if (WebServer.argName(i) == F("deletedir"))

    {

      ddelete = WebServer.arg(i);

    }

    if (WebServer.argName(i) == F("chgto"))

    {

      change_to_dir = WebServer.arg(i);

    }

  }



  if (fdelete.length() > 0)

  {

    SD.remove((char*)fdelete.c_str());

  }

  if (ddelete.length() > 0)

  {

    SD.rmdir((char*)ddelete.c_str());

  }

  if (change_to_dir.length() > 0)

  {

    current_dir = change_to_dir;

  }

  else

  {

    current_dir = "/";

  }



  current_dir.toCharArray(SDcardDir, current_dir.length()+1);

  File root = SD.open(SDcardDir);

  root.rewindDirectory();

  File entry = root.openNextFile();

  parent_dir = current_dir;

  if (!current_dir.equals("/"))

  {
# 9571 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
    parent_dir.remove(parent_dir.lastIndexOf("/", parent_dir.lastIndexOf("/") - 1) + 1);

  }







  String subheader = "SD Card: " + current_dir;

  addFormSubHeader(subheader);

  TXBuffer += F("<BR>");

  TXBuffer += F("<table class='multirow' border=1px frame='box' rules='all'><TH style='width:50px;'><TH>Name<TH>Size");

  html_TR_TD();

  TXBuffer += F("<TD><a href=\"SDfilelist?chgto=");

  TXBuffer += parent_dir;

  TXBuffer += F("\">..");

  TXBuffer += F("</a>");

  html_TD();

  while (entry)

  {

    if (entry.isDirectory())

    {

      char SDcardChildDir[80];

      html_TR_TD();



      String child_dir = current_dir + entry.name();

      child_dir.toCharArray(SDcardChildDir, child_dir.length()+1);

      File child = SD.open(SDcardChildDir);

      File dir_has_entry = child.openNextFile();



      if (!dir_has_entry)

      {

        TXBuffer += F("<a class='button link' onclick=\"return confirm('Delete this directory?')\" href=\"SDfilelist?deletedir=");

        TXBuffer += current_dir;

        TXBuffer += entry.name();

        TXBuffer += F("/");

        TXBuffer += F("&chgto=");

        TXBuffer += current_dir;

        TXBuffer += F("\">Del</a>");

      }

      TXBuffer += F("<TD><a href=\"SDfilelist?chgto=");

      TXBuffer += current_dir;

      TXBuffer += entry.name();

      TXBuffer += F("/");

      TXBuffer += F("\">");

      TXBuffer += entry.name();

      TXBuffer += F("</a>");

      html_TD();

      TXBuffer += F("dir");

      dir_has_entry.close();

    }

    else

    {

      html_TR_TD();

      if (entry.name() != String(F(FILE_CONFIG)).c_str() && entry.name() != String(F(FILE_SECURITY)).c_str())

      {

        TXBuffer += F("<a class='button link' onclick=\"return confirm('Delete this file?')\" href=\"SDfilelist?delete=");

        TXBuffer += current_dir;

        TXBuffer += entry.name();

        TXBuffer += F("&chgto=");

        TXBuffer += current_dir;

        TXBuffer += F("\">Del</a>");

      }

      TXBuffer += F("<TD><a href=\"");

      TXBuffer += current_dir;

      TXBuffer += entry.name();

      TXBuffer += F("\">");

      TXBuffer += entry.name();

      TXBuffer += F("</a>");

      html_TD();

      TXBuffer += entry.size();

    }

    entry.close();

    entry = root.openNextFile();

  }

  root.close();

  TXBuffer += F("</table></form>");



     sendHeadandTail(F("TmplStd"),true);

    TXBuffer.endStream();

}

#endif
# 9739 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handleNotFound() {

  checkRAM(F("handleNotFound"));



  if (wifiSetup)

  {

    WebServer.send(200, F("text/html"), F("<meta HTTP-EQUIV='REFRESH' content='0; url=/setup'>"));

    return;

  }



  if (!isLoggedIn()) return;

  if (loadFromFS(true, WebServer.uri())) return;

  if (loadFromFS(false, WebServer.uri())) return;

  String message = F("URI: ");

  message += WebServer.uri();

  message += F("\nMethod: ");

  message += (WebServer.method() == HTTP_GET) ? F("GET") : F("POST");

  message += F("\nArguments: ");

  message += WebServer.args();

  message += "\n";

  for (uint8_t i = 0; i < WebServer.args(); i++) {

    message += F(" NAME:");

    message += WebServer.argName(i);

    message += F("\n VALUE:");

    message += WebServer.arg(i);

    message += F("\n");

  }

  WebServer.send(404, F("text/plain"), message);

}
# 9805 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_setup() {

  checkRAM(F("handle_setup"));



  TXBuffer.startStream();

  sendHeadandTail(F("TmplAP"));



  addHeader(false,TXBuffer.buf);



  if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED)

  {

    addHtmlError(SaveSettings());

    const IPAddress ip = WiFi.localIP();

    char host[20];

    formatIP(ip, host);

    TXBuffer += F("<BR>ESP is connected and using IP Address: <BR><h1>");

    TXBuffer += host;

    TXBuffer += F("</h1><BR><BR>Connect your laptop / tablet / phone<BR>back to your main Wifi network and<BR><BR>");

    TXBuffer += F("<a class='button' href='http://");

    TXBuffer += host;

    TXBuffer += F("/config'>Proceed to main config</a><BR><BR>");



    sendHeadandTail(F("TmplAP"),true);

    TXBuffer.endStream();



    wifiSetup = false;



    timerAPoff = millis() + 60000L;

    return;

  }



  static byte status = 0;

  static int n = 0;

  static byte refreshCount = 0;

  String ssid = WebServer.arg(F("ssid"));

  String other = WebServer.arg(F("other"));

  String password = WebServer.arg(F("pass"));



  if (other.length() != 0)

  {

    ssid = other;

  }





  if (status == 0 && ssid.length() != 0 )

  {

    strncpy(SecuritySettings.WifiKey, password.c_str(), sizeof(SecuritySettings.WifiKey));

    strncpy(SecuritySettings.WifiSSID, ssid.c_str(), sizeof(SecuritySettings.WifiSSID));

    wifiSetupConnect = true;

    if (loglevelActiveFor(LOG_LEVEL_INFO)) {

      String reconnectlog = F("WIFI : Credentials Changed, retry connection. SSID: ");

      reconnectlog += ssid;

      addLog(LOG_LEVEL_INFO, reconnectlog);

    }

    status = 1;

    refreshCount = 0;

  }



  TXBuffer += F("<BR><h1>Wifi Setup wizard</h1>");

  TXBuffer += F("<form name='frmselect' method='post'>");



  if (status == 0)

  {

    WiFiMode_t cur_wifimode = WiFi.getMode();

    if (n == 0)

      n = WiFi.scanNetworks(false, true);

    setWifiMode(cur_wifimode);

    if (n == 0)

      TXBuffer += F("No Access Points found");

    else

    {

      TXBuffer += F("<table class='multirow' border=1px frame='box'><TR><TH style='width:50px;'>Pick<TH>Network info");

      for (int i = 0; i < n; ++i)

      {

        html_TR_TD(); TXBuffer += F("<label class='container2'>");

        TXBuffer += F("<input type='radio' name='ssid' value='");

        TXBuffer += WiFi.SSID(i);

        TXBuffer += F("'");

        if (WiFi.SSID(i) == ssid)

          TXBuffer += F(" checked ");

        TXBuffer += F("><span class='dotmark'></span></label><TD>");

        TXBuffer += formatScanResult(i, "<BR>");

        TXBuffer += F("");

      }

      TXBuffer += F("</table>");

    }



    TXBuffer += F("<BR><label class='container2'>other SSID:<input type='radio' name='ssid' id='other_ssid' value='other' ><span class='dotmark'></span></label>");

    TXBuffer += F("<input class='wide' type ='text' name='other' value='");

    TXBuffer += other;

    TXBuffer += F("'><BR><BR>");



    addFormSeparator (2);



    TXBuffer += F("<BR>Password:<BR><input class='wide' type ='text' name='pass' value='");

    TXBuffer += password;

    TXBuffer += F("'><BR><BR>");



    addSubmitButton(F("Connect"),F(""));

  }



  if (status == 1)

  {

    if (refreshCount > 0)

    {

      status = 0;





      TXBuffer += F("<a class='button' href='setup'>Back to Setup</a><BR><BR>");

    }

    else

    {

      int wait = 20;

      if (refreshCount != 0)

        wait = 3;

      TXBuffer += F("Please wait for <h1 id='countdown'>20..</h1>");

      TXBuffer += F("<script type='text/JavaScript'>");

      TXBuffer += F("function timedRefresh(timeoutPeriod) {");

      TXBuffer += F("   var timer = setInterval(function() {");

      TXBuffer += F("   if (timeoutPeriod > 0) {");

      TXBuffer += F("       timeoutPeriod -= 1;");

      TXBuffer += F("       document.getElementById('countdown').innerHTML = timeoutPeriod + '..' + '<br />';");

      TXBuffer += F("   } else {");

      TXBuffer += F("       clearInterval(timer);");

      TXBuffer += F("            window.location.href = window.location.href;");

      TXBuffer += F("       };");

      TXBuffer += F("   }, 1000);");

      TXBuffer += F("};");

      TXBuffer += F("timedRefresh(");

      TXBuffer += wait;

      TXBuffer += F(");");

      TXBuffer += F("</script>");

      TXBuffer += F("seconds while trying to connect");

    }

    refreshCount++;

  }



  TXBuffer += F("</form>");

   sendHeadandTail(F("TmplAP"),true);

  TXBuffer.endStream();

  delay(10);

}
# 10097 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_rules() {

  checkRAM(F("handle_rules"));

  if (!isLoggedIn()) return;

  navMenuIndex = 5;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));

  static byte currentSet = 1;



  const byte rulesSet = getFormItemInt(F("set"), 1);



  #if defined(ESP8266)

    String fileName = F("rules");

  #endif

  #if defined(ESP32)

    String fileName = F("/rules");

  #endif

  fileName += rulesSet;

  fileName += F(".txt");





  checkRAM(F("handle_rules"));







  if (WebServer.args() > 0)

  {

    String log = F("Rules : Save rulesSet: ");

    log += rulesSet;

    log += F(" currentSet: ");

    log += currentSet;



    if (currentSet == rulesSet)

    {

      String rules = WebServer.arg(F("rules"));

      log += F(" rules.length(): ");

      log += rules.length();

      if (rules.length() > RULES_MAX_SIZE)

        TXBuffer += F("<span style=\"color:red\">Data was not saved, exceeds web editor limit!</span>");

      else

      {
# 10195 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
          fs::File f = SPIFFS.open(fileName, "w");

          if (f)

          {

            log += F(" Write to file: ");

            log += fileName;

            f.print(rules);

            f.close();



          }



      }

    }

    else

    {

      if (!SPIFFS.exists(fileName))

      {

        log += F(" Create new file: ");

        log += fileName;

        fs::File f = SPIFFS.open(fileName, "w");

        f.close();

      }

    }

    addLog(LOG_LEVEL_INFO, log);



    log = F(" Webserver args:");

    for (int i = 0; i < WebServer.args(); ++i) {

      log += F(" ");

      log += i;

      log += F(": '");

      log += WebServer.argName(i);

      log += F("' length: ");

      log += WebServer.arg(i).length();

    }

    addLog(LOG_LEVEL_INFO, log);

  }



  if (rulesSet != currentSet)

    currentSet = rulesSet;



  TXBuffer += F("<form name = 'frmselect' method = 'post'><table class='normal'><TR><TH align='left'>Rules");



  byte choice = rulesSet;

  String options[RULESETS_MAX];

  int optionValues[RULESETS_MAX];

  for (byte x = 0; x < RULESETS_MAX; x++)

  {

    options[x] = F("Rules Set ");

    options[x] += x + 1;

    optionValues[x] = x + 1;

  }



   html_TR_TD();

  addSelector(F("set"), RULESETS_MAX, options, optionValues, NULL, choice, true);

  addHelpButton(F("Tutorial_Rules"));







  int size = 0;

  fs::File f = SPIFFS.open(fileName, "r+");

  if (f)

  {

    size = f.size();

    if (size > RULES_MAX_SIZE)

       TXBuffer += F("<span style=\"color:red\">Filesize exceeds web editor limit!</span>");

    else

    {

       html_TR_TD(); TXBuffer += F("<textarea name='rules' rows='30' wrap='off'>");

      while (f.available())

      {

        String c((char)f.read());

        htmlEscape(c);

         TXBuffer += c;

      }

       TXBuffer += F("</textarea>");

    }

    f.close();

  }



   html_TR_TD(); TXBuffer += F("Current size: ");

   TXBuffer += size;

   TXBuffer += F(" characters (Max ");

   TXBuffer += RULES_MAX_SIZE;

   TXBuffer += F(")");



  addFormSeparator(2);



   html_TR_TD();

  addSubmitButton();

  addButton(fileName, F("Download to file"));

   TXBuffer += F("</table></form>");

  sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();



  checkRuleSets();

}
# 10395 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_sysinfo() {

  checkRAM(F("handle_sysinfo"));

  if (!isLoggedIn()) return;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));



  int freeMem = ESP.getFreeHeap();



  addHeader(true, TXBuffer.buf);

   TXBuffer += printWebString;

   TXBuffer += F("<form>");





   TXBuffer += F("<table class='normal'><TR><TH style='width:150px;' align='left'>System Info<TH align='left'>");



   addCopyButton(F("copyText"), F("\\n"), F("Copy info to clipboard") );



   TXBuffer += githublogo;



   html_TR_TD(); TXBuffer += F("Unit<TD>");

   TXBuffer += Settings.Unit;



  if (Settings.UseNTP)

  {



     html_TR_TD(); TXBuffer += F("Local Time<TD>");

     TXBuffer += getDateTimeString('-', ':', ' ');

  }



   html_TR_TD(); TXBuffer += F("Uptime<TD>");

  char strUpTime[40];

  int minutes = wdcounter / 2;

  int days = minutes / 1440;

  minutes = minutes % 1440;

  int hrs = minutes / 60;

  minutes = minutes % 60;

  sprintf_P(strUpTime, PSTR("%d days %d hours %d minutes"), days, hrs, minutes);

   TXBuffer += strUpTime;



   html_TR_TD(); TXBuffer += F("Load<TD>");

  if (wdcounter > 0)

  {

     TXBuffer += getCPUload();

     TXBuffer += F("% (LC=");

     TXBuffer += getLoopCountPerSec();

     TXBuffer += F(")");

  }



   html_TR_TD(); TXBuffer += F("Free Mem<TD>");

   TXBuffer += freeMem;

   TXBuffer += F(" (");

   TXBuffer += lowestRAM;

   TXBuffer += F(" - ");

   TXBuffer += lowestRAMfunction;

   TXBuffer += F(")");



   html_TR_TD(); TXBuffer += F("Boot<TD>");

   TXBuffer += getLastBootCauseString();

   TXBuffer += F(" (");

   TXBuffer += RTC.bootCounter;

   TXBuffer += F(")");

   html_TR_TD(); TXBuffer += F("Reset Reason<TD>");

   TXBuffer += getResetReasonString();



   addTableSeparator(F("Network"), 2, 3, F("Wifi"));



  if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED)

  {

     html_TR_TD(); TXBuffer += F("Wifi<TD>");

    #if defined(ESP8266)

      byte PHYmode = wifi_get_phy_mode();

    #endif

    #if defined(ESP32)

      byte PHYmode = 3;

    #endif

    switch (PHYmode)

    {

      case 1:

         TXBuffer += F("802.11B");

        break;

      case 2:

         TXBuffer += F("802.11G");

        break;

      case 3:

         TXBuffer += F("802.11N");

        break;

    }

     TXBuffer += F(" (RSSI ");

     TXBuffer += WiFi.RSSI();

     TXBuffer += F(" dB)");

  }

  html_TR_TD(); TXBuffer += F("IP config<TD>");

  TXBuffer += useStaticIP() ? F("Static") : F("DHCP");



   html_TR_TD(); TXBuffer += F("IP / subnet<TD>");

   TXBuffer += formatIP(WiFi.localIP());

   TXBuffer += F(" / ");

   TXBuffer += formatIP(WiFi.subnetMask());



   html_TR_TD(); TXBuffer += F("GW<TD>");

   TXBuffer += formatIP(WiFi.gatewayIP());



  {

    html_TR_TD(); TXBuffer += F("Client IP<TD>");

    WiFiClient client(WebServer.client());

    TXBuffer += formatIP(client.remoteIP());

  }



  html_TR_TD(); TXBuffer += F("DNS<TD>");

  TXBuffer += formatIP(WiFi.dnsIP(0));

  TXBuffer += F(" / ");

  TXBuffer += formatIP(WiFi.dnsIP(1));



  html_TR_TD(); TXBuffer += F("Allowed IP Range<TD>");

  TXBuffer += describeAllowedIPrange();



  html_TR_TD(); TXBuffer += F("Serial Port available:<TD>");

  TXBuffer += String(SerialAvailableForWrite());

  TXBuffer += F(" (");

  #if defined(ESP8266)

    TXBuffer += Serial.availableForWrite();

  #endif

  TXBuffer += F(" , ");

  TXBuffer += Serial.available();

  TXBuffer += F(")");



  html_TR_TD(); TXBuffer += F("STA MAC<TD>");



  uint8_t mac[] = {0, 0, 0, 0, 0, 0};

  uint8_t* macread = WiFi.macAddress(mac);

  char macaddress[20];

  formatMAC(macread, macaddress);

  TXBuffer += macaddress;



  html_TR_TD(); TXBuffer += F("AP MAC<TD>");

  macread = WiFi.softAPmacAddress(mac);

  formatMAC(macread, macaddress);

  TXBuffer += macaddress;



  html_TR_TD(); TXBuffer += F("SSID<TD>");

  TXBuffer += WiFi.SSID();

  TXBuffer += F(" (");

  TXBuffer += WiFi.BSSIDstr();

  TXBuffer += F(")");



  html_TR_TD(); TXBuffer += F("Channel<TD>");

  TXBuffer += WiFi.channel();



  html_TR_TD(); TXBuffer += F("Connected<TD>");

  TXBuffer += format_msec_duration(timeDiff(lastConnectMoment, millis()));



  html_TR_TD(); TXBuffer += F("Last Disconnect Reason<TD>");

  TXBuffer += getLastDisconnectReason();



  html_TR_TD(); TXBuffer += F("Number reconnects<TD>");

  TXBuffer += wifi_reconnects;



  addTableSeparator(F("Firmware"), 2, 3);



  TXBuffer += F("<TR><TD id='copyText_1'>Build<TD id='copyText_2'>");

  TXBuffer += BUILD;

  TXBuffer += F(" ");

  TXBuffer += F(BUILD_NOTES);



  TXBuffer += F("<TR><TD id='copyText_3'>Libraries<TD id='copyText_4'>");

  TXBuffer += getSystemLibraryString();



  TXBuffer += F("<TR><TD id='copyText_5'>GIT version<TD id='copyText_6'>");

  TXBuffer += BUILD_GIT;



  TXBuffer += F("<TR><TD id='copyText_7'>Plugins<TD id='copyText_8'>");

  TXBuffer += deviceCount + 1;

  TXBuffer += getPluginDescriptionString();



  html_TR_TD(); TXBuffer += F("Build Md5<TD>");

  for (byte i = 0; i<16; i++) TXBuffer += String(CRCValues.compileTimeMD5[i],HEX);



   html_TR_TD(); TXBuffer += F("Md5 check<TD>");

  if (! CRCValues.checkPassed())

     TXBuffer += F("<font color = 'red'>fail !</font>");

  else TXBuffer += F("passed.");



   TXBuffer += F("<TR><TD id='copyText_9'>Build time<TD id='copyText_10'>");

   TXBuffer += String(CRCValues.compileDate);

   TXBuffer += " ";

   TXBuffer += String(CRCValues.compileTime);



   TXBuffer += F("<TR><TD id='copyText_11'>Binary filename<TD id='copyText_12'>");

   TXBuffer += String(CRCValues.binaryFilename);



   addTableSeparator(F("ESP board"), 2, 3);



   html_TR_TD(); TXBuffer += F("ESP Chip ID<TD>");

  #if defined(ESP8266)

     TXBuffer += ESP.getChipId();

     TXBuffer += F(" (0x");

    String espChipId(ESP.getChipId(), HEX);

    espChipId.toUpperCase();

     TXBuffer += espChipId;

     TXBuffer += F(")");



     html_TR_TD(); TXBuffer += F("ESP Chip Freq:<TD>");

     TXBuffer += ESP.getCpuFreqMHz();

     TXBuffer += F(" MHz");

  #endif

  #if defined(ESP32)

     TXBuffer += F(" (0x");

     uint64_t chipid=ESP.getEfuseMac();

     uint32_t ChipId1 = (uint16_t)(chipid>>32);

     String espChipIdS(ChipId1, HEX);

     espChipIdS.toUpperCase();

     TXBuffer += espChipIdS;

     ChipId1 = (uint32_t)chipid;

     String espChipIdS1(ChipId1, HEX);

     espChipIdS1.toUpperCase();

     TXBuffer += espChipIdS1;

     TXBuffer += F(")");



     html_TR_TD(); TXBuffer += F("ESP Chip Freq:<TD>");

     TXBuffer += ESP.getCpuFreqMHz();

     TXBuffer += F(" MHz");

  #endif





   addTableSeparator(F("Storage"), 2, 3);



   html_TR_TD(); TXBuffer += F("Flash Chip ID<TD>");

  #if defined(ESP8266)

    uint32_t flashChipId = ESP.getFlashChipId();





     TXBuffer += F("Vendor: ");

     TXBuffer += formatToHex(flashChipId & 0xFF);

     TXBuffer += F(" Device: ");

     uint32_t flashDevice = (flashChipId & 0xFF00) | ((flashChipId >> 16) & 0xFF);

     TXBuffer += formatToHex(flashDevice);

  #endif

  uint32_t realSize = getFlashRealSizeInBytes();

  uint32_t ideSize = ESP.getFlashChipSize();



   html_TR_TD(); TXBuffer += F("Flash Chip Real Size:<TD>");

   TXBuffer += realSize / 1024;

   TXBuffer += F(" kB");



   html_TR_TD(); TXBuffer += F("Flash IDE Size:<TD>");

   TXBuffer += ideSize / 1024;

   TXBuffer += F(" kB");





  #if defined(ESP8266)

     html_TR_TD(); TXBuffer += F("Flash IDE speed:<TD>");

     TXBuffer += ESP.getFlashChipSpeed() / 1000000;

     TXBuffer += F(" MHz");



    FlashMode_t ideMode = ESP.getFlashChipMode();

     html_TR_TD(); TXBuffer += F("Flash IDE mode:<TD>");

    switch (ideMode) {

      case FM_QIO: TXBuffer += F("QIO"); break;

      case FM_QOUT: TXBuffer += F("QOUT"); break;

      case FM_DIO: TXBuffer += F("DIO"); break;

      case FM_DOUT: TXBuffer += F("DOUT"); break;

      default:

          TXBuffer += F("Unknown"); break;

    }

  #endif



   html_TR_TD(); TXBuffer += F("Flash Writes<TD>");

   TXBuffer += RTC.flashDayCounter;

   TXBuffer += F(" daily / ");

   TXBuffer += RTC.flashCounter;

   TXBuffer += F(" boot");



   html_TR_TD(); TXBuffer += F("Sketch Size<TD>");

  #if defined(ESP8266)

   TXBuffer += ESP.getSketchSize() / 1024;

   TXBuffer += F(" kB (");

   TXBuffer += ESP.getFreeSketchSpace() / 1024;

   TXBuffer += F(" kB free)");

  #endif



  html_TR_TD(); TXBuffer += F("SPIFFS Size<TD>");

  {

  #if defined(ESP8266)

    fs::FSInfo fs_info;

    SPIFFS.info(fs_info);

    TXBuffer += fs_info.totalBytes / 1024;

    TXBuffer += F(" kB (");

    TXBuffer += (fs_info.totalBytes - fs_info.usedBytes) / 1024;

    TXBuffer += F(" kB free)");

  #endif

  }



  if (showSettingsFileLayout) {

    addTableSeparator(F("Settings Files"), 2, 3);

    html_TR_TD();

    TXBuffer += F("Layout Settings File");

    html_TD();

    getConfig_dat_file_layout();

    html_TR_TD();

    html_TD();

    TXBuffer += F("(offset / size per item / index)");



    for (int st = 0; st < SettingsType_MAX; ++st) {

      SettingsType settingsType = static_cast<SettingsType>(st);

      html_TR_TD();

      TXBuffer += getSettingsTypeString(settingsType);

      html_TD();

      getStorageTableSVG(settingsType);

    }

  }



  #ifdef ESP32

   addTableSeparator(F("Partitions"), 2, 3,

     F("https://dl.espressif.com/doc/esp-idf/latest/api-guides/partition-tables.html"));



   html_TR_TD(); TXBuffer += F("Data Partition Table<TD>");





   getPartitionTableSVG(ESP_PARTITION_TYPE_DATA, 0x5856e6);



   html_TR_TD(); TXBuffer += F("App Partition Table<TD>");





   getPartitionTableSVG(ESP_PARTITION_TYPE_APP, 0xab56e6);

  #endif



   TXBuffer += F("</table></form>");

   sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();

}



void addSysVar_html(const String& input) {

  html_TR_TD();

  TXBuffer += F("<pre>");

  TXBuffer += F("<xmp>");

  TXBuffer += input;

  TXBuffer += F("</xmp>");

  TXBuffer += F("</pre>");

  html_TD();

  String replacement(input);

  parseSystemVariables(replacement, false);

  parseStandardConversions(replacement, false);

  TXBuffer += replacement;

  html_TD();

  replacement = input;

  parseSystemVariables(replacement, true);

  parseStandardConversions(replacement, true);

  TXBuffer += replacement;

  yield();

}
# 11105 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
void handle_sysvars() {

  checkRAM(F("handle_sysvars"));

  if (!isLoggedIn()) return;

  TXBuffer.startStream();

  sendHeadandTail(F("TmplStd"));



  addHeader(true, TXBuffer.buf);



  html_BR();

  TXBuffer += F("<p>This page may load slow.<BR>Do not load too often, since it may affect performance of the node.</p>");

  html_BR();





  TXBuffer += F("<table class='normal'><TR><TH align='left'>System Variables<TH align='left'>Normal<TH align='left'>URL encoded");

  addHelpButton(F("ESPEasy_System_Variables"));



  addTableSeparator(F("Constants"), 3, 3);

  addSysVar_html(F("%CR%"));

  addSysVar_html(F("%LF%"));

  addSysVar_html(F("%SP%"));

  addSysVar_html(F("%R%"));

  addSysVar_html(F("%N%"));



  addTableSeparator(F("Network"), 3, 3);

  addSysVar_html(F("%mac%"));

#if defined(ESP8266)

  addSysVar_html(F("%mac_int%"));

#endif

  addSysVar_html(F("%ip4%"));

  addSysVar_html(F("%ip%"));

  addSysVar_html(F("%rssi%"));

  addSysVar_html(F("%ssid%"));

  addSysVar_html(F("%bssid%"));

  addSysVar_html(F("%wi_ch%"));



  addTableSeparator(F("System"), 3, 3);

  addSysVar_html(F("%unit%"));

  addSysVar_html(F("%sysload%"));

  addSysVar_html(F("%sysheap%"));

  addSysVar_html(F("%sysname%"));

#if FEATURE_ADC_VCC

  addSysVar_html(F("%vcc%"));

#endif



  addTableSeparator(F("Time"), 3, 3);

  addSysVar_html(F("%lcltime%"));

  addSysVar_html(F("%lcltime_am%"));

  addSysVar_html(F("%systm_hm%"));

  addSysVar_html(F("%systm_hm_am%"));

  addSysVar_html(F("%systime%"));

  addSysVar_html(F("%systime_am%"));

  addTableSeparator(F("System"), 3, 3);

  addSysVar_html(F("%sysyear%  // %sysyear_0%"));

  addSysVar_html(F("%sysyears%"));

  addSysVar_html(F("%sysmonth% // %sysmonth_0%"));

  addSysVar_html(F("%sysday%   // %sysday_0%"));

  addSysVar_html(F("%syshour%  // %syshour_0%"));

  addSysVar_html(F("%sysmin%   // %sysmin_0%"));

  addSysVar_html(F("%syssec%   // %syssec_0%"));

  addSysVar_html(F("%syssec_d%"));

  addSysVar_html(F("%sysweekday%"));

  addSysVar_html(F("%sysweekday_s%"));

  addTableSeparator(F("System"), 3, 3);

  addSysVar_html(F("%uptime%"));

  addSysVar_html(F("%unixtime%"));

  addSysVar_html(F("%sunset%"));

  addSysVar_html(F("%sunset-1h%"));

  addSysVar_html(F("%sunrise%"));

  addSysVar_html(F("%sunrise+10m%"));



  addTableSeparator(F("Special Characters"), 3, 2);

  addTableSeparator(F("Degree"), 3, 3);

  addSysVar_html(F("{D}"));

  addSysVar_html(F("&deg;"));



  addTableSeparator(F("Angle quotes"), 3, 3);

  addSysVar_html(F("{<<}"));

  addSysVar_html(F("&laquo;"));

  addFormSeparator(3);

  addSysVar_html(F("{>>}"));

  addSysVar_html(F("&raquo;"));

  addTableSeparator(F("Greek letter Mu"), 3, 3);

  addSysVar_html(F("{u}"));

  addSysVar_html(F("&micro;"));

  addTableSeparator(F("Currency"), 3, 3);

  addSysVar_html(F("{E}"));

  addSysVar_html(F("&euro;"));

  addFormSeparator(3);

  addSysVar_html(F("{Y}"));

  addSysVar_html(F("&yen;"));

  addFormSeparator(3);

  addSysVar_html(F("{P}"));

  addSysVar_html(F("&pound;"));

  addFormSeparator(3);

  addSysVar_html(F("{c}"));

  addSysVar_html(F("&cent;"));



  addTableSeparator(F("Math symbols"), 3, 3);

  addSysVar_html(F("{^1}"));

  addSysVar_html(F("&sup1;"));

  addFormSeparator(3);

  addSysVar_html(F("{^2}"));

  addSysVar_html(F("&sup2;"));

  addFormSeparator(3);

  addSysVar_html(F("{^3}"));

  addSysVar_html(F("&sup3;"));

  addFormSeparator(3);

  addSysVar_html(F("{1_4}"));

  addSysVar_html(F("&frac14;"));

  addFormSeparator(3);

  addSysVar_html(F("{1_2}"));

  addSysVar_html(F("&frac12;"));

  addFormSeparator(3);

  addSysVar_html(F("{3_4}"));

  addSysVar_html(F("&frac34;"));

  addFormSeparator(3);

  addSysVar_html(F("{+-}"));

  addSysVar_html(F("&plusmn;"));

  addFormSeparator(3);

  addSysVar_html(F("{x}"));

  addSysVar_html(F("&times;"));

  addFormSeparator(3);

  addSysVar_html(F("{..}"));

  addSysVar_html(F("&divide;"));



  addTableSeparator(F("Standard Conversions"), 3, 2);



  addSysVar_html(F("Wind Dir.:    %c_w_dir%(123.4)"));

  addSysVar_html(F("{D}C to {D}F: %c_c2f%(20.4)"));

  addSysVar_html(F("m/s to Bft:   %c_ms2Bft%(5.1)"));

  addSysVar_html(F("Dew point(T,H): %c_dew_th%(18.6,67)"));

  addFormSeparator(3);

  addSysVar_html(F("cm to imperial: %c_cm2imp%(190)"));

  addSysVar_html(F("mm to imperial: %c_mm2imp%(1900)"));

  addFormSeparator(3);

  addSysVar_html(F("Mins to days: %c_m2day%(1900)"));

  addSysVar_html(F("Mins to dh:   %c_m2dh%(1900)"));

  addSysVar_html(F("Mins to dhm:  %c_m2dhm%(1900)"));

  addSysVar_html(F("Secs to dhms: %c_s2dhms%(100000)"));



  TXBuffer += F("</table></form>");

  sendHeadandTail(F("TmplStd"),true);

  TXBuffer.endStream();

}
# 11401 "C:/Users/admin/Documents/GitHub/ESPEasy/src/WebServer.ino"
String URLEncode(const char* msg)

{

  const char *hex = "0123456789abcdef";

  String encodedMsg = "";



  while (*msg != '\0') {

    if ( ('a' <= *msg && *msg <= 'z')

         || ('A' <= *msg && *msg <= 'Z')

         || ('0' <= *msg && *msg <= '9')

         || ('-' == *msg) || ('_' == *msg)

         || ('.' == *msg) || ('~' == *msg) ) {

      encodedMsg += *msg;

    } else {

      encodedMsg += '%';

      encodedMsg += hex[*msg >> 4];

      encodedMsg += hex[*msg & 15];

    }

    msg++;

  }

  return encodedMsg;

}





String getControllerSymbol(byte index)

{

  String ret = F("<p style='font-size:20px'>&#");

  ret += 10102 + index;

  ret += F(";</p>");

  return ret;

}



String getValueSymbol(byte index)

{

  String ret = F("&#");

  ret += 10112 + index;

  ret += F(";");

  return ret;

}





void handle_favicon() {

  checkRAM(F("handle_favicon"));

  WebServer.send_P(200, PSTR("image/x-icon"), favicon_8b_ico, favicon_8b_ico_len);

}



void createSvgRectPath(unsigned int color, int xoffset, int yoffset, int size, int height, int range, float SVG_BAR_WIDTH) {

  float width = SVG_BAR_WIDTH * size / range;

  if (width < 2) width = 2;

  TXBuffer += formatToHex(color, F("<path fill=\"#"));

  TXBuffer += F("\" d=\"M");

  TXBuffer += toString(SVG_BAR_WIDTH * xoffset / range, 2);

  TXBuffer += ' ';

  TXBuffer += yoffset;

  TXBuffer += 'h';

  TXBuffer += toString(width, 2);

  TXBuffer += 'v';

  TXBuffer += height;

  TXBuffer += 'H';

  TXBuffer += toString(SVG_BAR_WIDTH * xoffset / range, 2);

  TXBuffer += F("z\"/>\n");

}



void createSvgTextElement(const String& text, float textXoffset, float textYoffset) {

  TXBuffer += F("<text style=\"line-height:1.25\" x=\"");

  TXBuffer += toString(textXoffset, 2);

  TXBuffer += F("\" y=\"");

  TXBuffer += toString(textYoffset, 2);

  TXBuffer += F("\" stroke-width=\".3\" font-family=\"sans-serif\" font-size=\"8\" letter-spacing=\"0\" word-spacing=\"0\">\n");

  TXBuffer += F("<tspan x=\"");

  TXBuffer += toString(textXoffset, 2);

  TXBuffer += F("\" y=\"");

  TXBuffer += toString(textYoffset, 2);

  TXBuffer += F("\">");

  TXBuffer += text;

  TXBuffer += F("</tspan>\n</text>");

}



unsigned int getSettingsTypeColor(SettingsType settingsType) {

  switch (settingsType) {

    case BasicSettings_Type:

      return 0x5F0A87;

    case TaskSettings_Type:

      return 0xEE6352;

    case CustomTaskSettings_Type:

      return 0x59CD90;

    case ControllerSettings_Type:

      return 0x3FA7D6;

    case CustomControllerSettings_Type:

      return 0xFAC05E;

    case NotificationSettings_Type:

      return 0xF79D84;

    default:

      break;

  }

  return 0;

}



#define SVG_BAR_HEIGHT 16

#define SVG_BAR_WIDTH 400



void write_SVG_image_header(int width, int height) {

  TXBuffer += F("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"");

  TXBuffer += width;

  TXBuffer += F("\" height=\"");

  TXBuffer += height;

  TXBuffer += F("\">");

}



void getConfig_dat_file_layout() {

  const int shiftY = 2;

  float yOffset = shiftY;

  write_SVG_image_header(SVG_BAR_WIDTH + 250, SVG_BAR_HEIGHT + shiftY);



  int max_index, offset, max_size;

  int struct_size = 0;





  const uint32_t realSize = getFileSize(TaskSettings_Type);

  createSvgRectPath(0xcdcdcd, 0, yOffset, realSize, SVG_BAR_HEIGHT - 2, realSize, SVG_BAR_WIDTH);



  for (int st = 0; st < SettingsType_MAX; ++st) {

    SettingsType settingsType = static_cast<SettingsType>(st);

    if (settingsType != NotificationSettings_Type) {

      unsigned int color = getSettingsTypeColor(settingsType);

      getSettingsParameters(settingsType, 0, max_index, offset, max_size, struct_size);

      for (int i = 0; i < max_index; ++i) {

        getSettingsParameters(settingsType, i, offset, max_size);



        createSvgRectPath(color, offset, yOffset, max_size, SVG_BAR_HEIGHT - 2, realSize, SVG_BAR_WIDTH);

      }

    }

  }



  float textXoffset = SVG_BAR_WIDTH + 2;

  float textYoffset = yOffset + 0.9 * SVG_BAR_HEIGHT;

  createSvgTextElement(F("Config.dat"), textXoffset, textYoffset);

  TXBuffer += F("</svg>\n");

}



void getStorageTableSVG(SettingsType settingsType) {

  uint32_t realSize = getFileSize(settingsType);

  unsigned int color = getSettingsTypeColor(settingsType);

  const int shiftY = 2;



  int max_index, offset, max_size;

  int struct_size = 0;

  getSettingsParameters(settingsType, 0, max_index, offset, max_size, struct_size);

  if (max_index == 0) return;



  write_SVG_image_header(SVG_BAR_WIDTH + 250, (max_index + 1) * SVG_BAR_HEIGHT + shiftY);

  float yOffset = shiftY;

  for (int i = 0; i < max_index; ++i) {

    getSettingsParameters(settingsType, i, offset, max_size);



    createSvgRectPath(0xcdcdcd, 0, yOffset, realSize, SVG_BAR_HEIGHT - 2, realSize, SVG_BAR_WIDTH);



    createSvgRectPath(color, offset, yOffset, max_size, SVG_BAR_HEIGHT - 2, realSize, SVG_BAR_WIDTH);



    float textXoffset = SVG_BAR_WIDTH + 2;

    float textYoffset = yOffset + 0.9 * SVG_BAR_HEIGHT;

    createSvgTextElement(formatHumanReadable(offset, 1024), textXoffset, textYoffset);

    textXoffset = SVG_BAR_WIDTH + 60;

    createSvgTextElement(formatHumanReadable(max_size, 1024), textXoffset, textYoffset);

    textXoffset = SVG_BAR_WIDTH + 130;

    createSvgTextElement(String(i), textXoffset, textYoffset);

    yOffset += SVG_BAR_HEIGHT;

  }



  createSvgRectPath(0xcdcdcd, 0, yOffset, max_size, SVG_BAR_HEIGHT - 2, max_size, SVG_BAR_WIDTH);



  if (struct_size != 0) {

    createSvgRectPath(color, 0, yOffset, struct_size, SVG_BAR_HEIGHT - 2, max_size, SVG_BAR_WIDTH);

  }



  float textXoffset = SVG_BAR_WIDTH + 2;

  float textYoffset = yOffset + 0.9 * SVG_BAR_HEIGHT;

  if (struct_size != 0) {

    String text = formatHumanReadable(struct_size, 1024);

    text += '/';

    text += formatHumanReadable(max_size, 1024);

    text += F(" per item");

    createSvgTextElement(text, textXoffset, textYoffset);

  } else {

    createSvgTextElement(F("Variable size"), textXoffset, textYoffset);

  }

  TXBuffer += F("</svg>\n");

}



#ifdef ESP32





int getPartionCount(byte pType) {

  esp_partition_type_t partitionType = static_cast<esp_partition_type_t>(pType);

  esp_partition_iterator_t _mypartiterator = esp_partition_find(partitionType, ESP_PARTITION_SUBTYPE_ANY, NULL);

  int nrPartitions = 0;

  if (_mypartiterator) {

    do {

      ++nrPartitions;

    } while ((_mypartiterator = esp_partition_next(_mypartiterator)) != NULL);

  }

  esp_partition_iterator_release(_mypartiterator);

  return nrPartitions;

}



void getPartitionTableSVG(byte pType, unsigned int partitionColor) {

  int nrPartitions = getPartionCount(pType);

  if (nrPartitions == 0) return;

  const int shiftY = 2;



  uint32_t realSize = getFlashRealSizeInBytes();

  esp_partition_type_t partitionType = static_cast<esp_partition_type_t>(pType);

  const esp_partition_t * _mypart;

  esp_partition_iterator_t _mypartiterator = esp_partition_find(partitionType, ESP_PARTITION_SUBTYPE_ANY, NULL);

  write_SVG_image_header(SVG_BAR_WIDTH + 250, nrPartitions * SVG_BAR_HEIGHT + shiftY);

  float yOffset = shiftY;

  if (_mypartiterator) {

    do {

      _mypart = esp_partition_get(_mypartiterator);

      createSvgRectPath(0xcdcdcd, 0, yOffset, realSize, SVG_BAR_HEIGHT - 2, realSize, SVG_BAR_WIDTH);

      createSvgRectPath(partitionColor, _mypart->address, yOffset, _mypart->size, SVG_BAR_HEIGHT - 2, realSize, SVG_BAR_WIDTH);

      float textXoffset = SVG_BAR_WIDTH + 2;

      float textYoffset = yOffset + 0.9 * SVG_BAR_HEIGHT;

      createSvgTextElement(formatHumanReadable(_mypart->size, 1024), textXoffset, textYoffset);

      textXoffset = SVG_BAR_WIDTH + 60;

      createSvgTextElement(_mypart->label, textXoffset, textYoffset);

      textXoffset = SVG_BAR_WIDTH + 130;

      createSvgTextElement(getPartitionType(_mypart->type, _mypart->subtype), textXoffset, textYoffset);

      yOffset += SVG_BAR_HEIGHT;

    } while ((_mypartiterator = esp_partition_next(_mypartiterator)) != NULL);

  }

  TXBuffer += F("</svg>\n");

  esp_partition_iterator_release(_mypartiterator);

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C001.ino"
#ifdef USES_C001
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C001.ino"
#define CPLUGIN_001 

#define CPLUGIN_ID_001 1

#define CPLUGIN_NAME_001 "Domoticz HTTP"





boolean CPlugin_001(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_001;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 8080;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_001);

        break;

      }



    case CPLUGIN_INIT:

      {

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);

        C001_DelayHandler.configureControllerSettings(ControllerSettings);

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        if (event->idx != 0)

        {



          String url;



          switch (event->sensorType)

          {

            case SENSOR_TYPE_SWITCH:

              url = F("/json.htm?type=command&param=switchlight&idx=");

              url += event->idx;

              url += F("&switchcmd=");

              if (UserVar[event->BaseVarIndex] == 0)

                url += F("Off");

              else

                url += F("On");

              break;

            case SENSOR_TYPE_DIMMER:

              url = F("/json.htm?type=command&param=switchlight&idx=");

              url += event->idx;

              url += F("&switchcmd=");

              if (UserVar[event->BaseVarIndex] == 0) {

                url += ("Off");

              } else {

                url += F("Set%20Level&level=");

                url += UserVar[event->BaseVarIndex];

              }

              break;



            case SENSOR_TYPE_SINGLE:

            case SENSOR_TYPE_LONG:

            case SENSOR_TYPE_DUAL:

            case SENSOR_TYPE_TRIPLE:

            case SENSOR_TYPE_QUAD:

            case SENSOR_TYPE_TEMP_HUM:

            case SENSOR_TYPE_TEMP_BARO:

            case SENSOR_TYPE_TEMP_EMPTY_BARO:

            case SENSOR_TYPE_TEMP_HUM_BARO:

            case SENSOR_TYPE_WIND:

            default:

              url = F("/json.htm?type=command&param=udevice&idx=");

              url += event->idx;

              url += F("&nvalue=0");

              url += F("&svalue=");

              url += formatDomoticzSensorType(event);

              break;

          }





          url += F("&rssi=");

          url += mapRSSItoDomoticz();

          #if FEATURE_ADC_VCC

            url += F("&battery=");

            url += mapVccToDomoticz();

          #endif



          success = C001_DelayHandler.addToQueue(C001_queue_element(event->ControllerIndex, url));

          scheduleNextDelayQueue(TIMER_C001_DELAY_QUEUE, C001_DelayHandler.getNextScheduleTime());

        }

        else

        {

          addLog(LOG_LEVEL_ERROR, F("HTTP : IDX cannot be zero!"));

        }

        break;

      }

  }

  return success;

}



bool do_process_c001_delay_queue(int controller_number, const C001_queue_element& element, ControllerSettingsStruct& ControllerSettings) {

  WiFiClient client;

  if (!try_connect_host(controller_number, client, ControllerSettings))

    return false;





  String request = create_http_request_auth(controller_number, element.controller_idx, ControllerSettings, F("GET"), element.txt);



  addLog(LOG_LEVEL_DEBUG, element.txt);

  return send_via_http(controller_number, client, request);

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C002.ino"
#ifdef USES_C002
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C002.ino"
#define CPLUGIN_002 

#define CPLUGIN_ID_002 2

#define CPLUGIN_NAME_002 "Domoticz MQTT"



#include <ArduinoJson.h>



boolean CPlugin_002(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_002;

        Protocol[protocolCount].usesMQTT = true;

        Protocol[protocolCount].usesTemplate = true;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 1883;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_002);

        break;

      }



    case CPLUGIN_INIT:

      {

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);

        MQTTDelayHandler.configureControllerSettings(ControllerSettings);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = F("domoticz/out");

        event->String2 = F("domoticz/in");

        break;

      }



    case CPLUGIN_PROTOCOL_RECV:

      {
# 113 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C002.ino"
        byte ControllerID = findFirstEnabledControllerWithId(CPLUGIN_ID_002);

        if (ControllerID < CONTROLLER_MAX) {

          StaticJsonBuffer<512> jsonBuffer;

          JsonObject& root = jsonBuffer.parseObject(event->String2.c_str());

          if (root.success())

          {

            unsigned int idx = root[F("idx")];

            float nvalue = root[F("nvalue")];

            long nvaluealt = root[F("nvalue")];





            const char* svalue1 = root[F("svalue1")];





            const char* switchtype = root[F("switchType")];

            if (nvalue == 0)

              nvalue = nvaluealt;

            if ((int)switchtype == 0)

              switchtype = "?";



            for (byte x = 0; x < TASKS_MAX; x++) {



              if (Settings.TaskDeviceEnabled[x] && Settings.TaskDeviceID[ControllerID][x] == idx)

              {

                String action = "";

                switch (Settings.TaskDeviceNumber[x]) {

                  case 1:

                  {

                    action = F("inputSwitchState,");

                    action += x;

                    action += ",";

                    action += nvalue;

                    break;

                  }

                  case 29:

                  {

                    action = "";

                    int baseVar = x * VARS_PER_TASK;

                    if (strcasecmp_P(switchtype, PSTR("dimmer")) == 0)

                    {

                      int pwmValue = UserVar[baseVar];

                      action = F("pwm,");

                      action += Settings.TaskDevicePin1[x];

                      action += ",";

                      switch ((int)nvalue)

                      {

                        case 0:

                          pwmValue = 0;

                          break;

                        case 1:

                          pwmValue = UserVar[baseVar];

                          break;

                        case 2:

                          pwmValue = 10 * atol(svalue1);

                          UserVar[baseVar] = pwmValue;

                          break;

                      }

                      action += pwmValue;

                    } else {

                      UserVar[baseVar] = nvalue;

                      action = F("gpio,");

                      action += Settings.TaskDevicePin1[x];

                      action += ",";

                      action += nvalue;

                    }

                    break;

                  }

                  default:

                    break;

                }

                if (action.length() > 0) {

                  struct EventStruct TempEvent;

                  TempEvent.TaskIndex = x;

                  parseCommandString(&TempEvent, action);

                  PluginCall(PLUGIN_WRITE, &TempEvent, action);



                  if (Settings.UseRules)

                    createRuleEvents(x);

                }

              }

            }

            LoadTaskSettings(event->TaskIndex);

          }

        }

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        if (event->idx != 0)

        {

          ControllerSettingsStruct ControllerSettings;

          LoadControllerSettings(event->ControllerIndex, ControllerSettings);
# 311 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C002.ino"
          StaticJsonBuffer<200> jsonBuffer;



          JsonObject& root = jsonBuffer.createObject();

          root[F("idx")] = event->idx;

          root[F("RSSI")] = mapRSSItoDomoticz();

          #if FEATURE_ADC_VCC

            root[F("Battery")] = mapVccToDomoticz();

          #endif



          switch (event->sensorType)

          {

            case SENSOR_TYPE_SWITCH:

              root[F("command")] = String(F("switchlight"));

              if (UserVar[event->BaseVarIndex] == 0)

                root[F("switchcmd")] = String(F("Off"));

              else

                root[F("switchcmd")] = String(F("On"));

              break;

            case SENSOR_TYPE_DIMMER:

              root[F("command")] = String(F("switchlight"));

              if (UserVar[event->BaseVarIndex] == 0)

                root[F("switchcmd")] = String(F("Off"));

              else

                root[F("Set%20Level")] = UserVar[event->BaseVarIndex];

              break;



            case SENSOR_TYPE_SINGLE:

            case SENSOR_TYPE_LONG:

            case SENSOR_TYPE_DUAL:

            case SENSOR_TYPE_TRIPLE:

            case SENSOR_TYPE_QUAD:

            case SENSOR_TYPE_TEMP_HUM:

            case SENSOR_TYPE_TEMP_BARO:

            case SENSOR_TYPE_TEMP_EMPTY_BARO:

            case SENSOR_TYPE_TEMP_HUM_BARO:

            case SENSOR_TYPE_WIND:

            default:

              root[F("nvalue")] = 0;

              root[F("svalue")] = formatDomoticzSensorType(event);

              break;

          }



          String json;

          root.printTo(json);

          String log = F("MQTT : ");

          log += json;

          addLog(LOG_LEVEL_DEBUG, log);



          String pubname = ControllerSettings.Publish;

          parseControllerVariables(pubname, event, false);

          if (!MQTTpublish(event->ControllerIndex, pubname.c_str(), json.c_str(), Settings.MQTTRetainFlag))

          {

            connectionFailures++;

          }

          else if (connectionFailures)

            connectionFailures--;



        }

        else

        {

          String log = F("MQTT : IDX cannot be zero!");

          addLog(LOG_LEVEL_ERROR, log);

        }

        break;

      }



  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C003.ino"
#ifdef USES_C003
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C003.ino"
#define CPLUGIN_003 

#define CPLUGIN_ID_003 3

#define CPLUGIN_NAME_003 "Nodo Telnet"



boolean CPlugin_003(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_003;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 23;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_003);

        break;

      }



    case CPLUGIN_INIT:

      {

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);

        C003_DelayHandler.configureControllerSettings(ControllerSettings);

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {



        String url = F("variableset ");

        url += event->idx;

        url += ",";

        url += formatUserVarNoCheck(event, 0);

        url += "\n";

        success = C003_DelayHandler.addToQueue(C003_queue_element(event->ControllerIndex, url));

        scheduleNextDelayQueue(TIMER_C003_DELAY_QUEUE, C003_DelayHandler.getNextScheduleTime());



        break;

      }



  }

  return success;

}



bool do_process_c003_delay_queue(int controller_number, const C003_queue_element& element, ControllerSettingsStruct& ControllerSettings) {

  boolean success = false;

  char log[80];

  addLog(LOG_LEVEL_DEBUG, String(F("TELNT : connecting to ")) + ControllerSettings.getHostPortString());



  WiFiClient client;

  if (!ControllerSettings.connectToHost(client))

  {

    connectionFailures++;

    strcpy_P(log, PSTR("TELNT: connection failed"));

    addLog(LOG_LEVEL_ERROR, log);

    return success;

  }

  statusLED(true);

  if (connectionFailures)

    connectionFailures--;







  client.print(" \n");



  unsigned long timer = millis() + 200;

  while (!client.available() && !timeOutReached(timer))

    delay(1);



  timer = millis() + 1000;

  while (client_available(client) && !timeOutReached(timer) && !success)

  {





    String line;

    safeReadStringUntil(client, line, '\n');



    if (line.startsWith(F("Enter your password:")))

    {

      success = true;

      strcpy_P(log, PSTR("TELNT: Password request ok"));

      addLog(LOG_LEVEL_DEBUG, log);

    }

    delay(1);

  }



  strcpy_P(log, PSTR("TELNT: Sending pw"));

  addLog(LOG_LEVEL_DEBUG, log);

  client.println(SecuritySettings.ControllerPassword[element.controller_idx]);

  delay(100);

  while (client.available())

    client.read();



  strcpy_P(log, PSTR("TELNT: Sending cmd"));

  addLog(LOG_LEVEL_DEBUG, log);

  client.print(element.txt);

  delay(10);

  while (client_available(client))

    client.read();



  strcpy_P(log, PSTR("TELNT: closing connection"));

  addLog(LOG_LEVEL_DEBUG, log);



  client.stop();

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C004.ino"
#ifdef USES_C004
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C004.ino"
#define CPLUGIN_004 

#define CPLUGIN_ID_004 4

#define CPLUGIN_NAME_004 "ThingSpeak"



boolean CPlugin_004(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_004;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 80;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_004);

        break;

      }



    case CPLUGIN_INIT:

      {

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);

        C004_DelayHandler.configureControllerSettings(ControllerSettings);

        break;

      }



    case CPLUGIN_GET_PROTOCOL_DISPLAY_NAME:

      {

        success = true;

        switch (event->idx) {

          case CONTROLLER_USER:

            string = F("ThingHTTP Name");

            break;

          case CONTROLLER_PASS:

            string = F("API Key");

            break;

          default:

            success = false;

            break;

        }

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        success = C004_DelayHandler.addToQueue(C004_queue_element(event));

        scheduleNextDelayQueue(TIMER_C004_DELAY_QUEUE, C004_DelayHandler.getNextScheduleTime());



        break;

      }



  }

  return success;

}



bool do_process_c004_delay_queue(int controller_number, const C004_queue_element& element, ControllerSettingsStruct& ControllerSettings) {

  WiFiClient client;

  if (!try_connect_host(controller_number, client, ControllerSettings))

    return false;



  String postDataStr = F("api_key=");

  postDataStr += SecuritySettings.ControllerPassword[element.controller_idx];



  byte valueCount = getValueCountFromSensorType(element.sensorType);

  for (byte x = 0; x < valueCount; x++)

  {

    postDataStr += F("&field");

    postDataStr += element.idx + x;

    postDataStr += "=";

    postDataStr += formatUserVarNoCheck(element.TaskIndex, x);

  }

  String hostName = F("api.thingspeak.com");

  if (ControllerSettings.UseDNS)

    hostName = ControllerSettings.HostName;



  String postStr = do_create_http_request(

    hostName, F("POST"),

    F("/update"),

    "",

    F("Content-Type: application/x-www-form-urlencoded\r\n"),

    postDataStr.length());

  postStr += postDataStr;



  return send_via_http(controller_number, client, postStr);

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C005.ino"
#ifdef USES_C005
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C005.ino"
#define CPLUGIN_005 

#define CPLUGIN_ID_005 5

#define CPLUGIN_NAME_005 "OpenHAB MQTT"



boolean CPlugin_005(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_005;

        Protocol[protocolCount].usesMQTT = true;

        Protocol[protocolCount].usesTemplate = true;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 1883;

        Protocol[protocolCount].usesID = false;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_005);

        break;

      }



    case CPLUGIN_INIT:

      {

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);

        MQTTDelayHandler.configureControllerSettings(ControllerSettings);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = F("/%sysname%/#");

        event->String2 = F("/%sysname%/%tskname%/%valname%");

        break;

      }



    case CPLUGIN_PROTOCOL_RECV:

      {

        byte ControllerID = findFirstEnabledControllerWithId(CPLUGIN_ID_005);

        if (ControllerID == CONTROLLER_MAX) {



          break;

        } else {

          String cmd;

          struct EventStruct TempEvent;

          TempEvent.TaskIndex = event->TaskIndex;

          bool validTopic = false;

          const int lastindex = event->String1.lastIndexOf('/');

          const String lastPartTopic = event->String1.substring(lastindex + 1);

          if (lastPartTopic == F("cmd")) {

            cmd = event->String2;

            parseCommandString(&TempEvent, cmd);

            TempEvent.Source = VALUE_SOURCE_MQTT;

            validTopic = true;

          } else {

            if (lastindex > 0) {



              if (isFloat(event->String2) && isInt(lastPartTopic)) {

                int prevLastindex = event->String1.lastIndexOf('/', lastindex - 1);

                cmd = event->String1.substring(prevLastindex + 1, lastindex);

                TempEvent.Par1 = lastPartTopic.toInt();

                TempEvent.Par2 = event->String2.toFloat();

                TempEvent.Par3 = 0;

                validTopic = true;

              }

            }

          }

          if (validTopic) {



            String command = parseString(cmd, 1);

            if (command == F("event")) {

            eventBuffer = cmd.substring(6);

            } else if (!PluginCall(PLUGIN_WRITE, &TempEvent, cmd)) {

              remoteConfig(&TempEvent, cmd);

            }

          }

        }

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);

        if (!ControllerSettings.checkHostReachable(true)) {

            success = false;

            break;

        }

        statusLED(true);



        if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

          PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);



        String pubname = ControllerSettings.Publish;

        parseControllerVariables(pubname, event, false);



        String value = "";



        byte valueCount = getValueCountFromSensorType(event->sensorType);

        for (byte x = 0; x < valueCount; x++)

        {

          String tmppubname = pubname;

          tmppubname.replace(F("%valname%"), ExtraTaskSettings.TaskDeviceValueNames[x]);

          value = formatUserVarNoCheck(event, x);



          MQTTpublish(event->ControllerIndex, tmppubname.c_str(), value.c_str(), Settings.MQTTRetainFlag);

          String log = F("MQTT : ");

          log += tmppubname;

          log += " ";

          log += value;

          addLog(LOG_LEVEL_DEBUG, log);

        }

        break;

      }

  }



  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C006.ino"
#ifdef USES_C006
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C006.ino"
#define CPLUGIN_006 

#define CPLUGIN_ID_006 6

#define CPLUGIN_NAME_006 "PiDome MQTT"



boolean CPlugin_006(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_006;

        Protocol[protocolCount].usesMQTT = true;

        Protocol[protocolCount].usesTemplate = true;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = false;

        Protocol[protocolCount].defaultPort = 1883;

        Protocol[protocolCount].usesID = false;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_006);

        break;

      }



    case CPLUGIN_INIT:

      {

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);

        MQTTDelayHandler.configureControllerSettings(ControllerSettings);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = F("/Home/#");

        event->String2 = F("/hooks/devices/%id%/SensorData/%valname%");

        break;

      }



    case CPLUGIN_PROTOCOL_RECV:

      {





        String tmpTopic = event->String1.substring(1);

        String topicSplit[10];

        int SlashIndex = tmpTopic.indexOf('/');

        byte count = 0;

        while (SlashIndex > 0 && count < 10 - 1)

        {

          topicSplit[count] = tmpTopic.substring(0, SlashIndex);

          tmpTopic = tmpTopic.substring(SlashIndex + 1);

          SlashIndex = tmpTopic.indexOf('/');

          count++;

        }

        topicSplit[count] = tmpTopic;



        String name = topicSplit[4];

        String cmd = topicSplit[5];

        struct EventStruct TempEvent;

        TempEvent.TaskIndex = event->TaskIndex;

        TempEvent.Par1 = topicSplit[6].toInt();

        TempEvent.Par2 = 0;

        TempEvent.Par3 = 0;

        if (event->String2 == F("false") || event->String2 == F("true"))

        {

          if (event->String2 == F("true"))

            TempEvent.Par2 = 1;

        }

        else

          TempEvent.Par2 = event->String2.toFloat();

        if (name == Settings.Name)

        {

          PluginCall(PLUGIN_WRITE, &TempEvent, cmd);

        }

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        if (!WiFiConnected(100)) {

          success = false;

          break;

        }

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);



        statusLED(true);



        if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

          PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);



        String pubname = ControllerSettings.Publish;

        parseControllerVariables(pubname, event, false);



        String value = "";



        byte valueCount = getValueCountFromSensorType(event->sensorType);

        for (byte x = 0; x < valueCount; x++)

        {

          String tmppubname = pubname;

          tmppubname.replace(F("%valname%"), ExtraTaskSettings.TaskDeviceValueNames[x]);

          value = formatUserVarNoCheck(event, x);

          MQTTpublish(event->ControllerIndex, tmppubname.c_str(), value.c_str(), Settings.MQTTRetainFlag);

        }

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C007.ino"
#ifdef USES_C007
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C007.ino"
#define CPLUGIN_007 

#define CPLUGIN_ID_007 7

#define CPLUGIN_NAME_007 "Emoncms"



boolean CPlugin_007(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_007;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 80;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_007);

        break;

      }



    case CPLUGIN_INIT:

      {

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);

        C007_DelayHandler.configureControllerSettings(ControllerSettings);

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        const byte valueCount = getValueCountFromSensorType(event->sensorType);

        if (valueCount == 0 || valueCount > 3) {

          addLog(LOG_LEVEL_ERROR, F("emoncms : Unknown sensortype or too many sensor values"));

          break;

        }

        success = C007_DelayHandler.addToQueue(C007_queue_element(event));

        scheduleNextDelayQueue(TIMER_C007_DELAY_QUEUE, C007_DelayHandler.getNextScheduleTime());

        break;

      }



  }

  return success;

}



bool do_process_c007_delay_queue(int controller_number, const C007_queue_element& element, ControllerSettingsStruct& ControllerSettings) {

  WiFiClient client;

  if (!try_connect_host(controller_number, client, ControllerSettings))

    return false;



  String url = F("/emoncms/input/post.json?node=");

  url += Settings.Unit;

  url += F("&json=");

  const byte valueCount = getValueCountFromSensorType(element.sensorType);

  for (byte i = 0; i < valueCount; ++i) {

    url += (i == 0) ? F("{") : F(",");

    url += F("field");

    url += element.idx + i;

    url += ":";

    url += formatUserVarNoCheck(element.TaskIndex, i);

  }

  url += "}";

  url += F("&apikey=");

  url += SecuritySettings.ControllerPassword[element.controller_idx];



  if (Settings.SerialLogLevel >= LOG_LEVEL_DEBUG_MORE)

    Serial.println(url);



  return send_via_http(controller_number, client,

    create_http_get_request(controller_number, ControllerSettings, url));

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C008.ino"
#ifdef USES_C008
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C008.ino"
#define CPLUGIN_008 

#define CPLUGIN_ID_008 8

#define CPLUGIN_NAME_008 "Generic HTTP"

#include <ArduinoJson.h>



boolean CPlugin_008(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_008;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesTemplate = true;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 80;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_008);

        break;

      }



    case CPLUGIN_INIT:

      {

        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);

        C008_DelayHandler.configureControllerSettings(ControllerSettings);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = "";

        event->String2 = F("demo.php?name=%sysname%&task=%tskname%&valuename=%valname%&value=%value%");

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {



        byte valueCount = getValueCountFromSensorType(event->sensorType);

        C008_queue_element element(event, valueCount);

        if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

          PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);



        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);



        for (byte x = 0; x < valueCount; x++)

        {

          bool isvalid;

          String formattedValue = formatUserVar(event, x, isvalid);

          if (isvalid) {

            element.txt[x] = "/";

            element.txt[x] += ControllerSettings.Publish;

            parseControllerVariables(element.txt[x], event, true);



            element.txt[x].replace(F("%valname%"), URLEncode(ExtraTaskSettings.TaskDeviceValueNames[x]));

            element.txt[x].replace(F("%value%"), formattedValue);

            addLog(LOG_LEVEL_DEBUG_MORE, element.txt[x]);

          }

        }

        success = C008_DelayHandler.addToQueue(element);

        scheduleNextDelayQueue(TIMER_C008_DELAY_QUEUE, C008_DelayHandler.getNextScheduleTime());

        break;

      }



  }

  return success;

}
# 173 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C008.ino"
bool do_process_c008_delay_queue(int controller_number, const C008_queue_element& element, ControllerSettingsStruct& ControllerSettings) {

  while (element.txt[element.valuesSent] == "") {





    if (element.checkDone(true))

      return true;

  }



  WiFiClient client;

  if (!try_connect_host(controller_number, client, ControllerSettings))

    return false;



  String request = create_http_request_auth(controller_number, element.controller_idx, ControllerSettings, F("GET"), element.txt[element.valuesSent]);

  return element.checkDone(send_via_http(controller_number, client, request));

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C009.ino"
#ifdef USES_C009
# 57 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C009.ino"
#define CPLUGIN_009 

#define CPLUGIN_ID_009 9

#define CPLUGIN_NAME_009 "FHEM HTTP"

#include <ArduinoJson.h>



boolean CPlugin_009(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_009;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesTemplate = false;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].usesID = false;

        Protocol[protocolCount].defaultPort = 8383;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_009);

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        if (!WiFiConnected(100)) {

          success = false;

          break;

        }

        if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

          PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);





        String url = F("/ESPEasy");





        DynamicJsonBuffer jsonBuffer;

        JsonObject& root = jsonBuffer.createObject();

        root[F("module")] = String(F("ESPEasy"));

        root[F("version")] = String(F("1.04"));





        JsonObject& data = root.createNestedObject(String(F("data")));

        JsonObject& ESP = data.createNestedObject(String(F("ESP")));

        ESP[F("name")] = Settings.Name;

        ESP[F("unit")] = Settings.Unit;

        ESP[F("version")] = Settings.Version;

        ESP[F("build")] = Settings.Build;

        ESP[F("build_notes")] = String(F(BUILD_NOTES));

        ESP[F("build_git")] = String(F(BUILD_GIT));

        ESP[F("node_type_id")] = NODE_TYPE_ID;

        ESP[F("sleep")] = Settings.deepSleep;
# 183 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C009.ino"
        ESP[F("ip")] = WiFi.localIP().toString();





        JsonObject& SENSOR = data.createNestedObject(String(F("SENSOR")));

        byte valueCount = getValueCountFromSensorType(event->sensorType);



        for (byte x = 0; x < valueCount; x++)

        {





          JsonObject& val = SENSOR.createNestedObject(String(x));

          val[F("deviceName")] = getTaskDeviceName(event->TaskIndex);

          val[F("valueName")] = ExtraTaskSettings.TaskDeviceValueNames[x];

          val[F("type")] = event->sensorType;

          val[F("value")] = formatUserVarNoCheck(event, x);

        }





        String jsonString;

        root.printTo(jsonString);



        success = C009_DelayHandler.addToQueue(C009_queue_element(event->ControllerIndex, url, jsonString));

        scheduleNextDelayQueue(TIMER_C009_DELAY_QUEUE, C009_DelayHandler.getNextScheduleTime());

        break;

      }

  }

  return success;

}
# 247 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C009.ino"
bool do_process_c009_delay_queue(int controller_number, const C009_queue_element& element, ControllerSettingsStruct& ControllerSettings) {

  WiFiClient client;

  if (!try_connect_host(controller_number, client, ControllerSettings))

    return false;



  String request = create_http_request_auth(

      controller_number, element.controller_idx, ControllerSettings,

      F("POST"), element.url, element.json.length());

  request += element.json;



  return send_via_http(controller_number, client, request);

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C010.ino"
#ifdef USES_C010
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C010.ino"
#define CPLUGIN_010 

#define CPLUGIN_ID_010 10

#define CPLUGIN_NAME_010 "Generic UDP"



boolean CPlugin_010(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_010;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesTemplate = true;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = false;

        Protocol[protocolCount].defaultPort = 514;

        Protocol[protocolCount].usesID = false;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_010);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = "";

        event->String2 = F("%sysname%_%tskname%_%valname%=%value%");

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        byte valueCount = getValueCountFromSensorType(event->sensorType);

        C010_queue_element element(event, valueCount);

        if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

          PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);



        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);



        for (byte x = 0; x < valueCount; x++)

        {

          bool isvalid;

          String formattedValue = formatUserVar(event, x, isvalid);

          if (isvalid) {

            element.txt[x] = "";

            element.txt[x] += ControllerSettings.Publish;

            parseControllerVariables(element.txt[x], event, false);

            element.txt[x].replace(F("%valname%"), ExtraTaskSettings.TaskDeviceValueNames[x]);

            element.txt[x].replace(F("%value%"), formattedValue);

            if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE)) {

              char log[80];

              element.txt[x].toCharArray(log, 80);

              addLog(LOG_LEVEL_DEBUG_MORE, log);

            }

          }

        }

        success = C010_DelayHandler.addToQueue(element);

        scheduleNextDelayQueue(TIMER_C010_DELAY_QUEUE, C010_DelayHandler.getNextScheduleTime());

        break;

      }



  }

  return success;

}
# 161 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C010.ino"
bool do_process_c010_delay_queue(int controller_number, const C010_queue_element& element, ControllerSettingsStruct& ControllerSettings) {

  while (element.txt[element.valuesSent] == "") {





    if (element.checkDone(true))

      return true;

  }



  if (!try_connect_host(controller_number, portUDP, ControllerSettings))

    return false;



  portUDP.write(

    (uint8_t*)element.txt[element.valuesSent].c_str(),

              element.txt[element.valuesSent].length());

  return element.checkDone(portUDP.endPacket() != 0);

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C011.ino"
#ifdef USES_C011
# 15 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C011.ino"
#define CPLUGIN_011 

#define CPLUGIN_ID_011 11

#define CPLUGIN_NAME_011 "Generic HTTP Advanced [TESTING]"



#define C011_HTTP_METHOD_MAX_LEN 16

#define C011_HTTP_URI_MAX_LEN 240

#define C011_HTTP_HEADER_MAX_LEN 256

#define C011_HTTP_BODY_MAX_LEN 512



struct C011_ConfigStruct

{

  void zero_last() {

    HttpMethod[C011_HTTP_METHOD_MAX_LEN - 1] = 0;

    HttpUri[C011_HTTP_URI_MAX_LEN - 1] = 0;

    HttpHeader[C011_HTTP_HEADER_MAX_LEN - 1] = 0;

    HttpBody[C011_HTTP_BODY_MAX_LEN - 1] = 0;

  }



  char HttpMethod[C011_HTTP_METHOD_MAX_LEN] = {0};

  char HttpUri[C011_HTTP_URI_MAX_LEN] = {0};

  char HttpHeader[C011_HTTP_HEADER_MAX_LEN] = {0};

  char HttpBody[C011_HTTP_BODY_MAX_LEN] = {0};

};



boolean CPlugin_011(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_011;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = true;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 80;

        Protocol[protocolCount].usesID = false;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_011);

        break;

      }



    case CPLUGIN_WEBFORM_LOAD:

      {

        String escapeBuffer;



        C011_ConfigStruct customConfig;



        LoadCustomControllerSettings(event->ControllerIndex,(byte*)&customConfig, sizeof(customConfig));

        customConfig.zero_last();

        String methods[] = { F("GET"), F("POST"), F("PUT"), F("HEAD"), F("PATCH") };

        string += F("<TR><TD>HTTP Method :<TD><select name='P011httpmethod'>");

        for (byte i = 0; i < 5; i++)

        {

          string += F("<option value='");

          string += methods[i] + "'";

          string += methods[i].equals(customConfig.HttpMethod) ? F(" selected='selected'") : F("");

          string += F(">");

          string += methods[i];

          string += F("</option>");

        }

        string += F("</select>");



        string += F("<TR><TD>HTTP URI:<TD><input type='text' name='P011httpuri' size=80 maxlength='");

        string += C011_HTTP_URI_MAX_LEN-1;

        string += F("' value='");

        string += customConfig.HttpUri;



        string += F("'>");



        string += F("<TR><TD>HTTP Header:<TD><textarea name='P011httpheader' rows='4' cols='50' maxlength='");

        string += C011_HTTP_HEADER_MAX_LEN-1;

        string += F("'>");

        escapeBuffer=customConfig.HttpHeader;

        htmlEscape(escapeBuffer);

        string += escapeBuffer;

        string += F("</textarea>");



        string += F("<TR><TD>HTTP Body:<TD><textarea name='P011httpbody' rows='8' cols='50' maxlength='");

        string += C011_HTTP_BODY_MAX_LEN-1;

        string += F("'>");

        escapeBuffer=customConfig.HttpBody;

        htmlEscape(escapeBuffer);

        string += escapeBuffer;

        string += F("</textarea>");

        break;

      }



    case CPLUGIN_WEBFORM_SAVE:

      {

        C011_ConfigStruct customConfig;

        String httpmethod = WebServer.arg(F("P011httpmethod"));

        String httpuri = WebServer.arg(F("P011httpuri"));

        String httpheader = WebServer.arg(F("P011httpheader"));

        String httpbody = WebServer.arg(F("P011httpbody"));



        strlcpy(customConfig.HttpMethod, httpmethod.c_str(), sizeof(customConfig.HttpMethod));

        strlcpy(customConfig.HttpUri, httpuri.c_str(), sizeof(customConfig.HttpUri));

        strlcpy(customConfig.HttpHeader, httpheader.c_str(), sizeof(customConfig.HttpHeader));

        strlcpy(customConfig.HttpBody, httpbody.c_str(), sizeof(customConfig.HttpBody));

        customConfig.zero_last();

        SaveCustomControllerSettings(event->ControllerIndex,(byte*)&customConfig, sizeof(customConfig));

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

       success = Create_schedule_HTTP_C011(event);

        break;

      }



  }

  return success;

}
# 261 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C011.ino"
bool do_process_c011_delay_queue(int controller_number, const C011_queue_element& element, ControllerSettingsStruct& ControllerSettings) {

  WiFiClient client;

  if (!try_connect_host(controller_number, client, ControllerSettings))

    return false;



  return send_via_http(controller_number, client, element.txt);

}
# 287 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C011.ino"
boolean Create_schedule_HTTP_C011(struct EventStruct *event)

{

  int controller_number = CPLUGIN_ID_011;

  if (!WiFiConnected(100)) {

    return false;

  }

  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(event->ControllerIndex, ControllerSettings);



  C011_ConfigStruct customConfig;

  LoadCustomControllerSettings(event->ControllerIndex,(byte*)&customConfig, sizeof(customConfig));

  customConfig.zero_last();



  WiFiClient client;

  if (!try_connect_host(controller_number, client, ControllerSettings))

    return false;



  if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

    PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);



  String payload = create_http_request_auth(

    controller_number, event->ControllerIndex, ControllerSettings,

    String(customConfig.HttpMethod), customConfig.HttpUri);



  if (strlen(customConfig.HttpHeader) > 0)

    payload += customConfig.HttpHeader;

  ReplaceTokenByValue(payload, event);



  if (strlen(customConfig.HttpBody) > 0)

  {

    String body = String(customConfig.HttpBody);

    ReplaceTokenByValue(body, event);

    payload += F("\r\nContent-Length: ");

    payload += String(body.length());

    payload += F("\r\n\r\n");

    payload += body;

  }

  payload += F("\r\n");



  bool success = C011_DelayHandler.addToQueue(C011_queue_element(event->ControllerIndex, payload));

  scheduleNextDelayQueue(TIMER_C011_DELAY_QUEUE, C011_DelayHandler.getNextScheduleTime());

  return success;

}







void DeleteNotNeededValues(String &s, byte numberOfValuesWanted)

{

 numberOfValuesWanted++;

 for (byte i=1; i < 5; i++)

 {

    String startToken=String(F("%")) + i + F("%");

    String endToken=String(F("%/")) + i + F("%");





    if (i<numberOfValuesWanted)

    {



      s.replace(startToken, "");

      s.replace(endToken, "");

    }

    else

    {



      int startIndex=s.indexOf(startToken);

      int endIndex=s.indexOf(endToken);

      while(startIndex != -1 && endIndex != -1 && endIndex>startIndex)

    {

        String p = s.substring(startIndex,endIndex+4);



    s.replace(p, F(""));





        startIndex=s.indexOf(startToken);

        endIndex=s.indexOf(endToken);

    }

    }

 }

}
# 469 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C011.ino"
void ReplaceTokenByValue(String& s, struct EventStruct *event)

{







 addLog(LOG_LEVEL_DEBUG_MORE, F("HTTP before parsing: "));

 addLog(LOG_LEVEL_DEBUG_MORE, s);

  const byte valueCount = getValueCountFromSensorType(event->sensorType);

  DeleteNotNeededValues(s,valueCount);



 addLog(LOG_LEVEL_DEBUG_MORE, F("HTTP after parsing: "));

 addLog(LOG_LEVEL_DEBUG_MORE, s);



  parseControllerVariables(s, event, true);



 addLog(LOG_LEVEL_DEBUG_MORE, F("HTTP after replacements: "));

 addLog(LOG_LEVEL_DEBUG_MORE, s);

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C012.ino"
#ifdef USES_C012
# 15 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C012.ino"
#define CPLUGIN_012 

#define CPLUGIN_ID_012 12

#define CPLUGIN_NAME_012 "Blynk HTTP [TESTING]"



boolean CPlugin_012(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_012;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = true;

        Protocol[protocolCount].defaultPort = 80;

        Protocol[protocolCount].usesID = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_012);

        break;

      }



     case CPLUGIN_PROTOCOL_SEND:

      {



        byte valueCount = getValueCountFromSensorType(event->sensorType);

        C012_queue_element element(event, valueCount);

        if (ExtraTaskSettings.TaskDeviceValueNames[0][0] == 0)

          PluginCall(PLUGIN_GET_DEVICEVALUENAMES, event, dummyString);



        ControllerSettingsStruct ControllerSettings;

        LoadControllerSettings(event->ControllerIndex, ControllerSettings);



        for (byte x = 0; x < valueCount; x++)

        {

          bool isvalid;

          String formattedValue = formatUserVar(event, x, isvalid);

          if (isvalid) {

            element.txt[x] = F("update/V");

            element.txt[x] += event->idx + x;

            element.txt[x] += F("?value=");

            element.txt[x] += formattedValue;

            addLog(LOG_LEVEL_DEBUG_MORE, element.txt[x]);

          }

        }

        success = C012_DelayHandler.addToQueue(element);

        scheduleNextDelayQueue(TIMER_C012_DELAY_QUEUE, C012_DelayHandler.getNextScheduleTime());

        break;

      }

  }

  return success;

}
# 137 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C012.ino"
bool do_process_c012_delay_queue(int controller_number, const C012_queue_element& element, ControllerSettingsStruct& ControllerSettings) {

  while (element.txt[element.valuesSent] == "") {





    if (element.checkDone(true))

      return true;

  }

  return element.checkDone(Blynk_get(element.txt[element.valuesSent], element.controller_idx));

}



boolean Blynk_get(const String& command, byte controllerIndex, float *data )

{

  if (wifiStatus != ESPEASY_WIFI_SERVICES_INITIALIZED) {

    return false;

  }



  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(controllerIndex, ControllerSettings);



  if ((SecuritySettings.ControllerPassword[controllerIndex][0] == 0)) {

    addLog(LOG_LEVEL_ERROR, F("Blynk : No password set"));

    return false;

  }



  WiFiClient client;

  if (!try_connect_host(CPLUGIN_ID_012, client, ControllerSettings))

    return false;







  char request[300] = {0};

  sprintf_P(request,

            PSTR("GET /%s/%s HTTP/1.1\r\n Host: %s \r\n Connection: close\r\n\r\n"),

            SecuritySettings.ControllerPassword[controllerIndex],

            command.c_str(),

            ControllerSettings.getHost().c_str());

  addLog(LOG_LEVEL_DEBUG, request);

  client.print(request);



  unsigned long timer = millis() + 200;

  while (!client.available() && !timeOutReached(timer))

    yield();



  boolean success = false;

  char log[80] = {0};





  while (client_available(client)) {

    String line;

    safeReadStringUntil(client, line, '\n');

    addLog(LOG_LEVEL_DEBUG_MORE, line);



    if (line.substring(0, 15) == F("HTTP/1.1 200 OK")) {

      strcpy_P(log, PSTR("HTTP : Success"));

      success = true;

    }

    else if (line.substring(0, 24) == F("HTTP/1.1 400 Bad Request")) {

      strcpy_P(log, PSTR("HTTP : Unauthorized"));

    }

    else if (line.substring(0, 25) == F("HTTP/1.1 401 Unauthorized")) {

      strcpy_P(log, PSTR("HTTP : Unauthorized"));

    }

    addLog(LOG_LEVEL_DEBUG, log);





    if (data && line.startsWith("["))

    {

      String strValue = line;

      byte pos = strValue.indexOf('"',2);

      strValue = strValue.substring(2, pos);

      strValue.trim();

      float value = strValue.toFloat();

      *data = value;

      success = true;



      char value_char[5] = {0};

      strValue.toCharArray(value_char, 5);

      sprintf_P(log, PSTR("Blynk get - %s => %s"),command.c_str(), value_char );

      addLog(LOG_LEVEL_DEBUG, log);

    }

    yield();

  }

  strcpy_P(log, PSTR("HTTP : closing connection (012)"));

  addLog(LOG_LEVEL_DEBUG, log);



  client.flush();

  client.stop();





  timer = millis() + Settings.MessageDelay;

  while (!timeOutReached(timer))

              backgroundtasks();



  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C013.ino"
#ifdef USES_C013
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C013.ino"
#define CPLUGIN_013 

#define CPLUGIN_ID_013 13

#define CPLUGIN_NAME_013 "ESPEasy P2P Networking"



WiFiUDP C013_portUDP;



struct infoStruct

{

  byte header = 255;

  byte ID = 3;

  byte sourcelUnit;

  byte destUnit;

  byte sourceTaskIndex;

  byte destTaskIndex;

  byte deviceNumber;

  char taskName[26];

  char ValueNames[VARS_PER_TASK][26];

};



struct dataStruct

{

  byte header = 255;

  byte ID = 5;

  byte sourcelUnit;

  byte destUnit;

  byte sourceTaskIndex;

  byte destTaskIndex;

  float Values[VARS_PER_TASK];

};





boolean CPlugin_013(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case CPLUGIN_PROTOCOL_ADD:

      {

        Protocol[++protocolCount].Number = CPLUGIN_ID_013;

        Protocol[protocolCount].usesMQTT = false;

        Protocol[protocolCount].usesTemplate = false;

        Protocol[protocolCount].usesAccount = false;

        Protocol[protocolCount].usesPassword = false;

        Protocol[protocolCount].defaultPort = 65501;

        Protocol[protocolCount].usesID = false;

        Protocol[protocolCount].Custom = true;

        break;

      }



    case CPLUGIN_GET_DEVICENAME:

      {

        string = F(CPLUGIN_NAME_013);

        break;

      }



    case CPLUGIN_PROTOCOL_TEMPLATE:

      {

        event->String1 = "";

        event->String2 = "";

        break;

      }



    case CPLUGIN_INIT:

      {



        break;

      }



    case CPLUGIN_TASK_CHANGE_NOTIFICATION:

      {

        C013_SendUDPTaskInfo(0, event->TaskIndex, event->TaskIndex);

        break;

      }



    case CPLUGIN_PROTOCOL_SEND:

      {

        C013_SendUDPTaskData(0, event->TaskIndex, event->TaskIndex);

        break;

      }



    case CPLUGIN_UDP_IN:

      {

        C013_Receive(event);

        break;

      }



  }

  return success;

}
# 201 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C013.ino"
void C013_SendUDPTaskInfo(byte destUnit, byte sourceTaskIndex, byte destTaskIndex)

{

  if (!WiFiConnected(100)) {

    return;

  }

  struct infoStruct infoReply;

  infoReply.sourcelUnit = Settings.Unit;

  infoReply.sourceTaskIndex = sourceTaskIndex;

  infoReply.destTaskIndex = destTaskIndex;

  LoadTaskSettings(infoReply.sourceTaskIndex);

  infoReply.deviceNumber = Settings.TaskDeviceNumber[infoReply.sourceTaskIndex];

  strcpy(infoReply.taskName, getTaskDeviceName(infoReply.sourceTaskIndex).c_str());

  for (byte x = 0; x < VARS_PER_TASK; x++)

    strcpy(infoReply.ValueNames[x], ExtraTaskSettings.TaskDeviceValueNames[x]);



  if (destUnit != 0)

  {

    infoReply.destUnit = destUnit;

    C013_sendUDP(destUnit, (byte*)&infoReply, sizeof(infoStruct));

    delay(10);

  } else {

    for (NodesMap::iterator it = Nodes.begin(); it != Nodes.end(); ++it) {

      if (it->first != Settings.Unit) {

        infoReply.destUnit = it->first;

        C013_sendUDP(it->first, (byte*)&infoReply, sizeof(infoStruct));

        delay(10);

      }

    }

  }

  delay(50);

}



void C013_SendUDPTaskData(byte destUnit, byte sourceTaskIndex, byte destTaskIndex)

{

  if (!WiFiConnected(100)) {

    return;

  }

  struct dataStruct dataReply;

  dataReply.sourcelUnit = Settings.Unit;

  dataReply.sourceTaskIndex = sourceTaskIndex;

  dataReply.destTaskIndex = destTaskIndex;

  for (byte x = 0; x < VARS_PER_TASK; x++)

    dataReply.Values[x] = UserVar[dataReply.sourceTaskIndex * VARS_PER_TASK + x];



  if (destUnit != 0)

  {

    dataReply.destUnit = destUnit;

    C013_sendUDP(destUnit, (byte*) &dataReply, sizeof(dataStruct));

    delay(10);

  } else {

    for (NodesMap::iterator it = Nodes.begin(); it != Nodes.end(); ++it) {

      if (it->first != Settings.Unit) {

        dataReply.destUnit = it->first;

        C013_sendUDP(it->first, (byte*) &dataReply, sizeof(dataStruct));

        delay(10);

      }

    }

  }

  delay(50);

}
# 329 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_C013.ino"
void C013_sendUDP(byte unit, byte* data, byte size)

{

  if (!WiFiConnected(100)) {

    return;

  }

  NodesMap::iterator it;

  if (unit != 255) {

    it = Nodes.find(unit);

    if (it == Nodes.end())

      return;

    if (it->second.ip[0] == 0)

      return;

  }

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE)) {

    String log = F("C013 : Send UDP message to ");

    log += unit;

    addLog(LOG_LEVEL_DEBUG_MORE, log);

  }



  statusLED(true);



  IPAddress remoteNodeIP;

  if (unit == 255)

    remoteNodeIP = {255, 255, 255, 255};

  else

    remoteNodeIP = it->second.ip;

  if (!beginWiFiUDP_randomPort(C013_portUDP)) return;

  if (C013_portUDP.beginPacket(remoteNodeIP, Settings.UDPPort) == 0) return;

  C013_portUDP.write(data, size);

  C013_portUDP.endPacket();

  C013_portUDP.stop();

}



void C013_Receive(struct EventStruct *event) {

  if (event->Par2 < 6) return;

  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE)) {

    if (event->Data[1] > 1 && event->Data[1] < 6)

    {

      String log = (F("C013 : msg "));

      for (byte x = 1; x < 6; x++)

      {

        log += " ";

        log += (int)event->Data[x];

      }

      addLog(LOG_LEVEL_DEBUG_MORE, log);

    }

  }



  switch (event->Data[1]) {

    case 2:

      {



        break;

      }



    case 3:

      {

        struct infoStruct infoReply;

        if (static_cast<size_t>(event->Par2) < sizeof(infoStruct)) {

          addLog(LOG_LEVEL_DEBUG, F("C013_Receive: Received data smaller than infoStruct, discarded"));

        } else {

          memcpy((byte*)&infoReply, (byte*)event->Data, sizeof(infoStruct));







          if (Settings.TaskDeviceNumber[infoReply.destTaskIndex] == 0)

          {

            taskClear(infoReply.destTaskIndex, false);

            Settings.TaskDeviceNumber[infoReply.destTaskIndex] = infoReply.deviceNumber;

            Settings.TaskDeviceDataFeed[infoReply.destTaskIndex] = 1;

            for (byte x = 0; x < CONTROLLER_MAX; x++)

              Settings.TaskDeviceSendData[x][infoReply.destTaskIndex] = false;

            strcpy(ExtraTaskSettings.TaskDeviceName, infoReply.taskName);

            for (byte x = 0; x < VARS_PER_TASK; x++)

              strcpy( ExtraTaskSettings.TaskDeviceValueNames[x], infoReply.ValueNames[x]);

            ExtraTaskSettings.TaskIndex = infoReply.destTaskIndex;

            SaveTaskSettings(infoReply.destTaskIndex);

            SaveSettings();

          }

        }

        break;

      }



    case 4:

      {



        break;

      }



    case 5:

      {

        struct dataStruct dataReply;

        if (static_cast<size_t>(event->Par2) < sizeof(dataStruct)) {

          addLog(LOG_LEVEL_DEBUG, F("C013_Receive: Received data smaller than dataStruct, discarded"));

        } else {

          memcpy((byte*)&dataReply, (byte*)event->Data, sizeof(dataStruct));





          if (Settings.TaskDeviceDataFeed[dataReply.destTaskIndex] != 0)

          {

            for (byte x = 0; x < VARS_PER_TASK; x++)

            {

              UserVar[dataReply.destTaskIndex * VARS_PER_TASK + x] = dataReply.Values[x];

            }

            if (Settings.UseRules)

              createRuleEvents(dataReply.destTaskIndex);

          }

        }

        break;

      }

  }

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_CPlugin_DomoticzHelper.ino"
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_CPlugin_DomoticzHelper.ino"
String humStatDomoticz(struct EventStruct *event, byte rel_index){

  const int hum = UserVar[event->BaseVarIndex + rel_index];

  if (hum < 30) { return formatUserVarDomoticz(2); }

  if (hum < 40) { return formatUserVarDomoticz(0); }

  if (hum < 59) { return formatUserVarDomoticz(1); }

  return formatUserVarDomoticz(3);

}



int mapRSSItoDomoticz() {

  long rssi = WiFi.RSSI();

  if (-50 < rssi) { return 10; }

  if (rssi <= -98) { return 0; }

  rssi = rssi + 97;

  return (rssi / 5) + 1;

}



int mapVccToDomoticz() {

  #if FEATURE_ADC_VCC



    if (vcc < 2.6) return 0;

    return (vcc - 2.6) * 100;

  #else

    return 255;

  #endif

}





String formatUserVarDomoticz(struct EventStruct *event, byte rel_index) {

  String text = formatUserVarNoCheck(event, rel_index);

  text += F(";");

  return text;

}



String formatUserVarDomoticz(int value) {

  String text;

  text += value;

  text.trim();

  text += F(";");

  return text;

}



String formatDomoticzSensorType(struct EventStruct *event) {

  String values;

  switch (event->sensorType)

  {

    case SENSOR_TYPE_SINGLE:

      values = formatUserVarDomoticz(event, 0);

      break;

    case SENSOR_TYPE_LONG:

      values = (unsigned long)UserVar[event->BaseVarIndex] + ((unsigned long)UserVar[event->BaseVarIndex + 1] << 16);

      break;

    case SENSOR_TYPE_DUAL:

      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      break;

    case SENSOR_TYPE_TEMP_HUM:





      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      values += humStatDomoticz(event, 1);

      break;

    case SENSOR_TYPE_TEMP_HUM_BARO:





      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      values += humStatDomoticz(event, 1);

      values += formatUserVarDomoticz(event, 2);

      values += formatUserVarDomoticz(0);

      break;

    case SENSOR_TYPE_TEMP_BARO:





      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      values += formatUserVarDomoticz(0);

      values += formatUserVarDomoticz(0);

      break;

    case SENSOR_TYPE_TEMP_EMPTY_BARO:





      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 2);

      values += formatUserVarDomoticz(0);

      values += formatUserVarDomoticz(0);

      break;

    case SENSOR_TYPE_TRIPLE:

      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      values += formatUserVarDomoticz(event, 2);

      break;

    case SENSOR_TYPE_QUAD:

      values = formatUserVarDomoticz(event, 0);

      values += formatUserVarDomoticz(event, 1);

      values += formatUserVarDomoticz(event, 2);

      values += formatUserVarDomoticz(event, 3);

      break;

    case SENSOR_TYPE_WIND:





      values = formatUserVarDomoticz(event, 0);

      values += getBearing(UserVar[event->BaseVarIndex]);

      values += ";";



      values += toString((UserVar[event->BaseVarIndex + 1] * 10),ExtraTaskSettings.TaskDeviceValueDecimals[1]);

      values += ";";

      values += toString((UserVar[event->BaseVarIndex + 2] * 10),ExtraTaskSettings.TaskDeviceValueDecimals[2]);

      values += ";";

      values += formatUserVarDomoticz(0);

      values += formatUserVarDomoticz(0);

      break;

    case SENSOR_TYPE_SWITCH:

    case SENSOR_TYPE_DIMMER:



      break;

    default:

    {

      String log = F("Domoticz Controller: Not yet implemented sensor type: ");

      log += event->sensorType;

      log += F(" idx: ");

      log += event->idx;

      addLog(LOG_LEVEL_ERROR, log);

      break;

    }

  }



  int index_last_char = values.length() -1;

  if (index_last_char > 0 && values.charAt(index_last_char) == ';') {

    values.setCharAt(index_last_char, ' ');

  }

  values.trim();

  {

    String log = F(" Domoticz: Sensortype: ");

    log += event->sensorType;

    log += F(" idx: ");

    log += event->idx;

    log += F(" values: ");

    log += values;

    addLog(LOG_LEVEL_INFO, log);

  }

  return values;

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_CPlugin_SensorTypeHelper.ino"
# 9 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_CPlugin_SensorTypeHelper.ino"
byte getValueCountFromSensorType(byte sensorType)

{

  switch (sensorType)

  {

    case SENSOR_TYPE_NONE:

      return 0;

    case SENSOR_TYPE_SINGLE:

    case SENSOR_TYPE_SWITCH:

    case SENSOR_TYPE_DIMMER:

      return 1;

    case SENSOR_TYPE_LONG:

      return 1;

    case SENSOR_TYPE_TEMP_HUM:

    case SENSOR_TYPE_TEMP_BARO:

    case SENSOR_TYPE_DUAL:

      return 2;

    case SENSOR_TYPE_TEMP_HUM_BARO:

    case SENSOR_TYPE_TEMP_EMPTY_BARO:

    case SENSOR_TYPE_TRIPLE:

    case SENSOR_TYPE_WIND:

      return 3;

    case SENSOR_TYPE_QUAD:

      return 4;

  }

  addLog(LOG_LEVEL_ERROR, F("getValueCountFromSensorType: Unknown sensortype"));

  return 0;

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_N001_Email.ino"
#ifdef USES_N001
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_N001_Email.ino"
#define NPLUGIN_001 

#define NPLUGIN_ID_001 1

#define NPLUGIN_NAME_001 "Email (SMTP)"



#define NPLUGIN_001_TIMEOUT 5000







boolean NPlugin_001(byte function, struct EventStruct *event, String& string)

{

 boolean success = false;



 switch (function) {

 case NPLUGIN_PROTOCOL_ADD:

 {

  Notification[++notificationCount].Number = NPLUGIN_ID_001;

  Notification[notificationCount].usesMessaging = true;

  Notification[notificationCount].usesGPIO = 0;

  break;

 }



 case NPLUGIN_GET_DEVICENAME:

 {

  string = F(NPLUGIN_NAME_001);

  break;

 }
# 97 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_N001_Email.ino"
 case NPLUGIN_NOTIFY:

 {

  NotificationSettingsStruct NotificationSettings;

  LoadNotificationSettings(event->NotificationIndex, (byte*)&NotificationSettings, sizeof(NotificationSettings));

  String subject = NotificationSettings.Subject;

  String body = "";

  if (event->String1.length() > 0)

   body = event->String1;

  else

   body = NotificationSettings.Body;

  subject = parseTemplate(subject, subject.length());

  body = parseTemplate(body, body.length());

  NPlugin_001_send(NotificationSettings, subject, body);

  success = true;

  break;

 }

 }

 return success;

}



boolean NPlugin_001_send(const NotificationSettingsStruct& notificationsettings, const String& aSub, String& aMesg)

{



 boolean myStatus = false;





 WiFiClient client;

 String aHost = notificationsettings.Server;

 addLog(LOG_LEVEL_DEBUG, String(F("EMAIL: Connecting to ")) + aHost + notificationsettings.Port);

 if (client.connect(aHost.c_str(), notificationsettings.Port) != 1) {

  addLog(LOG_LEVEL_ERROR, String(F("EMAIL: Error connecting to ")) + aHost + notificationsettings.Port);

  myStatus = false;

 }else {

  String mailheader = F(

   "From: $nodename <$emailfrom>\r\n"

   "To: $ato\r\n"

   "Subject: $subject\r\n"

   "Reply-To: $nodename <$emailfrom>\r\n"

   "MIME-VERSION: 1.0\r\n"

   "Content-type: text/html; charset=UTF-8\r\n"

   "X-Mailer: EspEasy v$espeasyversion\r\n\r\n"

   );



    String email_address = notificationsettings.Sender;

  int pos_less = email_address.indexOf('<');

  if (pos_less == -1) {



   mailheader.replace(String(F("$nodename")), Settings.Name);

   mailheader.replace(String(F("$emailfrom")), notificationsettings.Sender);

  } else {

   String senderName = email_address.substring(0, pos_less);

   senderName.replace("\"", "");

   String address = email_address.substring(pos_less + 1);

   address.replace("<", "");

   address.replace(">", "");

   address.trim();

   senderName.trim();

   mailheader.replace(String(F("$nodename")), senderName);

   mailheader.replace(String(F("$emailfrom")), address);

  }



  mailheader.replace(String(F("$nodename")), Settings.Name);

  mailheader.replace(String(F("$emailfrom")), notificationsettings.Sender);

  mailheader.replace(String(F("$ato")), notificationsettings.Receiver);

  mailheader.replace(String(F("$subject")), aSub);

  mailheader.replace(String(F("$espeasyversion")), String(BUILD));

  aMesg.replace(F("\r"), F("<br/>"));







  while (true) {

   if (!NPlugin_001_MTA(client, "", F("220 "))) break;

   if (!NPlugin_001_MTA(client, String(F("EHLO ")) + notificationsettings.Domain, F("250 "))) break;

   if (!NPlugin_001_Auth(client, notificationsettings.User, notificationsettings.Pass)) break;

   if (!NPlugin_001_MTA(client, String(F("MAIL FROM:<")) + notificationsettings.Sender + ">", F("250 "))) break;



   bool nextAddressAvailable = true;

   int i = 0;

   String emailTo = "";

   if (!getNextMailAddress(notificationsettings.Receiver, emailTo, i)) {

    addLog(LOG_LEVEL_ERROR, F("Email: No recipient given"));

    break;

   }

   while (nextAddressAvailable) {

    String mailFound = F("Email: To ");

    mailFound += emailTo;

    addLog(LOG_LEVEL_INFO, mailFound);

    if (!NPlugin_001_MTA(client, String(F("RCPT TO:<")) + emailTo + ">", F("250 "))) break;

    ++i;

    nextAddressAvailable = getNextMailAddress(notificationsettings.Receiver, emailTo, i);

   }



   if (!NPlugin_001_MTA(client, F("DATA"), F("354 "))) break;

   if (!NPlugin_001_MTA(client, mailheader + aMesg + String(F("\r\n.\r\n")), F("250 "))) break;



   myStatus = true;

   break;

  }



  client.flush();

  client.stop();



  if (myStatus == true) {

   addLog(LOG_LEVEL_INFO, F("EMAIL: Connection Closed Successfully"));

  }else {

   String log = F("EMAIL: Connection Closed With Error. Used header: ");

   log += mailheader;

   addLog(LOG_LEVEL_ERROR, log);

  }

 }

 return myStatus;

}



boolean NPlugin_001_Auth(WiFiClient& client, String user, String pass)

{

 if (user.length() == 0 || pass.length() == 0) {



  return true;

 }

 if (!NPlugin_001_MTA(client, String(F("AUTH LOGIN")), F("334 "))) return false;

 base64 encoder;

 String auth;

 auth = encoder.encode(user);

 if (!NPlugin_001_MTA(client, auth, F("334 "))) return false;

 auth = encoder.encode(pass);

 if (!NPlugin_001_MTA(client, auth, F("235 "))) return false;



 return true;

}



boolean NPlugin_001_MTA(WiFiClient& client, String aStr, const String &aWaitForPattern)

{

 addLog(LOG_LEVEL_DEBUG, aStr);



 if (aStr.length()) client.println(aStr);





 unsigned long timer = millis() + NPLUGIN_001_TIMEOUT;

 backgroundtasks();

 while (true) {

  if (timeOutReached(timer)) {

   String log = F("Plugin_001_MTA: timeout. ");

   log += aStr;

   addLog(LOG_LEVEL_ERROR, log);

   return false;

  }



  yield();





  String line;

  safeReadStringUntil(client, line, '\n');



  addLog(LOG_LEVEL_DEBUG, line);



  if (line.indexOf(aWaitForPattern) >= 0) {

   return true;

  }

 }



 return false;

}



bool getNextMailAddress(const String& data, String& address, int index)

{

 int found = 0;

 int strIndex[] = { 0, -1 };

 const int maxIndex = data.length() - 1;



 for (int i = 0; i <= maxIndex && found <= index; i++) {

  if (data.charAt(i) == ',' || i == maxIndex) {

   found++;

   strIndex[0] = strIndex[1] + 1;

   strIndex[1] = (i == maxIndex) ? i + 1 : i;

  }

 }

 if (found > index) {

  address = data.substring(strIndex[0], strIndex[1]);

  return true;

 }

 return false;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_N002_Buzzer.ino"
#ifdef USES_N002
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_N002_Buzzer.ino"
#define NPLUGIN_002 

#define NPLUGIN_ID_002 2

#define NPLUGIN_NAME_002 "Buzzer"



boolean NPlugin_002(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case NPLUGIN_PROTOCOL_ADD:

      {

        Notification[++notificationCount].Number = NPLUGIN_ID_002;

        Notification[notificationCount].usesMessaging = false;

        Notification[notificationCount].usesGPIO=1;

        break;

      }



    case NPLUGIN_GET_DEVICENAME:

      {

        string = F(NPLUGIN_NAME_002);

        break;

      }
# 89 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_N002_Buzzer.ino"
    case NPLUGIN_NOTIFY:

      {

        NotificationSettingsStruct NotificationSettings;

        LoadNotificationSettings(event->NotificationIndex, (byte*)&NotificationSettings, sizeof(NotificationSettings));



        #ifndef ESP32



        tone_espEasy(NotificationSettings.Pin1, 500, 500);

        #endif

        success = true;

      }



  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P001_Switch.ino"
#ifdef USES_P001
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P001_Switch.ino"
#define PLUGIN_001 

#define PLUGIN_ID_001 1

#define PLUGIN_NAME_001 "Switch input - Switch"

#define PLUGIN_VALUENAME1_001 "Switch"

#if defined(ESP8266)

  Servo servo1;

  Servo servo2;

#endif

#define GPIO_MAX 17



#define PLUGIN_001_TYPE_SWITCH 0

#define PLUGIN_001_TYPE_DIMMER 3

#define PLUGIN_001_BUTTON_TYPE_NORMAL_SWITCH 0

#define PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_LOW 1

#define PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_HIGH 2



boolean Plugin_001_read_switch_state(struct EventStruct *event) {

  return digitalRead(Settings.TaskDevicePin1[event->TaskIndex]) == HIGH;

}



boolean Plugin_001(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static boolean switchstate[TASKS_MAX];

  static boolean outputstate[TASKS_MAX];

  static int8_t PinMonitor[GPIO_MAX];

  static int8_t PinMonitorState[GPIO_MAX];



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_001;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = true;

        Device[deviceCount].InverseLogicOption = true;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_001);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_001));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        String options[2];

        options[0] = F("Switch");

        options[1] = F("Dimmer");

        int optionValues[2] = { PLUGIN_001_TYPE_SWITCH, PLUGIN_001_TYPE_DIMMER };

        const byte switchtype = P001_getSwitchType(event);

        addFormSelector(F("Switch Type"), F("plugin_001_type"), 2, options, optionValues, switchtype);



        if (switchtype == PLUGIN_001_TYPE_DIMMER)

        {

          char tmpString[128];

          sprintf_P(tmpString, PSTR("<TR><TD>Dim value:<TD><input type='text' name='plugin_001_dimvalue' value='%u'>"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

          addHtml(tmpString);

        }



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        String buttonOptions[3];

        buttonOptions[0] = F("Normal Switch");

        buttonOptions[1] = F("Push Button Active Low");

        buttonOptions[2] = F("Push Button Active High");

        int buttonOptionValues[3] = {PLUGIN_001_BUTTON_TYPE_NORMAL_SWITCH, PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_LOW, PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_HIGH};

        addFormSelector(F("Switch Button Type"), F("plugin_001_button"), 3, buttonOptions, buttonOptionValues, choice);



        addFormCheckBox(F("Send Boot state"),F("plugin_001_boot"),

          Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_001_type"));

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == PLUGIN_001_TYPE_DIMMER)

        {

          Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_001_dimvalue"));

        }



        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_001_button"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = isFormItemChecked(F("plugin_001_boot"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        for (byte x=0; x < GPIO_MAX; x++){

           PinMonitor[x] = 0;

           PinMonitorState[x] = 0;

          }



        if (Settings.TaskDevicePin1PullUp[event->TaskIndex])

          pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT_PULLUP);

        else

          pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT);



        setPinState(PLUGIN_ID_001, Settings.TaskDevicePin1[event->TaskIndex], PIN_MODE_INPUT, 0);



        switchstate[event->TaskIndex] = Plugin_001_read_switch_state(event);

        outputstate[event->TaskIndex] = switchstate[event->TaskIndex];





        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3])

        {

          switchstate[event->TaskIndex] = !switchstate[event->TaskIndex];

          outputstate[event->TaskIndex] = !outputstate[event->TaskIndex];

        }

        success = true;

        break;

      }



    case PLUGIN_REQUEST:

      {

        String device = parseString(string, 1);

        String command = parseString(string, 2);

        String strPar1 = parseString(string, 3);

        if (device == F("gpio") && command == F("pinstate"))

        {

          int par1;

          if (validIntFromString(strPar1, par1)) {

            string = digitalRead(par1);

          }

          success = true;

        }

        break;

      }



    case PLUGIN_UNCONDITIONAL_POLL:

      {



        for (byte x=0; x < GPIO_MAX; x++)

           if (PinMonitor[x] != 0){

             byte state = digitalRead(x);

             if (PinMonitorState[x] != state){

               String eventString = F("GPIO#");

               eventString += x;

               eventString += F("=");

               eventString += state;

               rulesProcessing(eventString);

               PinMonitorState[x] = state;

             }

           }

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        const boolean state = Plugin_001_read_switch_state(event);

        if (state != switchstate[event->TaskIndex])

        {

          switchstate[event->TaskIndex] = state;

          const boolean currentOutputState = outputstate[event->TaskIndex];

          boolean new_outputState = currentOutputState;

          switch(Settings.TaskDevicePluginConfig[event->TaskIndex][2]) {

            case PLUGIN_001_BUTTON_TYPE_NORMAL_SWITCH:

                new_outputState = state;

              break;

            case PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_LOW:

              if (!state)

                new_outputState = !currentOutputState;

              break;

            case PLUGIN_001_BUTTON_TYPE_PUSH_ACTIVE_HIGH:

              if (state)

                new_outputState = !currentOutputState;

              break;

          }





          if (currentOutputState != new_outputState)

          {

            outputstate[event->TaskIndex] = new_outputState;

            boolean sendState = new_outputState;

            if (Settings.TaskDevicePin1Inversed[event->TaskIndex])

              sendState = !sendState;



            byte output_value = sendState ? 1 : 0;

            event->sensorType = SENSOR_TYPE_SWITCH;

            if (P001_getSwitchType(event) == PLUGIN_001_TYPE_DIMMER) {

              if (sendState) {

                output_value = Settings.TaskDevicePluginConfig[event->TaskIndex][1];



                event->sensorType = SENSOR_TYPE_DIMMER;

              }

            }

            UserVar[event->BaseVarIndex] = output_value;

            String log = F("SW   : Switch state ");

            log += state ? F("1") : F("0");

            log += F(" Output value ");

            log += output_value;

            addLog(LOG_LEVEL_INFO, log);

            sendData(event);

          }

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {





        String log = F("SW   : State ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String log = "";

        String command = parseString(string, 1);



        if (command == F("gpio"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= PIN_D_MAX)

          {

            if (event->Par2 == 2) {

              pinMode(event->Par1, INPUT);

              setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_INPUT, 0);

            } else {

              pinMode(event->Par1, OUTPUT);

              digitalWrite(event->Par1, event->Par2);

              setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            }

            log = String(F("SW   : GPIO ")) + String(event->Par1) + String(F(" Set to ")) + String(event->Par2);

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }



        if (command == F("pwm"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= PIN_D_MAX)

          {

            #if defined(ESP8266)

              pinMode(event->Par1, OUTPUT);

            #endif

            if(event->Par3 != 0)

            {

              byte prev_mode;

              uint16_t prev_value;

              getPinState(PLUGIN_ID_001, event->Par1, &prev_mode, &prev_value);

              if(prev_mode != PIN_MODE_PWM)

                prev_value = 0;



              int32_t step_value = ((event->Par2 - prev_value) << 12) / event->Par3;

              int32_t curr_value = prev_value << 12;



              int i = event->Par3;

              while(i--){

                curr_value += step_value;

                int16_t new_value;

                new_value = (uint16_t)(curr_value >> 12);

                #if defined(ESP8266)

                  analogWrite(event->Par1, new_value);

                #endif

                #if defined(ESP32)

                  analogWriteESP32(event->Par1, new_value);

                #endif

                delay(1);

              }

            }



            #if defined(ESP8266)

              analogWrite(event->Par1, event->Par2);

            #endif

            #if defined(ESP32)

              analogWriteESP32(event->Par1, event->Par2);

            #endif

            setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_PWM, event->Par2);

            log = String(F("SW   : GPIO ")) + String(event->Par1) + String(F(" Set PWM to ")) + String(event->Par2);

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }



        if (command == F("pulse"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= PIN_D_MAX)

          {

            pinMode(event->Par1, OUTPUT);

            digitalWrite(event->Par1, event->Par2);

            delay(event->Par3);

            digitalWrite(event->Par1, !event->Par2);

            setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("SW   : GPIO ")) + String(event->Par1) + String(F(" Pulsed for ")) + String(event->Par3) + String(F(" mS"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }



        if ((command == F("longpulse")) || (command == F("longpulse_ms")))

        {

          boolean time_in_msec = command == F("longpulse_ms");

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= PIN_D_MAX)

          {

            const bool pinStateHigh = event->Par2 != 0;

            const uint16_t pinStateValue = pinStateHigh ? 1 : 0;

            const uint16_t inversePinStateValue = pinStateHigh ? 0 : 1;

            pinMode(event->Par1, OUTPUT);

            digitalWrite(event->Par1, pinStateValue);

            setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, pinStateValue);

            unsigned long timer = time_in_msec ? event->Par3 : event->Par3 * 1000;



            setPluginTaskTimer(timer, PLUGIN_ID_001, event->TaskIndex, event->Par1, inversePinStateValue);

            log = String(F("SW   : GPIO ")) + String(event->Par1) +

                  String(F(" Pulse set for ")) + String(event->Par3) + String(time_in_msec ? F(" msec") : F(" sec"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }



        if (command == F("servo"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 2)

            switch (event->Par1)

            {

              case 1:





                #if defined(ESP8266)

                  servo1.attach(event->Par2);

                  servo1.write(event->Par3);

                #endif

                break;

              case 2:

                #if defined(ESP8266)

                  servo2.attach(event->Par2);

                  servo2.write(event->Par3);

                #endif

                break;

            }

          setPinState(PLUGIN_ID_001, event->Par2, PIN_MODE_SERVO, event->Par3);

          log = String(F("SW   : GPIO ")) + String(event->Par2) + String(F(" Servo set to ")) + String(event->Par3);

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par2, log, 0));

        }



        if (command == F("status"))

        {

          if (parseString(string, 2) == F("gpio"))

          {

            success = true;

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par2, dummyString, 0));

          }

        }



        if (command == F("monitor"))

        {

          if (parseString(string, 2) == F("gpio"))

          {

            PinMonitor[event->Par2] = 1;

            success = true;

          }

        }



        if (command == F("inputswitchstate"))

        {

          success = true;

          UserVar[event->Par1 * VARS_PER_TASK] = event->Par2;

          outputstate[event->Par1] = event->Par2;

        }







        if (command == F("rtttl"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 16)

          {

            pinMode(event->Par1, OUTPUT);



            String tmpString=string;

            tmpString.replace('-', '#');



            play_rtttl(event->Par1, tmpString.c_str());

            setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("SW   : ")) + string;

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }





        if (command == F("tone"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= PIN_D_MAX)

          {

            pinMode(event->Par1, OUTPUT);

            tone_espEasy(event->Par1, event->Par2, event->Par3);

            setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("SW   : ")) + string;

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_001, event->Par1, log, 0));

          }

        }



        break;

      }



    case PLUGIN_TIMER_IN:

      {

        digitalWrite(event->Par1, event->Par2);

        setPinState(PLUGIN_ID_001, event->Par1, PIN_MODE_OUTPUT, event->Par2);

        break;

      }

  }

  return success;

}





#if defined(ESP32)

void analogWriteESP32(int pin, int value)

{



  int8_t ledChannel = -1;

  for(byte x = 0; x < 16; x++)

    if (ledChannelPin[x] == pin)

      ledChannel = x;



  if(ledChannel == -1)

    {

      for(byte x = 0; x < 16; x++)

        if (ledChannelPin[x] == -1)

          {

            int freq = 5000;

            ledChannelPin[x] = pin;

            ledcSetup(x, freq, 10);

            ledcAttachPin(pin, x);

            ledChannel = x;

            break;

          }

    }

  ledcWrite(ledChannel, value);

}

#endif





byte P001_getSwitchType(struct EventStruct *event) {

  byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

  switch (choice) {

    case 2:

    case PLUGIN_001_TYPE_DIMMER:

      choice = PLUGIN_001_TYPE_DIMMER;

      break;

    case 1:

    case PLUGIN_001_TYPE_SWITCH:

    default:

      choice = PLUGIN_001_TYPE_SWITCH;

      break;

  }

  return choice;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P002_ADC.ino"
#ifdef USES_P002
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P002_ADC.ino"
#define PLUGIN_002 

#define PLUGIN_ID_002 2

#define PLUGIN_NAME_002 "Analog input - internal"

#define PLUGIN_VALUENAME1_002 "Analog"



uint32_t Plugin_002_OversamplingValue = 0;

uint16_t Plugin_002_OversamplingCount = 0;





boolean Plugin_002(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_002;

        Device[deviceCount].Type = DEVICE_TYPE_ANALOG;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_002);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_002));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        #if defined(ESP32)

          addHtml(F("<TR><TD>Analog Pin:<TD>"));

          addPinSelect(false, "taskdevicepin1", Settings.TaskDevicePin1[event->TaskIndex]);

        #endif



        addFormCheckBox(F("Oversampling"), F("plugin_002_oversampling"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        addFormSubHeader(F("Two Point Calibration"));



        addFormCheckBox(F("Calibration Enabled"), F("plugin_002_cal"), Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        addFormNumericBox(F("Point 1"), F("plugin_002_adc1"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][0], 0, 1023);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_002_out1"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0], 3), 10);



        addFormNumericBox(F("Point 2"), F("plugin_002_adc2"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][1], 0, 1023);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_002_out2"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1], 3), 10);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = isFormItemChecked(F("plugin_002_oversampling"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = isFormItemChecked(F("plugin_002_cal"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = getFormItemInt(F("plugin_002_adc1"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = getFormItemFloat(F("plugin_002_out1"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = getFormItemInt(F("plugin_002_adc2"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] = getFormItemFloat(F("plugin_002_out2"));



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

        {

          #if defined(ESP8266)

            Plugin_002_OversamplingValue += analogRead(A0);

          #endif

          #if defined(ESP32)

            Plugin_002_OversamplingValue += analogRead(Settings.TaskDevicePin1[event->TaskIndex]);

          #endif

          Plugin_002_OversamplingCount ++;

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        String log = F("ADC  : Analog value: ");



        if (Plugin_002_OversamplingCount > 0)

        {

          UserVar[event->BaseVarIndex] = (float)Plugin_002_OversamplingValue / Plugin_002_OversamplingCount;

          Plugin_002_OversamplingValue = 0;

          Plugin_002_OversamplingCount = 0;



          log += String(UserVar[event->BaseVarIndex], 3);

        }

        else

        {

          #if defined(ESP8266)

            int16_t value = analogRead(A0);

          #endif

          #if defined(ESP32)

            int16_t value = analogRead(Settings.TaskDevicePin1[event->TaskIndex]);

          #endif

          UserVar[event->BaseVarIndex] = (float)value;



          log += value;

        }



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3])

        {

          int adc1 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][0];

          int adc2 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][1];

          float out1 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0];

          float out2 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1];

          if (adc1 != adc2)

          {

            float normalized = (float)(UserVar[event->BaseVarIndex] - adc1) / (float)(adc2 - adc1);

            UserVar[event->BaseVarIndex] = normalized * (out2 - out1) + out1;



            log += F(" = ");

            log += String(UserVar[event->BaseVarIndex], 3);

          }

        }



        addLog(LOG_LEVEL_INFO,log);

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P003_Pulse.ino"
#ifdef USES_P003
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P003_Pulse.ino"
#define PLUGIN_003 

#define PLUGIN_ID_003 3

#define PLUGIN_NAME_003 "Generic - Pulse counter"

#define PLUGIN_VALUENAME1_003 "Count"

#define PLUGIN_VALUENAME2_003 "Total"

#define PLUGIN_VALUENAME3_003 "Time"





void Plugin_003_pulse_interrupt1() ICACHE_RAM_ATTR;

void Plugin_003_pulse_interrupt2() ICACHE_RAM_ATTR;

void Plugin_003_pulse_interrupt3() ICACHE_RAM_ATTR;

void Plugin_003_pulse_interrupt4() ICACHE_RAM_ATTR;
# 47 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P003_Pulse.ino"
unsigned long Plugin_003_pulseCounter[TASKS_MAX];

unsigned long Plugin_003_pulseTotalCounter[TASKS_MAX];

unsigned long Plugin_003_pulseTime[TASKS_MAX];

unsigned long Plugin_003_pulseTimePrevious[TASKS_MAX];



boolean Plugin_003(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_003;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_003);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_003));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_003));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_003));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormNumericBox(F("Debounce Time (mSec)"), F("plugin_003")

         , Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        String options[4] = { F("Delta"), F("Delta/Total/Time"), F("Total"), F("Delta/Total") };

        addFormSelector(F("Counter Type"), F("plugin_003_countertype"), 4, options, NULL, choice );



        if (choice !=0)

          addHtml(F("<span style=\"color:red\">Total count is not persistent!</span>"));



        String modeRaise[4];

        modeRaise[0] = F("LOW");

        modeRaise[1] = F("CHANGE");

        modeRaise[2] = F("RISING");

        modeRaise[3] = F("FALLING");

        int modeValues[4];

        modeValues[0] = LOW;

        modeValues[1] = CHANGE;

        modeValues[2] = RISING;

        modeValues[3] = FALLING;



        addFormSelector(F("Mode Type"), F("plugin_003_raisetype"), 4, modeRaise, modeValues, choice2 );



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_003"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_003_countertype"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_003_raisetype"));

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SHOW_VALUES:

      {

        string += F("<div class=\"div_l\">");

        string += ExtraTaskSettings.TaskDeviceValueNames[0];

        string += F(":</div><div class=\"div_r\">");

        string += Plugin_003_pulseCounter[event->TaskIndex];

        string += F("</div><div class=\"div_br\"></div><div class=\"div_l\">");

        string += ExtraTaskSettings.TaskDeviceValueNames[1];

        string += F(":</div><div class=\"div_r\">");

        string += Plugin_003_pulseTotalCounter[event->TaskIndex];

        string += F("</div><div class=\"div_br\"></div><div class=\"div_l\">");

        string += ExtraTaskSettings.TaskDeviceValueNames[2];

        string += F(":</div><div class=\"div_r\">");

        string += Plugin_003_pulseTime[event->TaskIndex];

        string += F("</div>");

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        String log = F("INIT : Pulse ");

        log += Settings.TaskDevicePin1[event->TaskIndex];

        addLog(LOG_LEVEL_INFO,log);

        pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT_PULLUP);

        success = Plugin_003_pulseinit(Settings.TaskDevicePin1[event->TaskIndex], event->TaskIndex,Settings.TaskDevicePluginConfig[event->TaskIndex][2]);

        break;

      }



    case PLUGIN_READ:

      {

        UserVar[event->BaseVarIndex] = Plugin_003_pulseCounter[event->TaskIndex];

        UserVar[event->BaseVarIndex+1] = Plugin_003_pulseTotalCounter[event->TaskIndex];

        UserVar[event->BaseVarIndex+2] = Plugin_003_pulseTime[event->TaskIndex];



        switch (Settings.TaskDevicePluginConfig[event->TaskIndex][1])

        {

          case 0:

          {

            event->sensorType = SENSOR_TYPE_SINGLE;

            UserVar[event->BaseVarIndex] = Plugin_003_pulseCounter[event->TaskIndex];

            break;

          }

          case 1:

          {

            event->sensorType = SENSOR_TYPE_TRIPLE;

            UserVar[event->BaseVarIndex] = Plugin_003_pulseCounter[event->TaskIndex];

            UserVar[event->BaseVarIndex+1] = Plugin_003_pulseTotalCounter[event->TaskIndex];

            UserVar[event->BaseVarIndex+2] = Plugin_003_pulseTime[event->TaskIndex];

            break;

          }

          case 2:

          {

            event->sensorType = SENSOR_TYPE_SINGLE;

            UserVar[event->BaseVarIndex] = Plugin_003_pulseTotalCounter[event->TaskIndex];

            break;

          }

          case 3:

          {

            event->sensorType = SENSOR_TYPE_DUAL;

            UserVar[event->BaseVarIndex] = Plugin_003_pulseCounter[event->TaskIndex];

            UserVar[event->BaseVarIndex+1] = Plugin_003_pulseTotalCounter[event->TaskIndex];

            break;

          }

        }

        Plugin_003_pulseCounter[event->TaskIndex] = 0;

        success = true;

        break;

      }

  }

  return success;

}
# 363 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P003_Pulse.ino"
void Plugin_003_pulsecheck(byte Index)

{

  const unsigned long PulseTime=timePassedSince(Plugin_003_pulseTimePrevious[Index]);

  if(PulseTime > (unsigned long)Settings.TaskDevicePluginConfig[Index][0])

    {

      Plugin_003_pulseCounter[Index]++;

      Plugin_003_pulseTotalCounter[Index]++;

      Plugin_003_pulseTime[Index] = PulseTime;

      Plugin_003_pulseTimePrevious[Index]=millis();

    }

}
# 395 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P003_Pulse.ino"
void Plugin_003_pulse_interrupt1()

{

  Plugin_003_pulsecheck(0);

}

void Plugin_003_pulse_interrupt2()

{

  Plugin_003_pulsecheck(1);

}

void Plugin_003_pulse_interrupt3()

{

  Plugin_003_pulsecheck(2);

}

void Plugin_003_pulse_interrupt4()

{

  Plugin_003_pulsecheck(3);

}

void Plugin_003_pulse_interrupt5()

{

  Plugin_003_pulsecheck(4);

}

void Plugin_003_pulse_interrupt6()

{

  Plugin_003_pulsecheck(5);

}

void Plugin_003_pulse_interrupt7()

{

  Plugin_003_pulsecheck(6);

}

void Plugin_003_pulse_interrupt8()

{

  Plugin_003_pulsecheck(7);

}
# 469 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P003_Pulse.ino"
bool Plugin_003_pulseinit(byte Par1, byte Index, byte Mode)

{



  switch (Index)

  {

    case 0:

      attachInterrupt(Par1, Plugin_003_pulse_interrupt1, Mode);

      break;

    case 1:

      attachInterrupt(Par1, Plugin_003_pulse_interrupt2, Mode);

      break;

    case 2:

      attachInterrupt(Par1, Plugin_003_pulse_interrupt3, Mode);

      break;

    case 3:

      attachInterrupt(Par1, Plugin_003_pulse_interrupt4, Mode);

      break;
# 527 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P003_Pulse.ino"
    default:

      addLog(LOG_LEVEL_ERROR,F("PULSE: Error, only the first 4 tasks can be pulse counters."));

      return(false);

  }



  return(true);

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
#ifdef USES_P004
# 15 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
#if defined(ESP32)

  #define ESP32noInterrupts() {portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;portENTER_CRITICAL(&mux)

  #define ESP32interrupts() portEXIT_CRITICAL(&mux);}

#endif



#define PLUGIN_004 

#define PLUGIN_ID_004 4

#define PLUGIN_NAME_004 "Environment - DS18b20"

#define PLUGIN_VALUENAME1_004 "Temperature"



int8_t Plugin_004_DallasPin;



boolean Plugin_004(byte function, struct EventStruct * event, String& string)

{

    boolean success = false;



    switch (function)

    {

        case PLUGIN_DEVICE_ADD:

        {

            Device[++deviceCount].Number = PLUGIN_ID_004;

            Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

            Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

            Device[deviceCount].Ports = 0;

            Device[deviceCount].PullUpOption = false;

            Device[deviceCount].InverseLogicOption = false;

            Device[deviceCount].FormulaOption = true;

            Device[deviceCount].ValueCount = 1;

            Device[deviceCount].SendDataOption = true;

            Device[deviceCount].TimerOption = true;

            Device[deviceCount].GlobalSyncOption = true;

            break;

        }



        case PLUGIN_GET_DEVICENAME:

        {

            string = F(PLUGIN_NAME_004);

            break;

        }



        case PLUGIN_GET_DEVICEVALUENAMES:

        {

            strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_004));

            break;

        }



        case PLUGIN_WEBFORM_LOAD:

        {

            uint8_t savedAddress[8];

            byte resolutionChoice = 0;



            Plugin_004_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];



            if (Plugin_004_DallasPin != -1){



              for (byte i = 0; i < 8; i++)

                  savedAddress[i] = ExtraTaskSettings.TaskDevicePluginConfigLong[i];





              addRowLabel(F("Device Address"));

              addSelector_Head(F("plugin_004_dev"), false);

              addSelector_Item("", -1, false, false, F(""));

              uint8_t tmpAddress[8];

              byte count = 0;

              Plugin_004_DS_reset();

              Plugin_004_DS_reset_search();

              while (Plugin_004_DS_search(tmpAddress))

              {

                  String option = "";

                  for (byte j = 0; j < 8; j++)

                  {

                      option += String(tmpAddress[j], HEX);

                      if (j < 7) option += F("-");

                  }

                  bool selected = (memcmp(tmpAddress, savedAddress, 8) == 0) ? true : false;

                  addSelector_Item(option, count, selected, false, F(""));

                  count ++;

              }

              addSelector_Foot();





              if (ExtraTaskSettings.TaskDevicePluginConfigLong[0] != 0)

                  resolutionChoice = Plugin_004_DS_getResolution(savedAddress);

              else

                  resolutionChoice = 9;

              String resultsOptions[4] = { "9", "10", "11", "12" };

              int resultsOptionValues[4] = { 9, 10, 11, 12 };

              addFormSelector(F("Device Resolution"), F("plugin_004_res"), 4, resultsOptions, resultsOptionValues, resolutionChoice);

              addHtml(F(" Bit"));

            }

            success = true;

            break;

        }



        case PLUGIN_WEBFORM_SAVE:

        {

            uint8_t addr[8] = {0,0,0,0,0,0,0,0};





            Plugin_004_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];



            if (Plugin_004_DallasPin != -1){

              Plugin_004_DS_scan(getFormItemInt(F("plugin_004_dev")), addr);

              for (byte x = 0; x < 8; x++)

                  ExtraTaskSettings.TaskDevicePluginConfigLong[x] = addr[x];



              Plugin_004_DS_setResolution(addr, getFormItemInt(F("plugin_004_res")));

              Plugin_004_DS_startConvertion(addr);

            }

            success = true;

            break;

        }



        case PLUGIN_WEBFORM_SHOW_CONFIG:

        {

            for (byte x = 0; x < 8; x++)

            {

                if (x != 0)

                    string += "-";



            }

            success = true;

            break;

        }

        case PLUGIN_INIT:

        {

            Plugin_004_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];

            if (Plugin_004_DallasPin != -1){

              uint8_t addr[8];

              Plugin_004_get_addr(addr, event->TaskIndex);

              Plugin_004_DS_startConvertion(addr);

              delay(800);

            }

            success = true;

            break;

        }



        case PLUGIN_READ:

        {

            if (ExtraTaskSettings.TaskDevicePluginConfigLong[0] != 0){

                uint8_t addr[8];

                Plugin_004_get_addr(addr, event->TaskIndex);



                Plugin_004_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];

                float value = 0;

                String log = F("DS   : Temperature: ");



                if (Plugin_004_DS_readTemp(addr, &value))

                {

                    UserVar[event->BaseVarIndex] = value;

                    log += UserVar[event->BaseVarIndex];

                    success = true;

                }

                else

                {

                    UserVar[event->BaseVarIndex] = NAN;

                    log += F("Error!");

                }

                Plugin_004_DS_startConvertion(addr);



                log += (" (");

                for (byte x = 0; x < 8; x++)

                {

                    if (x != 0)

                        log += "-";

                    log += String(ExtraTaskSettings.TaskDevicePluginConfigLong[x], HEX);

                }



                log += ')';

                addLog(LOG_LEVEL_INFO, log);

            }

            break;

        }

    }

    return success;

}



void Plugin_004_get_addr(uint8_t addr[], byte TaskIndex)

{



  LoadTaskSettings(TaskIndex);

  for (byte x = 0; x < 8; x++)

      addr[x] = ExtraTaskSettings.TaskDevicePluginConfigLong[x];

}
# 393 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
byte Plugin_004_DS_scan(byte getDeviceROM, uint8_t* ROM)

{

    byte tmpaddr[8];

    byte devCount = 0;

    Plugin_004_DS_reset();



    Plugin_004_DS_reset_search();

    while (Plugin_004_DS_search(tmpaddr))

    {

        if (getDeviceROM == devCount)

            for (byte i = 0; i < 8; i++)

                ROM[i] = tmpaddr[i];

        devCount++;

    }

    return devCount;

}
# 441 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
void Plugin_004_DS_startConvertion(uint8_t ROM[8])

{

    Plugin_004_DS_reset();

    Plugin_004_DS_write(0x55);

    for (byte i = 0; i < 8; i++)

        Plugin_004_DS_write(ROM[i]);

    Plugin_004_DS_write(0x44);

}
# 465 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
boolean Plugin_004_DS_readTemp(uint8_t ROM[8], float * value)

{

    int16_t DSTemp;

    byte ScratchPad[12];



    Plugin_004_DS_reset();

    Plugin_004_DS_write(0x55);

    for (byte i = 0; i < 8; i++)

        Plugin_004_DS_write(ROM[i]);



    Plugin_004_DS_write(0xBE);



    for (byte i = 0; i < 9; i++)

        ScratchPad[i] = Plugin_004_DS_read();



    if (!Plugin_004_DS_crc8(ScratchPad))

    {

        *value = 0;

        return false;

    }



    if ((ROM[0] == 0x28 ) || (ROM[0] == 0x3b) || (ROM[0] == 0x22))

    {

        DSTemp = (ScratchPad[1] << 8) + ScratchPad[0];

        if (DSTemp == 0x550)

           return false;

        *value = (float(DSTemp) * 0.0625);

    }

    else if (ROM[0] == 0x10)

    {

        if (ScratchPad[0] == 0xaa)

          return false;

        DSTemp = (ScratchPad[1] << 11) | ScratchPad[0] << 3;

        DSTemp = ((DSTemp & 0xfff0) << 3) - 16 +

                 (((ScratchPad[7] - ScratchPad[6]) << 7) / ScratchPad[7]);

        *value = float(DSTemp) * 0.0078125;

    }

    return true;

}
# 551 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
int Plugin_004_DS_getResolution(uint8_t ROM[8])

{



    if (ROM[0] == 0x10) return 12;



    byte ScratchPad[12];



    Plugin_004_DS_reset();

    Plugin_004_DS_write(0x55);

    for (byte i = 0; i < 8; i++)

        Plugin_004_DS_write(ROM[i]);



    Plugin_004_DS_write(0xBE);



    for (byte i = 0; i < 9; i++)

        ScratchPad[i] = Plugin_004_DS_read();



    if (!Plugin_004_DS_crc8(ScratchPad))

        return 0;

    else

    {

        switch (ScratchPad[4])

        {

            case 0x7F:

                return 12;



            case 0x5F:

                return 11;



            case 0x3F:

                return 10;



            case 0x1F:

            default:

                return 9;

        }

    }

    return(0);

}
# 637 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
boolean Plugin_004_DS_setResolution(uint8_t ROM[8], byte res)

{



    if (ROM[0] == 0x10) return true;



    byte ScratchPad[12];



    Plugin_004_DS_reset();

    Plugin_004_DS_write(0x55);

    for (byte i = 0; i < 8; i++)

        Plugin_004_DS_write(ROM[i]);



    Plugin_004_DS_write(0xBE);



    for (byte i = 0; i < 9; i++)

        ScratchPad[i] = Plugin_004_DS_read();



    if (!Plugin_004_DS_crc8(ScratchPad))

        return false;

    else

    {

        switch (res)

        {

            case 12:

                ScratchPad[4] = 0x7F;

                break;

            case 11:

                ScratchPad[4] = 0x5F;

                break;

            case 10:

                ScratchPad[4] = 0x3F;

                break;

            case 9:

            default:

                ScratchPad[4] = 0x1F;

                break;

        }



        Plugin_004_DS_reset();

        Plugin_004_DS_write(0x55);

        for (byte i = 0; i < 8; i++)

            Plugin_004_DS_write(ROM[i]);



        Plugin_004_DS_write(0x4E);

        Plugin_004_DS_write(ScratchPad[2]);

        Plugin_004_DS_write(ScratchPad[3]);

        Plugin_004_DS_write(ScratchPad[4]);



        Plugin_004_DS_write(0x55);

        for (byte i = 0; i < 8; i++)

            Plugin_004_DS_write(ROM[i]);





        Plugin_004_DS_write(0x48);

        delay(100);

        Plugin_004_DS_reset();



        return true;

    }

}
# 765 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
uint8_t Plugin_004_DS_reset()

{

    uint8_t r;

    uint8_t retries = 125;

    #if defined(ESP32)

      ESP32noInterrupts();

    #endif

    pinMode(Plugin_004_DallasPin, INPUT);

    do

    {

        if (--retries == 0)

            return 0;

        delayMicroseconds(2);

    }

    while (!digitalRead(Plugin_004_DallasPin));



    pinMode(Plugin_004_DallasPin, OUTPUT); digitalWrite(Plugin_004_DallasPin, LOW);

    delayMicroseconds(492);

    pinMode(Plugin_004_DallasPin, INPUT);

    delayMicroseconds(40);

    r = !digitalRead(Plugin_004_DallasPin);

    delayMicroseconds(420);

    #if defined(ESP32)

      ESP32interrupts();

    #endif

    return r;

}



#define FALSE 0

#define TRUE 1



unsigned char ROM_NO[8];

uint8_t LastDiscrepancy;

uint8_t LastFamilyDiscrepancy;

uint8_t LastDeviceFlag;
# 845 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
void Plugin_004_DS_reset_search()

{



    LastDiscrepancy = 0;

    LastDeviceFlag = FALSE;

    LastFamilyDiscrepancy = 0;

    for (byte i = 0; i < 8; i++)

        ROM_NO[i] = 0;

}
# 873 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
uint8_t Plugin_004_DS_search(uint8_t * newAddr)

{

    uint8_t id_bit_number;

    uint8_t last_zero, rom_byte_number, search_result;

    uint8_t id_bit, cmp_id_bit;

    unsigned char rom_byte_mask, search_direction;





    id_bit_number = 1;

    last_zero = 0;

    rom_byte_number = 0;

    rom_byte_mask = 1;

    search_result = 0;





    if (!LastDeviceFlag)

    {



        if (!Plugin_004_DS_reset())

        {



            LastDiscrepancy = 0;

            LastDeviceFlag = FALSE;

            LastFamilyDiscrepancy = 0;

            return FALSE;

        }





        Plugin_004_DS_write(0xF0);





        do

        {



            id_bit = Plugin_004_DS_read_bit();

            cmp_id_bit = Plugin_004_DS_read_bit();





            if ((id_bit == 1) && (cmp_id_bit == 1))

                break;

            else

            {



                if (id_bit != cmp_id_bit)

                    search_direction = id_bit;

                else

                {





                    if (id_bit_number < LastDiscrepancy)

                        search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);

                    else



                        search_direction = (id_bit_number == LastDiscrepancy);





                    if (search_direction == 0)

                    {

                        last_zero = id_bit_number;





                        if (last_zero < 9)

                            LastFamilyDiscrepancy = last_zero;

                    }

                }







                if (search_direction == 1)

                    ROM_NO[rom_byte_number] |= rom_byte_mask;

                else

                    ROM_NO[rom_byte_number] &= ~rom_byte_mask;





                Plugin_004_DS_write_bit(search_direction);







                id_bit_number++;

                rom_byte_mask <<= 1;





                if (rom_byte_mask == 0)

                {

                    rom_byte_number++;

                    rom_byte_mask = 1;

                }

            }

        }

        while (rom_byte_number < 8);





        if (!(id_bit_number < 65))

        {



            LastDiscrepancy = last_zero;





            if (LastDiscrepancy == 0)

                LastDeviceFlag = TRUE;



            search_result = TRUE;

        }

    }





    if (!search_result || !ROM_NO[0])

    {

        LastDiscrepancy = 0;

        LastDeviceFlag = FALSE;

        LastFamilyDiscrepancy = 0;

        search_result = FALSE;

    }



    for (int i = 0; i < 8; i++)

        newAddr[i] = ROM_NO[i];



    return search_result;

}
# 1119 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
uint8_t Plugin_004_DS_read(void)

{

    uint8_t bitMask;

    uint8_t r = 0;



    for (bitMask = 0x01; bitMask; bitMask <<= 1)

        if (Plugin_004_DS_read_bit())

            r |= bitMask;



    return r;

}
# 1149 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
void Plugin_004_DS_write(uint8_t ByteToWrite)

{

    uint8_t bitMask;

    for (bitMask = 0x01; bitMask; bitMask <<= 1)

        Plugin_004_DS_write_bit( (bitMask & ByteToWrite) ? 1 : 0);

}
# 1169 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
uint8_t Plugin_004_DS_read_bit(void)

{

    uint8_t r;



    #if defined(ESP32)

       ESP32noInterrupts();

    #endif

    pinMode(Plugin_004_DallasPin, OUTPUT);

    digitalWrite(Plugin_004_DallasPin, LOW);

    delayMicroseconds(3);

    pinMode(Plugin_004_DallasPin, INPUT);

    delayMicroseconds(10);

    r = digitalRead(Plugin_004_DallasPin);

    #if defined(ESP32)

       ESP32interrupts();

    #endif

    delayMicroseconds(53);

    return r;

}
# 1215 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
void Plugin_004_DS_write_bit(uint8_t v)

{

    if (v & 1)

    {

        #if defined(ESP32)

          ESP32noInterrupts();

        #endif

        digitalWrite(Plugin_004_DallasPin, LOW);

        pinMode(Plugin_004_DallasPin, OUTPUT);

        delayMicroseconds(10);

        digitalWrite(Plugin_004_DallasPin, HIGH);

        #if defined(ESP32)

          ESP32interrupts();

        #endif

        delayMicroseconds(55);

    }

    else

    {

        #if defined(ESP32)

          ESP32noInterrupts();

        #endif

        digitalWrite(Plugin_004_DallasPin, LOW);

        pinMode(Plugin_004_DallasPin, OUTPUT);

        delayMicroseconds(65);

        digitalWrite(Plugin_004_DallasPin, HIGH);

        #if defined(ESP32)

           ESP32interrupts();

        #endif

        delayMicroseconds(5);

    }

}
# 1285 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P004_Dallas.ino"
boolean Plugin_004_DS_crc8(uint8_t * addr)

{

  uint8_t crc = 0;

  uint8_t len = 8;



    while (len--)

    {

        uint8_t inbyte = *addr++;

        for (uint8_t i = 8; i; i--)

        {

            uint8_t mix = (crc ^ inbyte) & 0x01;

            crc >>= 1;

            if (mix) crc ^= 0x8C;

            inbyte >>= 1;

        }

    }

    return crc == *addr;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P005_DHT.ino"
#ifdef USES_P005
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P005_DHT.ino"
#define PLUGIN_005 

#define PLUGIN_ID_005 5

#define PLUGIN_NAME_005 "Environment - DHT11/12/22  SONOFF2301/7021"

#define PLUGIN_VALUENAME1_005 "Temperature"

#define PLUGIN_VALUENAME2_005 "Humidity"



uint8_t Plugin_005_DHT_Pin;



boolean Plugin_005(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_005;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_005);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_005));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_005));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        const String options[] = { F("DHT 11"), F("DHT 22"), F("DHT 12"), F("Sonoff am2301"), F("Sonoff si7021") };

        int indices[] = { 11, 22, 12, 23, 70 };



        addFormSelector(F("DHT Type"), F("plugin_005_dhttype"), 5, options, indices, Settings.TaskDevicePluginConfig[event->TaskIndex][0] );



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_005_dhttype"));



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        byte dht_dat[5];

        byte i;

        boolean error = false;



        byte Par3 = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Plugin_005_DHT_Pin = Settings.TaskDevicePin1[event->TaskIndex];



        pinMode(Plugin_005_DHT_Pin, OUTPUT);

        digitalWrite(Plugin_005_DHT_Pin, LOW);

        if(Par3 == 11 || Par3 == 22 || Par3 == 12) delay(18);

        else if (Par3 == 23 ) delayMicroseconds(900);

        else if (Par3 == 70 ) delayMicroseconds(500);

        pinMode(Plugin_005_DHT_Pin, INPUT);

        delayMicroseconds(50);



        error = waitState(0);

        if(error)

        { logError(event, F("DHT  : no Reading !"));

            break;

        }

        error = waitState(1);

        if(error)

        { logError(event, F("DHT  : no Reading !"));

            break;

        }

        noInterrupts();

        error = waitState(0);

        if(error)

        { logError(event, F("DHT  : no Reading !"));

            break;

        }

        for (i = 0; i < 5; i++)

        {

            byte data = Plugin_005_read_dht_dat();

            if(data == -1)

            { logError(event, F("DHT  : protocol timeout!"));

                break;

            }

            dht_dat[i] = data;

        }

        interrupts();





        byte dht_check_sum = (dht_dat[0] + dht_dat[1] + dht_dat[2] + dht_dat[3]) & 0xFF;

        if (dht_dat[4] != dht_check_sum)

        {

            logError(event, F("DHT  : checksum error!"));

            break;

        }



        float temperature = NAN;

        float humidity = NAN;

        if (Par3 == 11)

        {

          temperature = float(dht_dat[2]);

          humidity = float(dht_dat[0]);

        }

        else if (Par3 == 12)

        {

            temperature = float(dht_dat[2]*10 + (dht_dat[3] & 0x7f)) / 10.0;

            if (dht_dat[3] & 0x80) { temperature = -temperature; }

            humidity = float(dht_dat[0]*10+dht_dat[1]) / 10.0;

        }

        else if (Par3 == 22 || Par3 == 23 || Par3 == 70)

        {

          if (dht_dat[2] & 0x80)

            temperature = -0.1 * word(dht_dat[2] & 0x7F, dht_dat[3]);

          else

            temperature = 0.1 * word(dht_dat[2], dht_dat[3]);

          humidity = 0.1 * word(dht_dat[0], dht_dat[1]);

        }



        if (temperature == NAN || humidity == NAN)

        { logError(event, F("DHT  : invalid NAN reading !"));

              break;

        }



        UserVar[event->BaseVarIndex] = temperature;

        UserVar[event->BaseVarIndex + 1] = humidity;

        String log = F("DHT  : Temperature: ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        log = F("DHT  : Humidity: ");

        log += UserVar[event->BaseVarIndex + 1];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }

  }

  return success;

}
# 331 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P005_DHT.ino"
void logError(struct EventStruct *event, String text)

{

  addLog(LOG_LEVEL_INFO, text);

  UserVar[event->BaseVarIndex] = NAN;

  UserVar[event->BaseVarIndex + 1] = NAN;

}
# 351 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P005_DHT.ino"
boolean waitState(int state)

{

  byte counter = 0;

  while (( digitalRead(Plugin_005_DHT_Pin) != state) && (counter < 100))

  {

    delayMicroseconds(1);

    counter++;

  }

  if( counter < 100) return false;

  return true;

}
# 381 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P005_DHT.ino"
int Plugin_005_read_dht_dat(void)

{

  byte i = 0;

  byte result = 0;

  byte counter = 0;

  for (i = 0; i < 8; i++)

  {

    while ((!digitalRead(Plugin_005_DHT_Pin)) && (counter < 100))

    {

      delayMicroseconds(1);

      counter++;

    }

    if (counter >= 100)

    {

      return -1;

    }

    delayMicroseconds(35);

    if (digitalRead(Plugin_005_DHT_Pin))

      result |= (1 << (7 - i));

    counter = 0;

    while ((digitalRead(Plugin_005_DHT_Pin)) && (counter < 100))

    {

      delayMicroseconds(1);

      counter++;

    }

    if (counter >= 100)

    {

      return -1;

    }

  }

  return result;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P006_BMP085.ino"
#ifdef USES_P006
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P006_BMP085.ino"
#define PLUGIN_006 

#define PLUGIN_ID_006 6

#define PLUGIN_NAME_006 "Environment - BMP085/180"

#define PLUGIN_VALUENAME1_006 "Temperature"

#define PLUGIN_VALUENAME2_006 "Pressure"







boolean Plugin_006_init = false;



boolean Plugin_006(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_006;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_BARO;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_006);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_006));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_006));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormNumericBox(F("Altitude [m]"), F("_p006_bmp085_elev"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("_p006_bmp085_elev"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (!Plugin_006_init)

        {

          if (Plugin_006_bmp085_begin())

            Plugin_006_init = true;

        }



        if (Plugin_006_init)

        {

          UserVar[event->BaseVarIndex] = Plugin_006_bmp085_readTemperature();

          int elev = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

          if (elev)

          {

             UserVar[event->BaseVarIndex + 1] = Plugin_006_pressureElevation((float)Plugin_006_bmp085_readPressure() / 100, elev);

          } else {

             UserVar[event->BaseVarIndex + 1] = ((float)Plugin_006_bmp085_readPressure()) / 100;

          }

          String log = F("BMP  : Temperature: ");

          log += UserVar[event->BaseVarIndex];

          addLog(LOG_LEVEL_INFO, log);

          log = F("BMP  : Barometric Pressure: ");

          log += UserVar[event->BaseVarIndex + 1];

          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }

        break;

      }



  }

  return success;

}



#define BMP085_I2CADDR 0x77

#define BMP085_ULTRAHIGHRES 3

#define BMP085_CAL_AC1 0xAA

#define BMP085_CAL_AC2 0xAC

#define BMP085_CAL_AC3 0xAE

#define BMP085_CAL_AC4 0xB0

#define BMP085_CAL_AC5 0xB2

#define BMP085_CAL_AC6 0xB4

#define BMP085_CAL_B1 0xB6

#define BMP085_CAL_B2 0xB8

#define BMP085_CAL_MB 0xBA

#define BMP085_CAL_MC 0xBC

#define BMP085_CAL_MD 0xBE

#define BMP085_CONTROL 0xF4

#define BMP085_TEMPDATA 0xF6

#define BMP085_PRESSUREDATA 0xF6

#define BMP085_READTEMPCMD 0x2E

#define BMP085_READPRESSURECMD 0x34



uint8_t oversampling = BMP085_ULTRAHIGHRES;

int16_t ac1, ac2, ac3, b1, b2, mb, mc, md;

uint16_t ac4, ac5, ac6;





boolean Plugin_006_bmp085_begin()



{

  if (I2C_read8_reg(BMP085_I2CADDR, 0xD0) != 0x55) return false;





  ac1 = I2C_read16_reg(BMP085_I2CADDR, BMP085_CAL_AC1);

  ac2 = I2C_read16_reg(BMP085_I2CADDR, BMP085_CAL_AC2);

  ac3 = I2C_read16_reg(BMP085_I2CADDR, BMP085_CAL_AC3);

  ac4 = I2C_read16_reg(BMP085_I2CADDR, BMP085_CAL_AC4);

  ac5 = I2C_read16_reg(BMP085_I2CADDR, BMP085_CAL_AC5);

  ac6 = I2C_read16_reg(BMP085_I2CADDR, BMP085_CAL_AC6);



  b1 = I2C_read16_reg(BMP085_I2CADDR, BMP085_CAL_B1);

  b2 = I2C_read16_reg(BMP085_I2CADDR, BMP085_CAL_B2);



  mb = I2C_read16_reg(BMP085_I2CADDR, BMP085_CAL_MB);

  mc = I2C_read16_reg(BMP085_I2CADDR, BMP085_CAL_MC);

  md = I2C_read16_reg(BMP085_I2CADDR, BMP085_CAL_MD);



  return(true);

}





uint16_t Plugin_006_bmp085_readRawTemperature(void)



{

  I2C_write8_reg(BMP085_I2CADDR, BMP085_CONTROL, BMP085_READTEMPCMD);

  delay(5);

  return I2C_read16_reg(BMP085_I2CADDR, BMP085_TEMPDATA);

}





uint32_t Plugin_006_bmp085_readRawPressure(void)



{

  uint32_t raw;



  I2C_write8_reg(BMP085_I2CADDR, BMP085_CONTROL, BMP085_READPRESSURECMD + (oversampling << 6));



  delay(26);



  raw = I2C_read16_reg(BMP085_I2CADDR, BMP085_PRESSUREDATA);

  raw <<= 8;

  raw |= I2C_read8_reg(BMP085_I2CADDR, BMP085_PRESSUREDATA + 2);

  raw >>= (8 - oversampling);



  return raw;

}





int32_t Plugin_006_bmp085_readPressure(void)



{

  int32_t UT, UP, B3, B5, B6, X1, X2, X3, p;

  uint32_t B4, B7;



  UT = Plugin_006_bmp085_readRawTemperature();

  UP = Plugin_006_bmp085_readRawPressure();





  X1 = (UT - (int32_t)(ac6)) * ((int32_t)(ac5)) / pow(2, 15);

  X2 = ((int32_t)mc * pow(2, 11)) / (X1 + (int32_t)md);

  B5 = X1 + X2;





  B6 = B5 - 4000;

  X1 = ((int32_t)b2 * ( (B6 * B6) >> 12 )) >> 11;

  X2 = ((int32_t)ac2 * B6) >> 11;

  X3 = X1 + X2;

  B3 = ((((int32_t)ac1 * 4 + X3) << oversampling) + 2) / 4;



  X1 = ((int32_t)ac3 * B6) >> 13;

  X2 = ((int32_t)b1 * ((B6 * B6) >> 12)) >> 16;

  X3 = ((X1 + X2) + 2) >> 2;

  B4 = ((uint32_t)ac4 * (uint32_t)(X3 + 32768)) >> 15;

  B7 = ((uint32_t)UP - B3) * (uint32_t)( 50000UL >> oversampling );



  if (B7 < 0x80000000)

  {

    p = (B7 * 2) / B4;

  }

  else

  {

    p = (B7 / B4) * 2;

  }

  X1 = (p >> 8) * (p >> 8);

  X1 = (X1 * 3038) >> 16;

  X2 = (-7357 * p) >> 16;



  p = p + ((X1 + X2 + (int32_t)3791) >> 4);

  return p;

}





float Plugin_006_bmp085_readTemperature(void)



{

  int32_t UT, X1, X2, B5;

  float temp;



  UT = Plugin_006_bmp085_readRawTemperature();





  X1 = (UT - (int32_t)ac6) * ((int32_t)ac5) / pow(2, 15);

  X2 = ((int32_t)mc * pow(2, 11)) / (X1 + (int32_t)md);

  B5 = X1 + X2;

  temp = (B5 + 8) / pow(2, 4);

  temp /= 10;



  return temp;

}





float Plugin_006_pressureElevation(float atmospheric, int altitude) {



  return atmospheric / pow(1.0 - (altitude/44330.0), 5.255);

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P007_PCF8591.ino"
#ifdef USES_P007
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P007_PCF8591.ino"
#define PLUGIN_007 

#define PLUGIN_ID_007 7

#define PLUGIN_NAME_007 "Analog input - PCF8591"

#define PLUGIN_VALUENAME1_007 "Analog"



boolean Plugin_007(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;







  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_007;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 4;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_007);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_007));

        break;

      }



    case PLUGIN_READ:

      {

        byte unit = (Settings.TaskDevicePort[event->TaskIndex] - 1) / 4;

        byte port = Settings.TaskDevicePort[event->TaskIndex] - (unit * 4);

        uint8_t address = 0x48 + unit;





        Wire.beginTransmission(address);

        Wire.write(port - 1);

        Wire.endTransmission();



        Wire.requestFrom(address, (uint8_t)0x2);

        if (Wire.available())

        {

          Wire.read();

          UserVar[event->BaseVarIndex] = (float)Wire.read();

          String log = F("PCF  : Analog value: ");

          log += UserVar[event->BaseVarIndex];

          addLog(LOG_LEVEL_INFO,log);

          success = true;

        }

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P008_RFID.ino"
#ifdef USES_P008
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P008_RFID.ino"
#define PLUGIN_008 

#define PLUGIN_ID_008 8

#define PLUGIN_NAME_008 "RFID - Wiegand"

#define PLUGIN_VALUENAME1_008 "Tag"



void Plugin_008_interrupt1() ICACHE_RAM_ATTR;

void Plugin_008_interrupt2() ICACHE_RAM_ATTR;



volatile byte Plugin_008_bitCount = 0;

uint64_t Plugin_008_keyBuffer = 0;

byte Plugin_008_timeoutCount = 0;

byte Plugin_008_WiegandSize = 26;



boolean Plugin_008_init = false;



boolean Plugin_008(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_008;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_LONG;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_008);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_008));

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_008_init = true;

        Plugin_008_WiegandSize = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT_PULLUP);

        pinMode(Settings.TaskDevicePin2[event->TaskIndex], INPUT_PULLUP);

        attachInterrupt(Settings.TaskDevicePin1[event->TaskIndex], Plugin_008_interrupt1, FALLING);

        attachInterrupt(Settings.TaskDevicePin2[event->TaskIndex], Plugin_008_interrupt2, FALLING);

        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        if (Plugin_008_init)

        {

          if (Plugin_008_bitCount > 0)

          {

            if (Plugin_008_bitCount % 4 == 0 && ((Plugin_008_keyBuffer & 0xF) == 11))

            {



              Plugin_008_keyBuffer = Plugin_008_keyBuffer >> 4;

              UserVar[event->BaseVarIndex] = (Plugin_008_keyBuffer & 0xFFFF);

              UserVar[event->BaseVarIndex + 1] = ((Plugin_008_keyBuffer >> 16) & 0xFFFF);

            }

            else if (Plugin_008_bitCount == Plugin_008_WiegandSize)

            {



              Plugin_008_keyBuffer = Plugin_008_keyBuffer >> 1;

              if (Plugin_008_WiegandSize == 26)

                Plugin_008_keyBuffer &= 0xFFFFFF;

              else

                Plugin_008_keyBuffer &= 0xFFFFFFFF;

              UserVar[event->BaseVarIndex] = (Plugin_008_keyBuffer & 0xFFFF);

              UserVar[event->BaseVarIndex + 1] = ((Plugin_008_keyBuffer >> 16) & 0xFFFF);

            }

            else

            {



              Plugin_008_timeoutCount++;

              if (Plugin_008_timeoutCount > 5)

              {

                String log = F("RFID : reset bits: ");

                log += Plugin_008_bitCount;

                addLog(LOG_LEVEL_INFO, log );



                Plugin_008_keyBuffer = 0;

                Plugin_008_bitCount = 0;

                Plugin_008_timeoutCount = 0;

              }

              break;

            }



            unsigned long bitCount = Plugin_008_bitCount;

            unsigned long keyBuffer = Plugin_008_keyBuffer;

            Plugin_008_keyBuffer = 0;

            Plugin_008_bitCount = 0;

            Plugin_008_timeoutCount = 0;



            String log = F("RFID : Tag: ");

            log += keyBuffer;

            log += F(" Bits: ");

            log += bitCount;

            addLog(LOG_LEVEL_INFO, log);

            sendData(event);

          }

        }

        break;

      }

      case PLUGIN_WEBFORM_LOAD:

        {

          byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

          String options[2];

          options[0] = F("26 Bits");

          options[1] = F("34 Bits");

          int optionValues[2];

          optionValues[0] = 26;

          optionValues[1] = 34;

          addFormSelector(F("Wiegand Type"), F("plugin_008_type"), 2, options, optionValues, choice);

          success = true;

          break;

        }



      case PLUGIN_WEBFORM_SAVE:

        {

          String plugin1 = WebServer.arg(F("plugin_008_type"));

          Settings.TaskDevicePluginConfig[event->TaskIndex][0] = plugin1.toInt();

          success = true;

          break;

        }

  }

  return success;

}





void Plugin_008_interrupt1()



{



  Plugin_008_keyBuffer = Plugin_008_keyBuffer << 1;

  Plugin_008_keyBuffer += 1;

  Plugin_008_bitCount++;

}





void Plugin_008_interrupt2()



{



  Plugin_008_keyBuffer = Plugin_008_keyBuffer << 1;

  Plugin_008_bitCount++;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P009_MCP.ino"
#ifdef USES_P009
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P009_MCP.ino"
#define PLUGIN_009 

#define PLUGIN_ID_009 9

#define PLUGIN_NAME_009 "Switch input - MCP23017"

#define PLUGIN_VALUENAME1_009 "Switch"



boolean Plugin_009(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte switchstate[TASKS_MAX];



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_009;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].Ports = 16;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_009);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_009));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormCheckBox(F("Send Boot state") ,F("plugin_009_boot"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = isFormItemChecked(F("plugin_009_boot"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {



        Plugin_009_Config(Settings.TaskDevicePort[event->TaskIndex], 1);





        switchstate[event->TaskIndex] = Plugin_009_Read(Settings.TaskDevicePort[event->TaskIndex]);





        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

          switchstate[event->TaskIndex] = !switchstate[event->TaskIndex];



        setPinState(PLUGIN_ID_009, Settings.TaskDevicePort[event->TaskIndex], PIN_MODE_INPUT, 0);

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        int state = Plugin_009_Read(Settings.TaskDevicePort[event->TaskIndex]);

        if (state != -1)

        {

          if (state != switchstate[event->TaskIndex])

          {

            String log = F("MCP  : State ");

            log += state;

            addLog(LOG_LEVEL_INFO, log);

            switchstate[event->TaskIndex] = state;

            UserVar[event->BaseVarIndex] = state;

            event->sensorType = SENSOR_TYPE_SWITCH;

            sendData(event);

          }

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {





        String log = F("MCP   : State ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String log = "";

        String command = parseString(string, 1);



        if (command == F("mcpgpio"))

        {

          success = true;

          Plugin_009_Write(event->Par1, event->Par2);

          setPinState(PLUGIN_ID_009, event->Par1, PIN_MODE_OUTPUT, event->Par2);

          log = String(F("MCP  : GPIO ")) + String(event->Par1) + String(F(" Set to ")) + String(event->Par2);

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_009, event->Par1, log, 0));

        }



        if (command == F("mcppulse"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 128)

          {

            Plugin_009_Write(event->Par1, event->Par2);

            delay(event->Par3);

            Plugin_009_Write(event->Par1, !event->Par2);

            setPinState(PLUGIN_ID_009, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("MCP  : GPIO ")) + String(event->Par1) + String(F(" Pulsed for ")) + String(event->Par3) + String(F(" mS"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_009, event->Par1, log, 0));

          }

        }



        if (command == F("mcplongpulse"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 128)

          {

            Plugin_009_Write(event->Par1, event->Par2);

            setPinState(PLUGIN_ID_009, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            setPluginTaskTimer(event->Par3 * 1000, PLUGIN_ID_009, event->TaskIndex, event->Par1, !event->Par2);

            log = String(F("MCP  : GPIO ")) + String(event->Par1) + String(F(" Pulse set for ")) + String(event->Par3) + String(F(" S"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_009, event->Par1, log, 0));

          }

        }



        if (command == F("status"))

        {

          if (parseString(string, 2) == F("mcp"))

          {

            success = true;

            String status = "";

            if (hasPinState(PLUGIN_ID_009, event->Par2))

              status = getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_009, event->Par2, dummyString, 0);

            else

            {

              int state = Plugin_009_Read(event->Par2);

              if (state != -1)

                status = getPinStateJSON(NO_SEARCH_PIN_STATE, PLUGIN_ID_009, event->Par2, dummyString, state);

            }

            SendStatus(event->Source, status);

          }

        }



        break;

      }



    case PLUGIN_TIMER_IN:

      {

        Plugin_009_Write(event->Par1, event->Par2);

        setPinState(PLUGIN_ID_009, event->Par1, PIN_MODE_OUTPUT, event->Par2);

        break;

      }

  }

  return success;

}
# 381 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P009_MCP.ino"
int Plugin_009_Read(byte Par1)

{

  int8_t state = -1;

  byte unit = (Par1 - 1) / 16;

  byte port = Par1 - (unit * 16);

  uint8_t address = 0x20 + unit;

  byte IOBankValueReg = 0x12;

  if (port > 8)

  {

    port = port - 8;

    IOBankValueReg++;

  }



  Wire.beginTransmission(address);

  Wire.write(IOBankValueReg);

  Wire.endTransmission();

  Wire.requestFrom(address, (uint8_t)0x1);

  if (Wire.available())

  {

    state = ((Wire.read() & _BV(port - 1)) >> (port - 1));

  }

  return state;

}
# 437 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P009_MCP.ino"
boolean Plugin_009_Write(byte Par1, byte Par2)

{

  boolean success = false;

  byte portvalue = 0;

  byte unit = (Par1 - 1) / 16;

  byte port = Par1 - (unit * 16);

  uint8_t address = 0x20 + unit;

  byte IOBankConfigReg = 0;

  byte IOBankValueReg = 0x12;

  if (port > 8)

  {

    port = port - 8;

    IOBankConfigReg++;

    IOBankValueReg++;

  }



  Wire.beginTransmission(address);

  Wire.write(IOBankConfigReg);

  Wire.endTransmission();

  Wire.requestFrom(address, (uint8_t)0x1);

  if (Wire.available())

  {

    portvalue = Wire.read();

    portvalue &= ~(1 << (port - 1));





    Wire.beginTransmission(address);

    Wire.write(IOBankConfigReg);

    Wire.write(portvalue);

    Wire.endTransmission();

  }



  Wire.beginTransmission(address);

  Wire.write(IOBankValueReg);

  Wire.endTransmission();

  Wire.requestFrom(address, (uint8_t)0x1);

  if (Wire.available())

  {

    portvalue = Wire.read();

    if (Par2 == 1)

      portvalue |= (1 << (port - 1));

    else

      portvalue &= ~(1 << (port - 1));





    Wire.beginTransmission(address);

    Wire.write(IOBankValueReg);

    Wire.write(portvalue);

    Wire.endTransmission();

    success = true;

  }

  return(success);

}
# 553 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P009_MCP.ino"
void Plugin_009_Config(byte Par1, byte Par2)

{



  byte portvalue = 0;

  byte unit = (Par1 - 1) / 16;

  byte port = Par1 - (unit * 16);

  uint8_t address = 0x20 + unit;

  byte IOBankConfigReg = 0xC;

  if (port > 8)

  {

    port = port - 8;

    IOBankConfigReg++;

  }



  Wire.beginTransmission(address);

  Wire.write(IOBankConfigReg);

  Wire.endTransmission();

  Wire.requestFrom(address, (uint8_t)0x1);

  if (Wire.available())

  {

    portvalue = Wire.read();

    if (Par2 == 1)

      portvalue |= (1 << (port - 1));

    else

      portvalue &= ~(1 << (port - 1));





    Wire.beginTransmission(address);

    Wire.write(IOBankConfigReg);

    Wire.write(portvalue);

    Wire.endTransmission();

  }

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P010_BH1750.ino"
#ifdef USES_P010







#ifdef ESP8266

#include "AS_BH1750.h"

#endif



#define PLUGIN_010 

#define PLUGIN_ID_010 10

#define PLUGIN_NAME_010 "Light/Lux - BH1750"

#define PLUGIN_VALUENAME1_010 "Lux"





boolean Plugin_010(byte function, struct EventStruct *event, String& string)

  {

  boolean success=false;



  switch(function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_010;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_010);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_010));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];
# 115 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P010_BH1750.ino"
        int optionValues[2];

        optionValues[0] = BH1750_DEFAULT_I2CADDR;

        optionValues[1] = BH1750_SECOND_I2CADDR;

        addFormSelectorI2C(F("plugin_010"), 2, optionValues, choice);

        addFormNote(F("ADDR Low=0x23, High=0x5c"));



        byte choiceMode = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String optionsMode[4];

        optionsMode[0] = F("RESOLUTION_LOW");

        optionsMode[1] = F("RESOLUTION_NORMAL");

        optionsMode[2] = F("RESOLUTION_HIGH");

        optionsMode[3] = F("RESOLUTION_AUTO_HIGH");

        int optionValuesMode[4];

        optionValuesMode[0] = RESOLUTION_LOW;

        optionValuesMode[1] = RESOLUTION_NORMAL;

        optionValuesMode[2] = RESOLUTION_HIGH;

        optionValuesMode[3] = RESOLUTION_AUTO_HIGH;

        addFormSelector(F("Measurement mode"), F("plugin_010_mode"), 4, optionsMode, optionValuesMode, choiceMode);



        addFormCheckBox(F("Send sensor to sleep"), F("plugin_010_sleep"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_010"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_010_mode"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = isFormItemChecked(F("plugin_010_sleep"));

        success = true;

        break;

      }



  case PLUGIN_READ:

    {

     uint8_t address = Settings.TaskDevicePluginConfig[event->TaskIndex][0];





      AS_BH1750 sensor = AS_BH1750(address);

      sensors_resolution_t mode;



      mode = (sensors_resolution_t)Settings.TaskDevicePluginConfig[event->TaskIndex][1];
# 219 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P010_BH1750.ino"
      sensor.begin(mode,Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



      float lux = sensor.readLightLevel();

      if (lux != -1) {

       UserVar[event->BaseVarIndex] = lux;

     String log = F("BH1750 Address: 0x");

     log += String(address,HEX);

     log += F(" Mode: 0x");

     log += String(mode);

     log += F(" : Light intensity: ");

     log += UserVar[event->BaseVarIndex];

     addLog(LOG_LEVEL_INFO,log);

       success=true;

      }

      break;

    }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P011_PME.ino"
#ifdef USES_P011
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P011_PME.ino"
#define PLUGIN_011 

#define PLUGIN_ID_011 11

#define PLUGIN_NAME_011 "Extra IO - ProMini Extender"

#define PLUGIN_VALUENAME1_011 "Value"



#define PLUGIN_011_I2C_ADDRESS 0x7f



boolean Plugin_011(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_011;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].Ports = 14;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_011);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_011));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[2] = { F("Digital"), F("Analog") };

        addFormSelector(F("Port Type"), F("plugin_011"), 2, options, NULL, choice);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_011"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        UserVar[event->BaseVarIndex] = Plugin_011_Read(Settings.TaskDevicePluginConfig[event->TaskIndex][0], Settings.TaskDevicePort[event->TaskIndex]);

        String log = F("PME  : PortValue: ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String log = "";

        String command = parseString(string, 1);



        if (command == F("extgpio"))

        {

          success = true;

          Plugin_011_Write(event->Par1, event->Par2);

          setPinState(PLUGIN_ID_011, event->Par1, PIN_MODE_OUTPUT, event->Par2);

          log = String(F("PME  : GPIO ")) + String(event->Par1) + String(F(" Set to ")) + String(event->Par2);

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par1, log, 0));

        }



        if (command == F("extpwm"))

        {

          success = true;

          uint8_t address = PLUGIN_011_I2C_ADDRESS;

          Wire.beginTransmission(address);

          Wire.write(3);

          Wire.write(event->Par1);

          Wire.write(event->Par2 & 0xff);

          Wire.write((event->Par2 >> 8));

          Wire.endTransmission();

          setPinState(PLUGIN_ID_011, event->Par1, PIN_MODE_PWM, event->Par2);

          log = String(F("PME  : GPIO ")) + String(event->Par1) + String(F(" Set PWM to ")) + String(event->Par2);

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par1, log, 0));

        }



        if (command == F("extpulse"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 13)

          {

            Plugin_011_Write(event->Par1, event->Par2);

            delay(event->Par3);

            Plugin_011_Write(event->Par1, !event->Par2);

            setPinState(PLUGIN_ID_011, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("PME  : GPIO ")) + String(event->Par1) + String(F(" Pulsed for ")) + String(event->Par3) + String(F(" mS"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par1, log, 0));

          }

        }



        if (command == F("extlongpulse"))

        {

          success = true;

          if (event->Par1 >= 0 && event->Par1 <= 13)

          {

            Plugin_011_Write(event->Par1, event->Par2);

            setPluginTaskTimer(event->Par3 * 1000, PLUGIN_ID_011, event->TaskIndex, event->Par1, !event->Par2);

            setPinState(PLUGIN_ID_011, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            log = String(F("PME  : GPIO ")) + String(event->Par1) + String(F(" Pulse set for ")) + String(event->Par3) + String(F(" S"));

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par1, log, 0));

          }

        }



        if (command == F("status"))

        {

          if (parseString(string, 2) == F("ext"))

          {

            success = true;

            String status = "";

            if (hasPinState(PLUGIN_ID_011, event->Par2))

              status = getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par2, dummyString, 0);

            else

            {

              byte port = event->Par2;

              byte type = 0;

              if (port > 13)

              {

                type = 1;

                port -= 20;

              }

              int state = Plugin_011_Read(type, port);

              if (state != -1)

                status = getPinStateJSON(NO_SEARCH_PIN_STATE, PLUGIN_ID_011, event->Par2, dummyString, state);

            }

            SendStatus(event->Source, status);

          }

        }



        break;

      }



    case PLUGIN_TIMER_IN:

      {

        Plugin_011_Write(event->Par1, event->Par2);

        setPinState(PLUGIN_ID_011, event->Par1, PIN_MODE_OUTPUT, event->Par2);

        break;

      }

  }

  return success;

}
# 351 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P011_PME.ino"
int Plugin_011_Read(byte Par1, byte Par2)

{

  int value = -1;

  uint8_t address = PLUGIN_011_I2C_ADDRESS;

  Wire.beginTransmission(address);

  if (Par1 == 0)

    Wire.write(2);

  else

    Wire.write(4);

  Wire.write(Par2);

  Wire.write(0);

  Wire.write(0);

  Wire.endTransmission();

  delay(1);

  Wire.requestFrom(address, (uint8_t)0x4);

  byte buffer[4];

  if (Wire.available() == 4)

  {

    for (byte x = 0; x < 4; x++)

      buffer[x] = Wire.read();

    value = buffer[0] + 256 * buffer[1];

  }

  return value;

}
# 409 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P011_PME.ino"
void Plugin_011_Write(byte Par1, byte Par2)

{

  uint8_t address = 0x7f;

  Wire.beginTransmission(address);

  Wire.write(1);

  Wire.write(Par1);

  Wire.write(Par2 & 0xff);

  Wire.write((Par2 >> 8));

  Wire.endTransmission();

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P012_LCD.ino"
#ifdef USES_P012
# 23 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P012_LCD.ino"
#include <LiquidCrystal_I2C.h>



LiquidCrystal_I2C *lcd=NULL;

int Plugin_012_cols = 16;

int Plugin_012_rows = 2;

int Plugin_012_mode = 1;



#define PLUGIN_012 

#define PLUGIN_ID_012 12

#define PLUGIN_NAME_012 "Display - LCD2004"

#define PLUGIN_VALUENAME1_012 "LCD"



boolean Plugin_012(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte displayTimer = 0;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_012;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_012);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_012));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        int optionValues[16];

        for (byte x = 0; x < 16; x++)

        {

          if (x < 8)

            optionValues[x] = 0x20 + x;

          else

            optionValues[x] = 0x30 + x;





        }

        addFormSelectorI2C(F("plugin_012_adr"), 16, optionValues, choice);





        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options2[2];

        options2[0] = F("2 x 16");

        options2[1] = F("4 x 20");

        int optionValues2[2] = { 1, 2 };

        addFormSelector(F("Display Size"), F("plugin_012_size"), 2, options2, optionValues2, choice2);





        char deviceTemplate[4][80];

        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));

        for (byte varNr = 0; varNr < 4; varNr++)

        {

          addHtml(F("<TR><TD>Line "));

          addHtml(String(varNr + 1));

          addHtml(F(":<TD><input type='text' size='80' maxlength='80' name='Plugin_012_template"));

          addHtml(String(varNr + 1));

          addHtml(F("' value='"));

          addHtml(deviceTemplate[varNr]);

          addHtml(F("'>"));

        }





        addRowLabel(F("Display button"));

        addPinSelect(false, F("taskdevicepin3"), Settings.TaskDevicePin3[event->TaskIndex]);





        char tmpString[128];

        sprintf_P(tmpString, PSTR("<TR><TD>Display Timeout:<TD><input type='text' name='plugin_12_timer' value='%u'>"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);

        addHtml(tmpString);





        String options3[3];

        options3[0] = F("Continue to next line (as in v1.4)");

        options3[1] = F("Truncate exceeding message");

        options3[2] = F("Clear then truncate exceeding message");

        int optionValues3[3] = { 0,1,2 };

        addFormSelector(F("LCD command Mode"), F("plugin_012_mode"), 3, options3, optionValues3, Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_012_adr"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_012_size"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_12_timer"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("plugin_012_mode"));



        char deviceTemplate[4][80];

        for (byte varNr = 0; varNr < 4; varNr++)

        {

          char argc[25];

          String arg = F("Plugin_012_template");

          arg += varNr + 1;

          arg.toCharArray(argc, 25);

          String tmpString = WebServer.arg(argc);

          strncpy(deviceTemplate[varNr], tmpString.c_str(), sizeof(deviceTemplate[varNr]));

        }



        SaveCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 2) {

          Plugin_012_rows = 4;

          Plugin_012_cols = 20;

        } else if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 1) {

          Plugin_012_rows = 2;

          Plugin_012_cols = 16;

        }



        Plugin_012_mode = Settings.TaskDevicePluginConfig[event->TaskIndex][3];







        if (!lcd)

          lcd = new LiquidCrystal_I2C(Settings.TaskDevicePluginConfig[event->TaskIndex][0], 20, 4);





        lcd->init();

        lcd->backlight();

        lcd->print(F("ESP Easy"));

        displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

          pinMode(Settings.TaskDevicePin3[event->TaskIndex], INPUT_PULLUP);

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

        {

          if (!digitalRead(Settings.TaskDevicePin3[event->TaskIndex]))

          {

            if (lcd) {

              lcd->backlight();

            }

            displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

          }

        }

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        if ( displayTimer > 0)

        {

          displayTimer--;

          if (lcd && displayTimer == 0)

            lcd->noBacklight();

        }

        break;

      }



    case PLUGIN_READ:

      {

        char deviceTemplate[4][80];

        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



        for (byte x = 0; x < Plugin_012_rows; x++)

        {

          String tmpString = deviceTemplate[x];

          if (lcd && tmpString.length())

          {

            String newString = P012_parseTemplate(tmpString, Plugin_012_cols);

            lcd->setCursor(0, x);

            lcd->print(newString);

          }

        }

        success = false;

        break;

      }



    case PLUGIN_WRITE:

      {

        String tmpString = string;

        int argIndex = tmpString.indexOf(',');

        if (argIndex)

          tmpString = tmpString.substring(0, argIndex);



        if (lcd && tmpString.equalsIgnoreCase(F("LCDCMD")))

        {

          success = true;

          argIndex = string.lastIndexOf(',');

          tmpString = string.substring(argIndex + 1);

          if (tmpString.equalsIgnoreCase(F("Off"))){

              lcd->noBacklight();

          }

          else if (tmpString.equalsIgnoreCase(F("On"))){

              lcd->backlight();

          }

          else if (tmpString.equalsIgnoreCase(F("Clear"))){

              lcd->clear();

          }

        }

        else if (lcd && tmpString.equalsIgnoreCase(F("LCD")))

        {

          success = true;

          tmpString = P012_parseTemplate(string, Plugin_012_cols);

          argIndex = tmpString.lastIndexOf(',');

          tmpString = tmpString.substring(argIndex + 1);



          int colPos = event->Par2 - 1;

          int rowPos = event->Par1 - 1;





          if (Plugin_012_mode == 2){

              lcd->setCursor(colPos, rowPos);

              for (byte i = colPos; i < Plugin_012_cols; i++) {

                  lcd->print(F(" "));

              }

          }





          lcd->setCursor(colPos, rowPos);

          if(Plugin_012_mode == 1 || Plugin_012_mode == 2){

              lcd->setCursor(colPos, rowPos);

              for (byte i = 0; i < Plugin_012_cols - colPos; i++) {

                  if(tmpString[i]){

                     lcd->print(tmpString[i]);

                  }

              }

          }





          else{



              boolean stillProcessing = 1;

              byte charCount = 1;

              while(stillProcessing) {

                   if (++colPos > Plugin_012_cols) {

                        rowPos += 1;

                        lcd->setCursor(0,rowPos);

                        colPos = 1;

                   }





                   if(rowPos < Plugin_012_rows ){

                       lcd->print(tmpString[charCount - 1]);

                   }



                   if (!tmpString[charCount]) {

                        stillProcessing = 0;

                   }

                   charCount += 1;

              }





          }



        }

        break;

      }



  }

  return success;

}







String P012_parseTemplate(String &tmpString, byte lineSize) {

  String result = parseTemplate(tmpString, lineSize);

  const char degree[3] = {0xc2, 0xb0, 0};

  const char degree_lcd[2] = {0xdf, 0};

  result.replace(degree, degree_lcd);

  return result;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P013_HCSR04.ino"
#ifdef USES_P013
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P013_HCSR04.ino"
#define PLUGIN_013 

#define PLUGIN_ID_013 13

#define PLUGIN_NAME_013 "Distance - HC-SR04, RCW-0001, etc."

#define PLUGIN_VALUENAME1_013 "Distance"



#include <Arduino.h>

#include <map>

#include <NewPingESP8266.h>



struct P_013_sensordef {

  P_013_sensordef() : sonar(NULL) {}



  P_013_sensordef(byte TRIG_Pin, byte IRQ_Pin, int16_t max_cm_distance) : sonar(NULL) {

    sonar = new NewPingESP8266(TRIG_Pin, IRQ_Pin, max_cm_distance);

  }



  ~P_013_sensordef() {

    if (sonar != NULL) {

      delete sonar;

      sonar = NULL;

    }

  }



  NewPingESP8266 *sonar;

};



std::map<unsigned int, P_013_sensordef> P_013_sensordefs;
# 73 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P013_HCSR04.ino"
boolean Plugin_013(byte function, struct EventStruct *event, String& string)

{

  static byte switchstate[TASKS_MAX];

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_013;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_013);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_013));

        break;

      }





    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[2];

        options[0] = F("Value");

        options[1] = F("State");

        int optionValues[2] = { 1, 2 };

        addFormSelector(F("Mode"), F("plugin_013_mode"), 2, options, optionValues, choice);



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 2)

        {

         addFormNumericBox(F("Threshold"), F("plugin_013_threshold"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        }

        addFormNumericBox(F("Max Distance"), F("plugin_013_max_distance"), Settings.TaskDevicePluginConfig[event->TaskIndex][2], 0, 500);

        addUnit(F("cm"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_013_mode"));

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 2)

        {

          Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_013_threshold"));

        }

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_013_max_distance"));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        byte Plugin_013_TRIG_Pin = Settings.TaskDevicePin1[event->TaskIndex];

        byte Plugin_013_IRQ_Pin = Settings.TaskDevicePin2[event->TaskIndex];

        int16_t max_cm_distance = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        P_013_sensordefs[event->TaskIndex] =

          P_013_sensordef(Plugin_013_TRIG_Pin, Plugin_013_IRQ_Pin, max_cm_distance);

        String log = F("ULTRASONIC : TaskNr: ");

        log += event->TaskIndex +1;

        log += F(" TrigPin: ");

        log += Plugin_013_TRIG_Pin;

        log += F(" IRQ_Pin: ");

        log += Plugin_013_IRQ_Pin;

        log += F(" max dist cm: ");

        log += max_cm_distance;

        log += F(" max echo: ");

        log += P_013_sensordefs[event->TaskIndex].sonar->getMaxEchoTime();

        log += F(" nr_tasks: ");

        log += P_013_sensordefs.size();

        addLog(LOG_LEVEL_INFO, log);



        unsigned long tmpmillis = millis();

        unsigned long tmpmicros = micros();

        delay(100);

        long millispassed = timePassedSince(tmpmillis);

        long microspassed = usecPassedSince(tmpmicros);



        log = F("ULTRASONIC : micros() test: ");

        log += millispassed;

        log += F(" msec, ");

        log += microspassed;

        log += F(" usec, ");

        addLog(LOG_LEVEL_INFO, log);





        success = true;

        break;

      }



    case PLUGIN_EXIT:

      {

        P_013_sensordefs.erase(event->TaskIndex);

        break;

      }



    case PLUGIN_READ:

      {

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 1)

        {

          float value = Plugin_013_read(event->TaskIndex);

          String log = F("ULTRASONIC : TaskNr: ");

          log += event->TaskIndex +1;

          log += F(" Distance: ");

          if (value > 0)

          {

            UserVar[event->BaseVarIndex] = value;

            log += UserVar[event->BaseVarIndex];

            success = true;

          }

          else

            log += F("No reading!");



        addLog(LOG_LEVEL_INFO,log);

        }

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 2)

        {

          byte state = 0;

          float value = Plugin_013_read(event->TaskIndex);

          if (value > 0)

          {

            if (value < Settings.TaskDevicePluginConfig[event->TaskIndex][1])

              state = 1;

            if (state != switchstate[event->TaskIndex])

            {

              String log = F("ULTRASONIC : State ");

              log += state;

              addLog(LOG_LEVEL_INFO,log);

              switchstate[event->TaskIndex] = state;

              UserVar[event->BaseVarIndex] = state;

              event->sensorType = SENSOR_TYPE_SWITCH;

              sendData(event);

            }

          }

        }

        success = true;

        break;

      }

  }

  return success;

}





float Plugin_013_read(unsigned int taskIndex)



{

  if (P_013_sensordefs.count(taskIndex) == 0) return 0;

  if (P_013_sensordefs[taskIndex].sonar == NULL) return 0;

  delay(1);

  float distance = P_013_sensordefs[taskIndex].sonar->ping_cm();

  delay(1);

  return distance;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
#ifdef USES_P014
# 13 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
#define PLUGIN_014 

#define PLUGIN_ID_014 14

#define PLUGIN_NAME_014 "Environment - SI7021/HTU21D"

#define PLUGIN_VALUENAME1_014 "Temperature"

#define PLUGIN_VALUENAME2_014 "Humidity"



boolean Plugin_014_init = false;
# 35 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
#define SI7021_I2C_ADDRESS 0x40

#define SI7021_MEASURE_TEMP_HUM 0xE0

#define SI7021_MEASURE_TEMP_HM 0xE3

#define SI7021_MEASURE_HUM_HM 0xE5

#define SI7021_MEASURE_TEMP 0xF3

#define SI7021_MEASURE_HUM 0xF5

#define SI7021_WRITE_REG 0xE6

#define SI7021_READ_REG 0xE7

#define SI7021_SOFT_RESET 0xFE







#define SI7021_RESOLUTION_14T_12RH 0x00

#define SI7021_RESOLUTION_13T_10RH 0x80

#define SI7021_RESOLUTION_12T_08RH 0x01

#define SI7021_RESOLUTION_11T_11RH 0x81

#define SI7021_RESOLUTION_MASK 0B01111110



uint16_t si7021_humidity;

int16_t si7021_temperature;



boolean Plugin_014(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_014;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_014);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_014));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_014));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        #define SI7021_RESOLUTION_OPTION 4



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[SI7021_RESOLUTION_OPTION];

        int optionValues[SI7021_RESOLUTION_OPTION];

        optionValues[0] = SI7021_RESOLUTION_14T_12RH;

        options[0] = F("Temp 14 bits / RH 12 bits");

        optionValues[1] = SI7021_RESOLUTION_13T_10RH;

        options[1] = F("Temp 13 bits / RH 10 bits");

        optionValues[2] = SI7021_RESOLUTION_12T_08RH;

        options[2] = F("Temp 12 bits / RH  8 bits");

        optionValues[3] = SI7021_RESOLUTION_11T_11RH;

        options[3] = F("Temp 11 bits / RH 11 bits");

        addFormSelector(F("Resolution"), F("plugin_014_res"), SI7021_RESOLUTION_OPTION, options, optionValues, choice);





        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_014_res"));

        Plugin_014_init = false;

        success = true;

        break;

      }



    case PLUGIN_READ:

      {



        uint8_t res = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        if (!Plugin_014_init) {

          Plugin_014_init = Plugin_014_si7021_begin(res);

        }





        if (Plugin_014_init && Plugin_014_si7021_readValues(res) == 0) {

          UserVar[event->BaseVarIndex] = si7021_temperature/100.0;

          UserVar[event->BaseVarIndex + 1] = si7021_humidity / 10.0;

          success = true;
# 251 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
        } else {

          addLog(LOG_LEVEL_INFO,F("SI7021 : Read Error!"));

        }



        break;

      }



  }

  return success;

}
# 287 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
boolean Plugin_014_si7021_begin(uint8_t resolution)

{

  uint8_t ret;





  ret = Plugin_014_si7021_setResolution(resolution);

  if ( ret == 0 ) {

    ret = true;

  } else {

    String log = F("SI7021 : Res=0x");

    log += String(resolution,HEX);

    log += F(" => Error 0x");

    log += String(ret,HEX);

    addLog(LOG_LEVEL_INFO,log);

    ret = false;

  }



  return ret;

}
# 341 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
uint8_t Plugin_014_si7021_checkCRC(uint16_t data, uint8_t check)

{

  uint32_t remainder, divisor;





  remainder = (uint32_t)data << 8;
# 361 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
  divisor = (uint32_t) 0x988000;





  remainder |= check;







  for (uint8_t i = 0 ; i < 16 ; i++) {



    if( remainder & (uint32_t)1<<(23 - i) )

      remainder ^= divisor;





    divisor >>= 1;

  }

  return ((uint8_t) remainder);

}
# 411 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
int8_t Plugin_014_si7021_readRegister(uint8_t * value)

{





  Wire.beginTransmission(SI7021_I2C_ADDRESS);

  Wire.write(SI7021_READ_REG);

  Wire.endTransmission();





  Wire.requestFrom(SI7021_I2C_ADDRESS, 1);

  if (Wire.available()>=1) {

      *value = Wire.read();

      return 0;

  }



  return 1;

}
# 463 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
int8_t Plugin_014_si7021_startConv(uint8_t datatype, uint8_t resolution)

{

  long data;

  uint16_t raw ;

  uint8_t checksum,tmp;





  Wire.beginTransmission(SI7021_I2C_ADDRESS);

  Wire.write(datatype);

  Wire.endTransmission();
# 515 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
  if (resolution == SI7021_RESOLUTION_11T_11RH)

    tmp = 7;

  else if (resolution == SI7021_RESOLUTION_12T_08RH)

    tmp = 13;

  else if (resolution == SI7021_RESOLUTION_13T_10RH)

    tmp = 25;

  else

    tmp = 50;







  if (datatype == SI7021_MEASURE_HUM)

    tmp *=2;



  delay(tmp);
# 577 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
  if ( Wire.requestFrom(SI7021_I2C_ADDRESS, 3) < 3 ) {

    return -1;

  }





  raw = ((uint16_t) Wire.read()) << 8;

  raw |= Wire.read();

  checksum = Wire.read();





  if(Plugin_014_si7021_checkCRC(raw, checksum) != 0) {

    addLog(LOG_LEVEL_INFO,F("SI7021 : checksum error!"));

    return -1;

  }





  if (datatype == SI7021_MEASURE_HUM || datatype == SI7021_MEASURE_HUM_HM) {





    data = ((1250 * (long)raw) >> 16) - 60;





    if (data>1000) data = 1000;

    if (data<0) data = 0;





    if (resolution == SI7021_RESOLUTION_12T_08RH) {

      data = (data + 5) / 10;

      data *= 10;

    }



    si7021_humidity = (uint16_t) data;





  } else if (datatype == SI7021_MEASURE_TEMP ||datatype == SI7021_MEASURE_TEMP_HM || datatype == SI7021_MEASURE_TEMP_HUM) {





    data = ((17572 * (long)raw) >> 16) - 4685;
# 681 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
    si7021_temperature = (int16_t) data;

  }



  return 0;

}
# 709 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
int8_t Plugin_014_si7021_readValues(uint8_t resolution)

{

  int8_t error = 0;





  error |= Plugin_014_si7021_startConv(SI7021_MEASURE_HUM, resolution);





  error |= Plugin_014_si7021_startConv(SI7021_MEASURE_TEMP, resolution);



  return error;

}
# 749 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P014_SI7021.ino"
int8_t Plugin_014_si7021_setResolution(uint8_t res)

{

  uint8_t reg;

  uint8_t error;





  error = Plugin_014_si7021_readRegister(&reg);

  if ( error == 0) {



    reg &= SI7021_RESOLUTION_MASK ;





    Wire.beginTransmission(SI7021_I2C_ADDRESS);

    Wire.write(SI7021_WRITE_REG);





    Wire.write(reg | ( res &= ~SI7021_RESOLUTION_MASK) );

    return (int8_t) Wire.endTransmission();

  }



  return error;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
#ifdef USES_P015
# 21 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
#define PLUGIN_015 

#define PLUGIN_ID_015 15

#define PLUGIN_NAME_015 "Light/Lux - TSL2561"

#define PLUGIN_VALUENAME1_015 "Lux"

#define PLUGIN_VALUENAME2_015 "Infrared"

#define PLUGIN_VALUENAME3_015 "Broadband"



boolean Plugin_015_init = false;





#define TSL2561_ADDR_0 0x29

#define TSL2561_ADDR 0x39

#define TSL2561_ADDR_1 0x49



#define TSL2561_CMD 0x80

#define TSL2561_REG_CONTROL 0x00

#define TSL2561_REG_TIMING 0x01

#define TSL2561_REG_DATA_0 0x0C

#define TSL2561_REG_DATA_1 0x0E





byte plugin_015_i2caddr;

byte _error;



boolean plugin_015_begin()

{



 return(true);

}



boolean plugin_015_readByte(unsigned char address, unsigned char &value)
# 91 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
{



 Wire.beginTransmission(plugin_015_i2caddr);

 Wire.write((address & 0x0F) | TSL2561_CMD);

 _error = Wire.endTransmission();





 if (_error == 0)

 {

  Wire.requestFrom(plugin_015_i2caddr,(byte)1);

  if (Wire.available() == 1)

  {

   value = Wire.read();

   return(true);

  }

 }

 return(false);

}



boolean plugin_015_writeByte(unsigned char address, unsigned char value)
# 141 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
{



 Wire.beginTransmission(plugin_015_i2caddr);

 Wire.write((address & 0x0F) | TSL2561_CMD);



 Wire.write(value);

 _error = Wire.endTransmission();

 if (_error == 0)

  return(true);



 return(false);

}





boolean plugin_015_readUInt(unsigned char address, unsigned int &value)
# 181 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
{







 Wire.beginTransmission(plugin_015_i2caddr);

 Wire.write((address & 0x0F) | TSL2561_CMD);

 _error = Wire.endTransmission();





 if (_error == 0)

 {

  Wire.requestFrom(plugin_015_i2caddr,(byte)2);

  if (Wire.available() == 2)

  {

   char high, low;

   low = Wire.read();

   high = Wire.read();



   value = word(high,low);

   return(true);

  }

 }

 return(false);

}





boolean plugin_015_writeUInt(unsigned char address, unsigned int value)
# 245 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
{



 if (plugin_015_writeByte(address,lowByte(value))

  && plugin_015_writeByte(address + 1,highByte(value)))

  return(true);



 return(false);

}







boolean plugin_015_setTiming(boolean gain, unsigned char time)
# 285 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
{

 unsigned char timing;





 if (plugin_015_readByte(TSL2561_REG_TIMING,timing))

 {



  if (gain)

   timing |= 0x10;

  else

   timing &= ~0x10;





  timing &= ~0x03;

  timing |= (time & 0x03);





  if (plugin_015_writeByte(TSL2561_REG_TIMING,timing))

   return(true);

 }

 return(false);

}





boolean plugin_015_setTiming(boolean gain, unsigned char time, unsigned int &ms)
# 353 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
{



 switch (time)

 {

  case 0: ms = 14; break;

  case 1: ms = 101; break;

  case 2: ms = 402; break;

  default: ms = 0;

 }



 return(plugin_015_setTiming(gain,time));

}





boolean plugin_015_setPowerUp(void)







{



 return(plugin_015_writeByte(TSL2561_REG_CONTROL,0x03));

}





boolean plugin_015_setPowerDown(void)







{



 return(plugin_015_writeByte(TSL2561_REG_CONTROL,0x00));

}



boolean plugin_015_getData(unsigned int &data0, unsigned int &data1)
# 429 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
{



 if (plugin_015_readUInt(TSL2561_REG_DATA_0,data0) && plugin_015_readUInt(TSL2561_REG_DATA_1,data1))

  return(true);



 return(false);

}





boolean plugin_015_getLux(unsigned char gain, unsigned int ms, unsigned int CH0, unsigned int CH1, double &lux, double &infrared, double &broadband)
# 463 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
{
# 473 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
 if ((CH0 == 0xFFFF) || (CH1 == 0xFFFF))

 {

  lux = 65535.0;

  return(false);

 }

 else

 {

  double ratio, d0, d1;



  d0 = CH0; d1 = CH1;





  ratio = d1 / d0;





    infrared = d1;

    broadband = d0;





  d0 *= (402.0/ms);

  d1 *= (402.0/ms);





  if (!gain)

  {

   d0 *= 16;

   d1 *= 16;

  }







  if (ratio < 0.5)

  {

   lux = 0.0304 * d0 - 0.062 * d0 * pow(ratio,1.4);

   return(true);

  }



  if (ratio < 0.61)

  {

   lux = 0.0224 * d0 - 0.031 * d1;

   return(true);

  }



  if (ratio < 0.80)

  {

   lux = 0.0128 * d0 - 0.0153 * d1;

   return(true);

  }



  if (ratio < 1.30)

  {

   lux = 0.00146 * d0 - 0.00112 * d1;

   return(true);

  }





  lux = 0.0;

  return(true);

 }

}





boolean Plugin_015(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_015;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_015);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_015));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_015));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_015));



        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice1 = Settings.TaskDevicePluginConfig[event->TaskIndex][0];
# 689 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
        int optionValues1[3];

        optionValues1[0] = TSL2561_ADDR;

        optionValues1[1] = TSL2561_ADDR_1;

        optionValues1[2] = TSL2561_ADDR_0;

    addFormSelectorI2C(F("plugin_015_tsl2561_i2c"), 3, optionValues1, choice1);



        #define TSL2561_INTEGRATION_OPTION 3



        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options2[TSL2561_INTEGRATION_OPTION];

        int optionValues2[TSL2561_INTEGRATION_OPTION];

        optionValues2[0] = 0x00;

        options2[0] = F("13 ms");

        optionValues2[1] = 0x01;

        options2[1] = F("101 ms");

        optionValues2[2] = 0x02;

        options2[2] = F("402 ms");

    addFormSelector(F("Integration time"), F("plugin_015_integration"), TSL2561_INTEGRATION_OPTION, options2, optionValues2, choice2);



        addFormCheckBox(F("Send sensor to sleep:"), F("plugin_015_sleep"),

          Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



        addFormCheckBox(F("Enable 16x Gain:"), F("plugin_015_gain"),

          Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_015_tsl2561_i2c"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_015_integration"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = isFormItemChecked(F("plugin_015_sleep"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = isFormItemChecked(F("plugin_015_gain"));



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

       plugin_015_i2caddr = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        boolean gain;

        unsigned int ms;



        plugin_015_begin();







         gain = Settings.TaskDevicePluginConfig[event->TaskIndex][3];
# 807 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P015_TSL2561.ino"
         unsigned char time = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

         plugin_015_setTiming(gain,time,ms);

         plugin_015_setPowerUp();

         delayBackground(ms);

         unsigned int data0, data1;



         if (plugin_015_getData(data0,data1))

         {



           double lux;

           double infrared;

           double broadband;

           boolean good;







           good = plugin_015_getLux(gain,ms,data0,data1,lux, infrared, broadband);

          UserVar[event->BaseVarIndex] = lux;

           UserVar[event->BaseVarIndex + 1] = infrared;

           UserVar[event->BaseVarIndex + 2] = broadband;



           if (!good)

           {

             addLog(LOG_LEVEL_INFO,F("TSL2561: Sensor saturated! > 65535 Lux"));

           }



           success = true;

           String log = F("TSL2561: Address: 0x");

           log += String(plugin_015_i2caddr,HEX);

           log += F(": Mode: ");

           log += String(time,HEX);

           log += F(": Gain: ");

           log += String(gain,HEX);

           log += F(": Lux: ");

           log += UserVar[event->BaseVarIndex];

           log += F(": Infrared: ");

           log += UserVar[event->BaseVarIndex + 1];

           log += F(": Broadband: ");

           log += UserVar[event->BaseVarIndex + 2];

           addLog(LOG_LEVEL_INFO,log);

         }

         else

         {



          addLog(LOG_LEVEL_ERROR, F("TSL2561: i2c error"));



         }

         if (Settings.TaskDevicePluginConfig[event->TaskIndex][2]) {

          addLog(LOG_LEVEL_DEBUG_MORE, F("TSL2561: sleeping..."));

          plugin_015_setPowerDown();

         }



        break;

      }



  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P016_IR.ino"
#ifdef USES_P016
# 13 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P016_IR.ino"
#ifdef ESP8266

#include <IRremoteESP8266.h>

#endif



#include <IRrecv.h>

#include <IRutils.h>



#if DECODE_DAIKIN

#include <ir_Daikin.h>

#endif

#if DECODE_FUJITSU_AC

#include <ir_Fujitsu.h>

#endif

#if DECODE_GREE

#include <ir_Gree.h>

#endif

#if DECODE_HAIER_AC

#include <ir_Haier.h>

#endif

#if DECODE_KELVINATOR

#include <ir_Kelvinator.h>

#endif

#if DECODE_MIDEA

#include <ir_Midea.h>

#endif

#if DECODE_TOSHIBA_AC

#include <ir_Toshiba.h>

#endif



IRrecv *irReceiver;

decode_results results;



#define PLUGIN_016 

#define PLUGIN_ID_016 16

#define PLUGIN_NAME_016 "Communication - TSOP4838"

#define PLUGIN_VALUENAME1_016 "IR"
# 93 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P016_IR.ino"
#define CAPTURE_BUFFER_SIZE 1024
# 127 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P016_IR.ino"
#if DECODE_AC

#define P016_TIMEOUT 50U





#else

#define P016_TIMEOUT 15U

#endif
# 191 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P016_IR.ino"
#define MIN_UNKNOWN_SIZE 12





boolean Plugin_016(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_016;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_LONG;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = true;

        Device[deviceCount].InverseLogicOption = true;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_016);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_016));

        break;

      }



    case PLUGIN_INIT:

      {

        int irPin = Settings.TaskDevicePin1[event->TaskIndex];

        if (irReceiver == 0 && irPin != -1)

        {

          Serial.println(F("IR Init"));

          irReceiver = new IRrecv(irPin, CAPTURE_BUFFER_SIZE, P016_TIMEOUT, true);

          irReceiver->setUnknownThreshold(MIN_UNKNOWN_SIZE);

          irReceiver->enableIRIn();

        }

        if (irReceiver != 0 && irPin == -1)

        {

          Serial.println(F("IR Removed"));

          irReceiver->disableIRIn();

          delete irReceiver;

          irReceiver = 0;

        }

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (irReceiver->decode(&results))

        {

          unsigned long IRcode = results.value;

          irReceiver->resume();

          UserVar[event->BaseVarIndex] = (IRcode & 0xFFFF);

          UserVar[event->BaseVarIndex + 1] = ((IRcode >> 16) & 0xFFFF);

          String log = "IR: ";

          if (results.overflow)

            log += F("WARNING: IR code is too big for buffer. This result shouldn't be trusted until this is resolved. Edit & increase CAPTURE_BUFFER_SIZE.\n");



          log += resultToHumanReadableBasic(&results);

          addLog(LOG_LEVEL_INFO, log);





          log = "";

#if DECODE_DAIKIN

          if (results.decode_type == DAIKIN) {

            IRDaikinESP ac(0);

            ac.setRaw(results.state);

            log = ac.toString();

          }

#endif

#if DECODE_FUJITSU_AC

          if (results.decode_type == FUJITSU_AC) {

            IRFujitsuAC ac(0);

            ac.setRaw(results.state, results.bits / 8);

            log = ac.toString();

          }

#endif

#if DECODE_KELVINATOR

          if (results.decode_type == KELVINATOR) {

            IRKelvinatorAC ac(0);

            ac.setRaw(results.state);

            log = ac.toString();

          }

#endif

#if DECODE_TOSHIBA_AC

          if (results.decode_type == TOSHIBA_AC) {

            IRToshibaAC ac(0);

            ac.setRaw(results.state);

            log = ac.toString();

          }

#endif

#if DECODE_GREE

          if (results.decode_type == GREE) {

            IRGreeAC ac(0);

            ac.setRaw(results.state);

            log = ac.toString();

          }

#endif

#if DECODE_MIDEA

          if (results.decode_type == MIDEA) {

            IRMideaAC ac(0);

            ac.setRaw(results.value);

            log = ac.toString();

          }

#endif

#if DECODE_HAIER_AC

          if (results.decode_type == HAIER_AC) {

            IRHaierAC ac(0);

            ac.setRaw(results.state);

            log = ac.toString();

          }

#endif



          if (log != "") addLog(LOG_LEVEL_INFO, log);
# 453 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P016_IR.ino"
          sendData(event);

        }

        success = true;

        break;

      }

  }

  return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P017_PN532.ino"
#ifdef USES_P017
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P017_PN532.ino"
#define PLUGIN_017 

#define PLUGIN_ID_017 17

#define PLUGIN_NAME_017 "RFID - PN532"

#define PLUGIN_VALUENAME1_017 "Tag"



#define PN532_I2C_ADDRESS 0x24



#define PN532_PREAMBLE (0x00)

#define PN532_STARTCODE1 (0x00)

#define PN532_STARTCODE2 (0xFF)

#define PN532_POSTAMBLE (0x00)

#define PN532_HOSTTOPN532 (0xD4)

#define PN532_PN532TOHOST (0xD5)

#define PN532_ACK_WAIT_TIME (3)

#define PN532_INVALID_ACK (-1)

#define PN532_TIMEOUT (-2)

#define PN532_INVALID_FRAME (-3)

#define PN532_NO_SPACE (-4)



#define PN532_COMMAND_GETFIRMWAREVERSION (0x02)

#define PN532_COMMAND_SAMCONFIGURATION (0x14)

#define PN532_COMMAND_INLISTPASSIVETARGET (0x4A)

#define PN532_RESPONSE_INLISTPASSIVETARGET (0x4B)

#define PN532_MIFARE_ISO14443A (0x00)

#define PN532_COMMAND_POWERDOWN (0x16)



uint8_t Plugin_017_pn532_packetbuffer[64];

uint8_t Plugin_017_command;



boolean Plugin_017(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_017;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_LONG;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_017);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_017));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormPinSelect(F("Reset Pin"), F("taskdevicepin3"), Settings.TaskDevicePin3[event->TaskIndex]);

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {
# 165 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P017_PN532.ino"
        for(byte x=0; x < 3; x++)

        {

          if(Plugin_017_Init(Settings.TaskDevicePin3[event->TaskIndex]))

            break;

          delay(1000);

        }

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        static unsigned long tempcounter = 0;

        static byte counter;

        static byte errorCount=0;



        counter++;

        if (counter == 3 )

        {

          if (digitalRead(4) == 0 || digitalRead(5) == 0)

          {

            addLog(LOG_LEVEL_ERROR, F("PN532: BUS error"));

            Plugin_017_Init(Settings.TaskDevicePin3[event->TaskIndex]);



          }

          counter = 0;

          uint8_t uid[] = { 0, 0, 0, 0, 0, 0, 0 };

          uint8_t uidLength;

          byte error = Plugin_017_readPassiveTargetID(PN532_MIFARE_ISO14443A, uid, &uidLength);



          if (error == 1)

          {

            errorCount++;

            String log = F("PN532: Read error: ");

            log += errorCount;

            addLog(LOG_LEVEL_ERROR, log);

          }

          else

            errorCount=0;



          if (errorCount > 2)

          {

            Plugin_017_Init(Settings.TaskDevicePin3[event->TaskIndex]);

          }





          if (error == 0) {

            unsigned long key = uid[0];

            for (uint8_t i = 1; i < 4; i++) {

              key <<= 8;

              key += uid[i];

            }

            UserVar[event->BaseVarIndex] = (key & 0xFFFF);

            UserVar[event->BaseVarIndex + 1] = ((key >> 16) & 0xFFFF);

            String log = F("PN532: Tag: ");

            log += key;

            tempcounter++;

            log += " ";

            log += tempcounter;

            addLog(LOG_LEVEL_INFO, log);

            sendData(event);

          }

        }

        break;

      }

  }

  return success;

}
# 309 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P017_PN532.ino"
boolean Plugin_017_Init(int8_t resetPin)

{

  if (resetPin != -1)

  {

    String log = F("PN532: Reset on pin: ");

    log += resetPin;

    addLog(LOG_LEVEL_INFO, log);

    pinMode(resetPin, OUTPUT);

    digitalWrite(resetPin, LOW);

    delay(100);

    digitalWrite(resetPin, HIGH);

    pinMode(resetPin, INPUT_PULLUP);

    delay(10);

  }



  Wire.beginTransmission(PN532_I2C_ADDRESS);

  Wire.endTransmission();

  delay(5);



  uint32_t versiondata = getFirmwareVersion();

  if (versiondata) {

    String log = F("PN532: Found chip PN5");

    log += String((versiondata >> 24) & 0xFF, HEX);

    log += F(" FW: ");

    log += String((versiondata >> 16) & 0xFF, HEX);

    log += F(".");

    log += String((versiondata >> 8) & 0xFF, HEX);

    addLog(LOG_LEVEL_INFO, log);

  }

  else

    return false;



  Plugin_017_pn532_packetbuffer[0] = PN532_COMMAND_SAMCONFIGURATION;

  Plugin_017_pn532_packetbuffer[1] = 0x01;

  Plugin_017_pn532_packetbuffer[2] = 0x2;

  Plugin_017_pn532_packetbuffer[3] = 0x01;



  if (Plugin_017_writeCommand(Plugin_017_pn532_packetbuffer, 4))

    return false;





  Wire.beginTransmission(PN532_I2C_ADDRESS);

  Wire.endTransmission();

  delay(5);



  return true;

}
# 413 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P017_PN532.ino"
uint32_t getFirmwareVersion(void)

{

  uint32_t response;



  Plugin_017_pn532_packetbuffer[0] = PN532_COMMAND_GETFIRMWAREVERSION;



  if (Plugin_017_writeCommand(Plugin_017_pn532_packetbuffer, 1)) {

    return 0;

  }



  delay(50);





  int16_t status = Plugin_017_readResponse(Plugin_017_pn532_packetbuffer, sizeof(Plugin_017_pn532_packetbuffer));

  if (0 > status) {

    return 0;

  }



  response = Plugin_017_pn532_packetbuffer[0];

  response <<= 8;

  response |= Plugin_017_pn532_packetbuffer[1];

  response <<= 8;

  response |= Plugin_017_pn532_packetbuffer[2];

  response <<= 8;

  response |= Plugin_017_pn532_packetbuffer[3];



  return response;

}





void Plugin_017_powerDown(void)

{



  Plugin_017_pn532_packetbuffer[0] = PN532_COMMAND_POWERDOWN;

  Plugin_017_pn532_packetbuffer[1] = 1 << 7;



  if (Plugin_017_writeCommand(Plugin_017_pn532_packetbuffer, 2)) {

    return;

  }
# 499 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P017_PN532.ino"
  Plugin_017_readResponse(Plugin_017_pn532_packetbuffer, sizeof(Plugin_017_pn532_packetbuffer));

}
# 513 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P017_PN532.ino"
byte Plugin_017_readPassiveTargetID(uint8_t cardbaudrate, uint8_t *uid, uint8_t *uidLength)

{

  Plugin_017_pn532_packetbuffer[0] = PN532_COMMAND_INLISTPASSIVETARGET;

  Plugin_017_pn532_packetbuffer[1] = 1;

  Plugin_017_pn532_packetbuffer[2] = cardbaudrate;



  if (Plugin_017_writeCommand(Plugin_017_pn532_packetbuffer, 3)) {

    return 0x1;

  }



  delay(50);





  if (Plugin_017_readResponse(Plugin_017_pn532_packetbuffer, sizeof(Plugin_017_pn532_packetbuffer)) < 0) {
# 551 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P017_PN532.ino"
    Wire.beginTransmission(PN532_I2C_ADDRESS);

    Wire.endTransmission();

    return 0x2;

  }



  if (Plugin_017_pn532_packetbuffer[0] != 1)

    return 0x3;



  uint16_t sens_res = Plugin_017_pn532_packetbuffer[2];

  sens_res <<= 8;

  sens_res |= Plugin_017_pn532_packetbuffer[3];





  *uidLength = Plugin_017_pn532_packetbuffer[5];



  for (uint8_t i = 0; i < Plugin_017_pn532_packetbuffer[5]; i++) {

    uid[i] = Plugin_017_pn532_packetbuffer[6 + i];

  }





  Plugin_017_powerDown();





  return 0;

}
# 611 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P017_PN532.ino"
int8_t Plugin_017_writeCommand(const uint8_t *header, uint8_t hlen)

{

  Plugin_017_command = header[0];

  Wire.beginTransmission(PN532_I2C_ADDRESS);



  Wire.write(PN532_PREAMBLE);

  Wire.write(PN532_STARTCODE1);

  Wire.write(PN532_STARTCODE2);



  uint8_t length = hlen + 1;

  Wire.write(length);

  Wire.write(~length + 1);



  Wire.write(PN532_HOSTTOPN532);

  uint8_t sum = PN532_HOSTTOPN532;



  for (uint8_t i = 0; i < hlen; i++) {

    if (Wire.write(header[i])) {

      sum += header[i];



    } else {

      return PN532_INVALID_FRAME;

    }

  }



  uint8_t checksum = ~sum + 1;

  Wire.write(checksum);

  Wire.write(PN532_POSTAMBLE);

  byte status = Wire.endTransmission();



  if (status != 0)

    return PN532_INVALID_FRAME;



  return Plugin_017_readAckFrame();

}
# 691 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P017_PN532.ino"
int16_t Plugin_017_readResponse(uint8_t buf[], uint8_t len)

{

  if (!Wire.requestFrom(PN532_I2C_ADDRESS, len + 2))

    return -1;





  if (!(Wire.read() & 1))

    return -1;



  if (0x00 != Wire.read() ||

      0x00 != Wire.read() ||

      0xFF != Wire.read()

     ) {



    return PN532_INVALID_FRAME;

  }



  uint8_t length = Wire.read();

  if (0 != (uint8_t)(length + Wire.read())) {

    return PN532_INVALID_FRAME;

  }



  uint8_t cmd = Plugin_017_command + 1;

  if (PN532_PN532TOHOST != Wire.read() || (cmd) != Wire.read()) {

    return PN532_INVALID_FRAME;

  }



  length -= 2;

  if (length > len) {

    return PN532_NO_SPACE;

  }



  uint8_t sum = PN532_PN532TOHOST + cmd;

  for (uint8_t i = 0; i < length; i++) {

    buf[i] = Wire.read();

    sum += buf[i];



  }



  uint8_t checksum = Wire.read();

  if (0 != (uint8_t)(sum + checksum)) {

    return PN532_INVALID_FRAME;

  }

  Wire.read();



  return length;

}
# 795 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P017_PN532.ino"
int8_t Plugin_017_readAckFrame()

{

  const uint8_t PN532_ACK[] = {0, 0, 0xFF, 0, 0xFF, 0};

  uint8_t ackBuf[sizeof(PN532_ACK)];



  uint16_t time = 0;

  do {

    if (Wire.requestFrom(PN532_I2C_ADDRESS, sizeof(PN532_ACK) + 1)) {

      if (Wire.read() & 1) {

        break;

      }

    }



    delay(5);

    time++;

    if (time > PN532_ACK_WAIT_TIME) {

      return PN532_TIMEOUT;

    }

  } while (1);





  for (uint8_t i = 0; i < sizeof(PN532_ACK); i++) {

    ackBuf[i] = Wire.read();

  }



  if (memcmp(ackBuf, PN532_ACK, sizeof(PN532_ACK))) {

    return PN532_INVALID_ACK;

  }



  return 0;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P018_Dust.ino"
#ifdef USES_P018
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P018_Dust.ino"
#define PLUGIN_018 

#define PLUGIN_ID_018 18

#define PLUGIN_NAME_018 "Dust - Sharp GP2Y10"

#define PLUGIN_VALUENAME1_018 "Dust"



boolean Plugin_018_init = false;

byte Plugin_GP2Y10_LED_Pin = 0;



boolean Plugin_018(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_018;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_018);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_018));

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_018_init = true;

        pinMode(Settings.TaskDevicePin1[event->TaskIndex], OUTPUT);

        Plugin_GP2Y10_LED_Pin = Settings.TaskDevicePin1[event->TaskIndex];

        digitalWrite(Plugin_GP2Y10_LED_Pin, HIGH);

        success = true;

        break;

      }





    case PLUGIN_READ:

      {

        Plugin_GP2Y10_LED_Pin = Settings.TaskDevicePin1[event->TaskIndex];

        noInterrupts();

        byte x;

        int value;

        value = 0;

        for (x = 0; x < 25; x++)

        {

          digitalWrite(Plugin_GP2Y10_LED_Pin, LOW);

          delayMicroseconds(280);

          value = value + analogRead(A0);

          delayMicroseconds(40);

          digitalWrite(Plugin_GP2Y10_LED_Pin, HIGH);

          delayMicroseconds(9680);

        }

        interrupts();

        UserVar[event->BaseVarIndex] = (float)value;

        String log = F("GPY  : Dust value: ");

        log += value;

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P019_PCF8574.ino"
#ifdef USES_P019
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P019_PCF8574.ino"
#define PLUGIN_019 

#define PLUGIN_ID_019 19

#define PLUGIN_NAME_019 "Switch input - PCF8574"

#define PLUGIN_VALUENAME1_019 "Switch"



boolean Plugin_019(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte switchstate[TASKS_MAX];



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_019;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].Ports = 8;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_019);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_019));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormCheckBox(F("Send Boot state"), F("plugin_019_boot"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = isFormItemChecked(F("plugin_019_boot"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {



        switchstate[event->TaskIndex] = Plugin_019_Read(Settings.TaskDevicePort[event->TaskIndex]);





        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

          switchstate[event->TaskIndex] = !switchstate[event->TaskIndex];



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        int state = Plugin_019_Read(Settings.TaskDevicePort[event->TaskIndex]);

        if (state != -1)

        {

          if (state != switchstate[event->TaskIndex])

          {

            String log = F("PCF  : State ");

            log += state;

            addLog(LOG_LEVEL_INFO, log);

            switchstate[event->TaskIndex] = state;

            UserVar[event->BaseVarIndex] = state;

            event->sensorType = SENSOR_TYPE_SWITCH;

            sendData(event);

          }

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {





        String log = F("PCF  : State ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String log = "";

        String command = parseString(string, 1);



        if (command == F("pcfgpio"))

        {

          success = true;

          if (event->Par2 == 2) {



           setPinState(PLUGIN_ID_019, event->Par1, PIN_MODE_INPUT, 1);

           Plugin_019_Write(event->Par1,1);

           log = String(F("PCF  : GPIO ")) + String(event->Par1) + String(F(" Set to 1"));

          }

          else {

           setPinState(PLUGIN_ID_019, event->Par1, PIN_MODE_OUTPUT, event->Par2);

           Plugin_019_Write(event->Par1, event->Par2);

           log = String(F("PCF  : GPIO ")) + String(event->Par1) + String(F(" Set to ")) + String(event->Par2);

          }

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_019, event->Par1, log, 0));

        }



        if (command == F("pcfpulse"))

        {

          success = true;

          setPinState(PLUGIN_ID_019, event->Par1, PIN_MODE_OUTPUT, event->Par2);

          Plugin_019_Write(event->Par1, event->Par2);

          delay(event->Par3);

          Plugin_019_Write(event->Par1, !event->Par2);

          setPinState(PLUGIN_ID_019, event->Par1, PIN_MODE_OUTPUT, !event->Par2);

          log = String(F("PCF  : GPIO ")) + String(event->Par1) + String(F(" Pulsed for ")) + String(event->Par3) + String(F(" mS"));

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_019, event->Par1, log, 0));

        }



        if (command == F("pcflongpulse"))

        {

          success = true;

          setPinState(PLUGIN_ID_019, event->Par1, PIN_MODE_OUTPUT, event->Par2);

          Plugin_019_Write(event->Par1, event->Par2);

          setPluginTaskTimer(event->Par3 * 1000, PLUGIN_ID_019, event->TaskIndex, event->Par1, !event->Par2);

          log = String(F("PCF  : GPIO ")) + String(event->Par1) + String(F(" Pulse set for ")) + String(event->Par3) + String(F(" S"));

          addLog(LOG_LEVEL_INFO, log);

          SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_019, event->Par1, log, 0));

        }



        if (command == F("status"))

        {

          if (parseString(string, 2) == F("pcf"))

          {

            success = true;

            String status = "";

            if (hasPinState(PLUGIN_ID_019, event->Par2))

              status = getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_019, event->Par2, dummyString, 0);

            else

            {

              int state = Plugin_019_Read(event->Par2);

              if (state != -1)

                status = getPinStateJSON(NO_SEARCH_PIN_STATE, PLUGIN_ID_019, event->Par2, dummyString, state);

            }

            SendStatus(event->Source, status);

          }

        }



        break;

      }



    case PLUGIN_TIMER_IN:

      {

        Plugin_019_Write(event->Par1, event->Par2);

        setPinState(PLUGIN_ID_019, event->Par1, PIN_MODE_OUTPUT, event->Par2);

        break;

      }

  }

  return success;

}
# 379 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P019_PCF8574.ino"
int Plugin_019_Read(byte Par1)

{

  int8_t state = -1;

  byte unit = (Par1 - 1) / 8;

  byte port = Par1 - (unit * 8);

  uint8_t address = 0x20 + unit;

  if (unit > 7) address += 0x10;





  Wire.requestFrom(address, (uint8_t)0x1);

  if (Wire.available())

  {

    state = ((Wire.read() & _BV(port - 1)) >> (port - 1));

  }

  return state;

}
# 421 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P019_PCF8574.ino"
boolean Plugin_019_Write(byte Par1, byte Par2)

{

  byte unit = (Par1 - 1) / 8;

  byte port = Par1 - (unit * 8);

  uint8_t address = 0x20 + unit;

  if (unit > 7) address += 0x10;





  int i = 0;

  byte portmask = 0;

  byte mode = 0;

  uint16_t value = 0;

  unit *= 8;

  unit += 1;

  for(i =0;i<8;i++){

   mode =0;

   if(!getPinState(PLUGIN_ID_019, unit, &mode, &value) || mode == PIN_MODE_INPUT || (mode == PIN_MODE_OUTPUT && value == 1))

    portmask |= (1 << i);

   unit++;

  }



  if (Par2 == 1)

    portmask |= (1 << (port - 1));

  else

    portmask &= ~(1 << (port - 1));



  Wire.beginTransmission(address);

  Wire.write(portmask);

  Wire.endTransmission();



  return true;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P020_Ser2Net.ino"
#ifdef USES_P020
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P020_Ser2Net.ino"
#define PLUGIN_020 

#define PLUGIN_ID_020 20

#define PLUGIN_NAME_020 "Communication - Serial Server"

#define PLUGIN_VALUENAME1_020 "Ser2Net"



#define P020_BUFFER_SIZE 128

boolean Plugin_020_init = false;

byte Plugin_020_SerialProcessing = 0;



WiFiServer *ser2netServer;

WiFiClient ser2netClient;



boolean Plugin_020(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte connectionState = 0;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_020;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].Custom = true;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_020);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_020));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormNumericBox(F("TCP Port"), F("plugin_020_port"), ExtraTaskSettings.TaskDevicePluginConfigLong[0]);

       addFormNumericBox(F("Baud Rate"), F("plugin_020_baud"), ExtraTaskSettings.TaskDevicePluginConfigLong[1]);

       addFormNumericBox(F("Data bits"), F("plugin_020_data"), ExtraTaskSettings.TaskDevicePluginConfigLong[2]);



        byte choice = ExtraTaskSettings.TaskDevicePluginConfigLong[3];

        String options[3];

        options[0] = F("No parity");

        options[1] = F("Even");

        options[2] = F("Odd");

        int optionValues[3];

        optionValues[0] = 0;

        optionValues[1] = 2;

        optionValues[2] = 3;

        addFormSelector(F("Parity"), F("plugin_020_parity"), 3, options, optionValues, choice);



       addFormNumericBox(F("Stop bits"), F("plugin_020_stop"), ExtraTaskSettings.TaskDevicePluginConfigLong[4]);



       addFormPinSelect(F("Reset target after boot"), F("taskdevicepin1"), Settings.TaskDevicePin1[event->TaskIndex]);



       addFormNumericBox(F("RX Receive Timeout (mSec)"), F("plugin_020_rxwait"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);





        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options2[3];

        options2[0] = F("None");

        options2[1] = F("Generic");

        options2[2] = F("RFLink");

        addFormSelector(F("Event processing"), F("plugin_020_events"), 3, options2, NULL, choice2);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        ExtraTaskSettings.TaskDevicePluginConfigLong[0] = getFormItemInt(F("plugin_020_port"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[1] = getFormItemInt(F("plugin_020_baud"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[2] = getFormItemInt(F("plugin_020_data"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[3] = getFormItemInt(F("plugin_020_parity"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[4] = getFormItemInt(F("plugin_020_stop"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_020_rxwait"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_020_events"));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        LoadTaskSettings(event->TaskIndex);

        if ((ExtraTaskSettings.TaskDevicePluginConfigLong[0] != 0) && (ExtraTaskSettings.TaskDevicePluginConfigLong[1] != 0))

        {

          #if defined(ESP8266)

            byte serialconfig = 0x10;

          #endif

          #if defined(ESP32)

            uint32_t serialconfig = 0x8000010;

          #endif

          serialconfig += ExtraTaskSettings.TaskDevicePluginConfigLong[3];

          serialconfig += (ExtraTaskSettings.TaskDevicePluginConfigLong[2] - 5) << 2;

          if (ExtraTaskSettings.TaskDevicePluginConfigLong[4] == 2)

            serialconfig += 0x20;

          #if defined(ESP8266)

            Serial.begin(ExtraTaskSettings.TaskDevicePluginConfigLong[1], (SerialConfig)serialconfig);

          #endif

          #if defined(ESP32)

            Serial.begin(ExtraTaskSettings.TaskDevicePluginConfigLong[1], serialconfig);

          #endif

          ser2netServer = new WiFiServer(ExtraTaskSettings.TaskDevicePluginConfigLong[0]);

          ser2netServer->begin();



          if (Settings.TaskDevicePin1[event->TaskIndex] != -1)

          {

            pinMode(Settings.TaskDevicePin1[event->TaskIndex], OUTPUT);

            digitalWrite(Settings.TaskDevicePin1[event->TaskIndex], LOW);

            delay(500);

            digitalWrite(Settings.TaskDevicePin1[event->TaskIndex], HIGH);

            pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT_PULLUP);

          }



          Plugin_020_init = true;

        }

        Plugin_020_SerialProcessing = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_020_init)

        {

          size_t bytes_read;

          if (ser2netServer->hasClient())

          {

            if (ser2netClient) ser2netClient.stop();

            ser2netClient = ser2netServer->available();

            addLog(LOG_LEVEL_ERROR, F("Ser2N: Client connected!"));

          }



          if (ser2netClient.connected())

          {

            connectionState = 1;

            uint8_t net_buf[P020_BUFFER_SIZE];

            int count = ser2netClient.available();

            if (count > 0)

            {

              if (count > P020_BUFFER_SIZE)

                count = P020_BUFFER_SIZE;

              bytes_read = ser2netClient.read(net_buf, count);

              Serial.write(net_buf, bytes_read);

              Serial.flush();



              if (count == P020_BUFFER_SIZE)

              {

                count--;

                addLog(LOG_LEVEL_ERROR, F("Ser2N: network buffer full!"));

              }

              net_buf[count] = 0;

              char log[P020_BUFFER_SIZE + 40];

              sprintf_P(log, PSTR("Ser2N: N>: %s"), (char*)net_buf);

              addLog(LOG_LEVEL_DEBUG, log);

            }

          }

          else

          {

            if (connectionState == 1)

            {

              connectionState = 0;



              ser2netClient = WiFiClient();

              addLog(LOG_LEVEL_ERROR, F("Ser2N: Client disconnected!"));

            }



            while (Serial.available())

              Serial.read();

          }



          success = true;

        }

        break;

      }



    case PLUGIN_SERIAL_IN:

      {

        uint8_t serial_buf[P020_BUFFER_SIZE];

        int RXWait = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        if (RXWait == 0)

          RXWait = 1;

        int timeOut = RXWait;

        size_t bytes_read = 0;

        while (timeOut > 0)

        {

          while (Serial.available()) {

            if (bytes_read < P020_BUFFER_SIZE) {

              serial_buf[bytes_read] = Serial.read();

              bytes_read++;

            }

            else

              Serial.read();



            timeOut = RXWait;

          }

          delay(1);

          timeOut--;

        }



        if (bytes_read != P020_BUFFER_SIZE)

        {

          if (bytes_read > 0) {

            if (Plugin_020_init && ser2netClient.connected())

            {

              ser2netClient.write((const uint8_t*)serial_buf, bytes_read);

              ser2netClient.flush();

            }

          }

        }

        else

        {

          while (Serial.available())

            Serial.read();

          bytes_read--;



          addLog(LOG_LEVEL_ERROR, F("Ser2N: serial buffer full!"));

        }

        serial_buf[bytes_read] = 0;

        char log[P020_BUFFER_SIZE + 40];

        sprintf_P(log, PSTR("Ser2N: S>: %s"), (char*)serial_buf);

        addLog(LOG_LEVEL_DEBUG, log);





        if (Settings.UseRules)

        {

          String message = (char*)serial_buf;

          int NewLinePos = message.indexOf(F("\r\n"));

          if (NewLinePos > 0)

            message = message.substring(0, NewLinePos);

          String eventString = "";



          switch (Plugin_020_SerialProcessing)

          {

            case 0:

              {

                break;

              }



            case 1:

              {

                eventString = F("!Serial#");

                eventString += message;

                break;

              }



            case 2:

              {

                message = message.substring(6);

                if (message.startsWith("ESPEASY"))

                {

                  message = message.substring(8);

                  eventString = F("RFLink#");

                }

                else

                  eventString = F("!RFLink#");

                eventString += message;

                break;

              }

          }



          if (eventString.length() > 0)

            rulesProcessing(eventString);



        }

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String command = parseString(string, 1);

        if (command == F("serialsend"))

        {

          success = true;

          String tmpString = string.substring(11);

          Serial.println(tmpString);

        }

        break;

      }



  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P021_Level.ino"
#ifdef USES_P021
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P021_Level.ino"
#define PLUGIN_021 

#define PLUGIN_ID_021 21

#define PLUGIN_NAME_021 "Regulator - Level Control"

#define PLUGIN_VALUENAME1_021 "Output"



boolean Plugin_021(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte switchstate[TASKS_MAX];



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_021;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_021);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_021));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {





        addHtml(F("<TR><TD>Check Task:<TD>"));

        addTaskSelect(F("plugin_021_task"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        LoadTaskSettings(Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        addHtml(F("<TR><TD>Check Value:<TD>"));

        addTaskValueSelect(F("plugin_021_value"), Settings.TaskDevicePluginConfig[event->TaskIndex][1], Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



       addFormTextBox(F("Set Level"), F("plugin_021_setvalue"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0]), 8);



       addFormTextBox(F("Hysteresis"), F("plugin_021_hyst"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1]), 8);



        LoadTaskSettings(event->TaskIndex);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_021_task"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_021_value"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = getFormItemFloat(F("plugin_021_setvalue"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] = getFormItemFloat(F("plugin_021_hyst"));

        success = true;

        break;

      }



    case PLUGIN_SET_CONFIG:

      {

        String command = parseString(string, 1);

        if (command == F("setlevel"))

        {

          String value = parseString(string, 2);

          float result=0;

          Calculate(value.c_str(), &result);

          Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = result;

          SaveSettings();

          success = true;

        }

        break;

      }



    case PLUGIN_GET_CONFIG:

      {

        String command = parseString(string, 1);

        if (command == F("getlevel"))

        {

          string = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0];

          success = true;

        }

        break;

      }



    case PLUGIN_INIT:

      {

        pinMode(Settings.TaskDevicePin1[event->TaskIndex], OUTPUT);

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {



        byte TaskIndex = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        byte BaseVarIndex = TaskIndex * VARS_PER_TASK + Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        float value = UserVar[BaseVarIndex];

        byte state = switchstate[event->TaskIndex];



        float valueLowThreshold = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] - (Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] / 2);

        float valueHighThreshold = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] + (Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] / 2);

        if (value <= valueLowThreshold)

          state = 1;

        if (value >= valueHighThreshold)

          state = 0;

        if (state != switchstate[event->TaskIndex])

        {

          String log = F("LEVEL: State ");

          log += state;

          addLog(LOG_LEVEL_INFO, log);

          switchstate[event->TaskIndex] = state;

          digitalWrite(Settings.TaskDevicePin1[event->TaskIndex],state);

          UserVar[event->BaseVarIndex] = state;

          sendData(event);

        }



        success = true;

        break;

      }



  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P022_PCA9685.ino"
#ifdef USES_P022
# 15 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P022_PCA9685.ino"
#define PLUGIN_022 

#define PLUGIN_ID_022 22

#define PLUGIN_NAME_022 "Extra IO - PCA9685"

#define PLUGIN_VALUENAME1_022 "PWM"



#define PLUGIN_022_PCA9685_MODE1 0x00

#define PCA9685_MODE2 0x01

#define PCA9685_LED0 0x06

#define PCA9685_ADDRESS 0x40

#define PCA9685_MAX_ADDRESS 0x7F

#define PCA9685_NUMS_ADDRESS PCA9685_MAX_ADDRESS - PCA9685_ADDRESS

#define PCA9685_MAX_PINS 15

#define PCA9685_MAX_PWM 4095

#define PCA9685_MIN_FREQUENCY 23.0

#define PCA9685_MAX_FREQUENCY 1500.0

#define PCA9685_ALLLED_REG (byte)0xFA
# 57 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P022_PCA9685.ino"
#define IS_INIT(state,bit) ((state & 1 << bit) == 1 << bit)

#define SET_INIT(state,bit) (state|= 1 << bit)

long long initializeState;



boolean Plugin_022(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  int address = 0;

  if(event != NULL && event->TaskIndex >- 1)

  {

    address = Settings.TaskDevicePort[event->TaskIndex];

  }



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_022;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 1;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].Custom = true;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_022);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_022));

        break;

      }



   case PLUGIN_WEBFORM_LOAD:

      {

        int optionValues[PCA9685_NUMS_ADDRESS];

        for (int i=0;i < PCA9685_NUMS_ADDRESS; i++)

        {

          optionValues[i] = PCA9685_ADDRESS + i;

        }

        addFormSelectorI2C(F("i2c_addr"), PCA9685_NUMS_ADDRESS, optionValues, address);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePort[event->TaskIndex] = getFormItemInt(F("i2c_addr"));

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String log = "";

        String line = String(string);

        String command = "";

        int dotPos = line.indexOf('.');

        bool istanceCommand = false;

        if(dotPos > -1)

        {

          LoadTaskSettings(event->TaskIndex);

          String name = line.substring(0,dotPos);

          name.replace(F("["),F(""));

          name.replace(F("]"),F(""));

          if(name.equalsIgnoreCase(getTaskDeviceName(event->TaskIndex)) == true)

          {

            line = line.substring(dotPos + 1);

            istanceCommand = true;

          }

          else

          {

             break;

          }

        }

        command = parseString(line, 1);



        if (command == F("pcapwm") || (istanceCommand && command == F("pwm")))

        {

          success = true;

          log = String(F("PCA 0x")) + String(address, HEX) + String(F(": GPIO ")) + String(event->Par1);

          if(event->Par1 >= 0 && event->Par1 <= PCA9685_MAX_PINS)

          {

            if(event->Par2 >=0 && event->Par2 <= PCA9685_MAX_PWM)

            {

              if (!IS_INIT(initializeState, (address - PCA9685_ADDRESS))) Plugin_022_initialize(address);



              Plugin_022_Write(address, event->Par1, event->Par2);

              setPinState(PLUGIN_ID_022, event->Par1, PIN_MODE_PWM, event->Par2);

              addLog(LOG_LEVEL_INFO, log);

              SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_022, event->Par1, log, 0));

            }

            else{

              addLog(LOG_LEVEL_ERROR, log + String(F(" the pwm value ")) + String(event->Par2) + String(F(" is invalid value.")));

            }

          }

          else{

            addLog(LOG_LEVEL_ERROR, log + String(F(" is invalid value.")));

          }

        }

        if (command == F("pcafrq") || (istanceCommand && command == F("frq")))

        {

          success = true;

          if(event->Par1 >= PCA9685_MIN_FREQUENCY && event->Par1 <= PCA9685_MAX_FREQUENCY)

          {

            if (!IS_INIT(initializeState, (address - PCA9685_ADDRESS))) Plugin_022_initialize(address);



            Plugin_022_Frequency(address, event->Par1);

            setPinState(PLUGIN_ID_022, 99, PIN_MODE_UNDEFINED, event->Par1);

            log = String(F("PCA 0x")) + String(address) + String(F(": FREQ ")) + String(event->Par1);

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_022, 99, log, 0));

          }

          else{

            addLog(LOG_LEVEL_ERROR,String(F("PCA ")) + String(address, HEX) + String(F(" The frequesncy ")) + String(event->Par1) + String(F(" is out of range.")));

          }



        }



        if (command == F("status"))

        {

          if (parseString(line, 2) == F("pca"))

          {

            if (!IS_INIT(initializeState, (address - PCA9685_ADDRESS))) Plugin_022_initialize(address);

            success = true;

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_022, event->Par2, dummyString, 0));

          }

        }



        if(istanceCommand && command == F("gpio"))

        {

          success = true;

          log = String(F("PCA 0x")) + String(address, HEX) + String(F(": GPIO "));

          if(event->Par1>=0 && event->Par1 <= PCA9685_MAX_PINS)

          {

            if (!IS_INIT(initializeState, (address - PCA9685_ADDRESS))) Plugin_022_initialize(address);

            int pin = event->Par1;

            if(parseString(line,2) == "all")

            {

              pin = -1;

              log += String(F("all"));

            }

            else

            {

               log += String(pin);

            }

            if(event->Par2 == 0)

            {

              log += F(" off");

              Plugin_022_Off(address, pin);

            }

            else

            {

              log += F(" on");

              Plugin_022_On(address, pin);

            }

            addLog(LOG_LEVEL_INFO, log);

            setPinState(PLUGIN_ID_022, pin, PIN_MODE_OUTPUT, event->Par2);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_022, pin, log, 0));

          }

          else{

            addLog(LOG_LEVEL_ERROR, log + String(F(" is invalid value.")));

          }

        }



        if(istanceCommand && command == F("pulse"))

        {

          success = true;

          log = String(F("PCA 0x")) + String(address, HEX) + String(F(": GPIO ")) + String(event->Par1);

          if(event->Par1>=0 && event->Par1 <= PCA9685_MAX_PINS)

          {

            if (!IS_INIT(initializeState, ((address - PCA9685_ADDRESS)))) Plugin_022_initialize(address);



            if(event->Par2 == 0)

            {

              log += F(" off");

              Plugin_022_Off(address, event->Par1);

            }

            else

            {

              log += F(" on");

              Plugin_022_On(address, event->Par1);

            }

            log += String(F(" Pulse set for ")) + event->Par3;

            log += String(F("ms"));

            int autoreset = 0;

            if(event->Par3 > 0)

            {

              if(parseString(line, 5) == F("auto"))

              {

                autoreset = -1;

                log += String(F(" with autoreset infinity"));

              }

              else

              {

                autoreset = event->Par4;

                if(autoreset > 0)

                {

                  log += String(F(" for "));

                  log += String(autoreset);

                }

              }



            }

            setPluginTaskTimer(event->Par3 , PLUGIN_ID_022

              , event->TaskIndex

              , event->Par1

              , !event->Par2

              , event->Par3

              , autoreset);

            setPinState(PLUGIN_ID_022, event->Par1, PIN_MODE_OUTPUT, event->Par2);

            addLog(LOG_LEVEL_INFO, log);

            SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_022, event->Par1, log, 0));

          }

          else{

            addLog(LOG_LEVEL_ERROR, log + String(F(" is invalid value.")));

          }

        }



        break;

      }

      case PLUGIN_TIMER_IN:

      {

        String log = String(F("PCA 0x")) + String(address, HEX) + String(F(": GPIO ")) + String(event->Par1);

        int autoreset = event->Par4;

        if(event->Par2 == 0)

        {

          log += F(" off");

          Plugin_022_Off(address, event->Par1);

        }

        else

        {

          log += F(" on");

          Plugin_022_On(address, event->Par1);

        }

        if(autoreset > 0 || autoreset == -1)

        {

          if(autoreset > -1)

          {

            log += String(F(" Pulse auto restart for "));

            log += String(autoreset);

            autoreset--;

          }

          setPluginTaskTimer(event->Par3, PLUGIN_ID_022

            , event->TaskIndex

            , event->Par1

            , !event->Par2

            , event->Par3

            , autoreset);

        }

        setPinState(PLUGIN_ID_022, event->Par1, PIN_MODE_OUTPUT, event->Par2);

        SendStatus(event->Source, getPinStateJSON(SEARCH_PIN_STATE, PLUGIN_ID_022, event->Par1, log, 0));

        break;

      }

  }

  return success;

}
# 599 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P022_PCA9685.ino"
void Plugin_022_writeRegister(int i2cAddress, int regAddress, byte data) {

  Wire.beginTransmission(i2cAddress);

  Wire.write(regAddress);

  Wire.write(data);

  Wire.endTransmission();

}



uint8_t Plugin_022_readRegister(int i2cAddress, int regAddress) {

  uint8_t res = 0;

  Wire.requestFrom(i2cAddress,1,1);

  while (Wire.available()) {

    res = Wire.read();

  }

  return res;

}
# 639 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P022_PCA9685.ino"
void Plugin_022_Off(int address, int pin)

{

  Plugin_022_Write(address, pin, 0);

}



void Plugin_022_On(int address, int pin)

{

  Plugin_022_Write(address, pin, PCA9685_MAX_PWM);

}



void Plugin_022_Write(int address, int Par1, int Par2)

{

  int i2cAddress = address;



  int regAddress = Par1 == -1

    ? PCA9685_ALLLED_REG

    : PCA9685_LED0 + 4 * Par1;

  uint16_t LED_ON = 0;

  uint16_t LED_OFF = Par2;

  Wire.beginTransmission(i2cAddress);

  Wire.write(regAddress);

  Wire.write(lowByte(LED_ON));

  Wire.write(highByte(LED_ON));

  Wire.write(lowByte(LED_OFF));

  Wire.write(highByte(LED_OFF));

  Wire.endTransmission();

}



void Plugin_022_Frequency(int address, uint16_t freq)

{

  int i2cAddress = address;

  Plugin_022_writeRegister(i2cAddress, PLUGIN_022_PCA9685_MODE1, (byte)0x0);

  freq *= 0.9;



  uint16_t prescale = 6103;

  prescale /= freq;

  prescale -= 1;

  uint8_t oldmode = Plugin_022_readRegister(i2cAddress, 0);

  uint8_t newmode = (oldmode&0x7f) | 0x10;

  Plugin_022_writeRegister(i2cAddress, PLUGIN_022_PCA9685_MODE1, (byte)newmode);

  Plugin_022_writeRegister(i2cAddress, 0xfe, (byte)prescale);

  Plugin_022_writeRegister(i2cAddress, PLUGIN_022_PCA9685_MODE1, (byte)oldmode);

  delayMicroseconds(5000);

  Plugin_022_writeRegister(i2cAddress, PLUGIN_022_PCA9685_MODE1, (byte)oldmode | 0xa1);

}



void Plugin_022_initialize(int address)

{

  int i2cAddress = address;



  Plugin_022_writeRegister(i2cAddress, PLUGIN_022_PCA9685_MODE1, (byte)0x01);

  delay(1);

  Plugin_022_writeRegister(i2cAddress, PLUGIN_022_PCA9685_MODE1, (byte)B10100000);

  Plugin_022_writeRegister(i2cAddress, PCA9685_MODE2, (byte)0x10);

  SET_INIT(initializeState, (address - PCA9685_ADDRESS));

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P023_OLED.ino"
#ifdef USES_P023
# 23 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P023_OLED.ino"
#define PLUGIN_023 

#define PLUGIN_ID_023 23

#define PLUGIN_NAME_023 "Display - OLED SSD1306"

#define PLUGIN_VALUENAME1_023 "OLED"

#define PLUGIN_023_MAX_DYSPALY 2



struct Plugin_023_OLED_SettingStruct

{

  Plugin_023_OLED_SettingStruct(): address(0)

  , type(0),font_width(0),displayTimer(0){}

  byte address;

  byte type;

  byte font_width;

  byte displayTimer;

} OLED_Settings[PLUGIN_023_MAX_DYSPALY];



enum

{

  OLED_64x48 = 0x01,

  OLED_rotated = 0x02,

  OLED_128x32 = 0x04

};



enum

{

  Size_normal = 0x01,

  Size_optimized = 0x02

};



boolean Plugin_023(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_023;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_023);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_023));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        int optionValues[2] = { 0x3C, 0x3D };

        addFormSelectorI2C(F("plugin_023_adr"), 2, optionValues, choice);



        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options2[2] = { F("Normal"), F("Rotated") };

        int optionValues2[2] = { 1, 2 };

        addFormSelector(F("Rotation"), F("plugin_023_rotate"), 2, options2, optionValues2, choice2);



        byte choice3 = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

        String options3[3] = { F("128x64"), F("128x32"), F("64x48") };

        int optionValues3[3] = { 1, 3, 2 };

        addFormSelector(F("Display Size"), F("plugin_023_size"), 3, options3, optionValues3, choice3);



        byte choice4 = Settings.TaskDevicePluginConfig[event->TaskIndex][4];

        String options4[2] = { F("Normal"), F("Optimized") };

        int optionValues4[2] = { 1, 2 };

        addFormSelector(F("Font Width"), F("plugin_023_font_width"), 2, options4, optionValues4, choice4);



        char deviceTemplate[8][64];

        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));

        for (byte varNr = 0; varNr < 8; varNr++)

        {

          addFormTextBox(String(F("Line ")) + (varNr + 1), String(F("Plugin_023_template")) + (varNr + 1), deviceTemplate[varNr], 64);

        }



        addFormPinSelect(F("Display button"), F("taskdevicepin3"), Settings.TaskDevicePin3[event->TaskIndex]);



        addFormNumericBox(F("Display Timeout"), F("plugin_23_timer"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_023_adr"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_023_rotate"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_23_timer"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("plugin_023_size"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][4] = getFormItemInt(F("plugin_023_font_width"));



        char deviceTemplate[8][64];

        for (byte varNr = 0; varNr < 8; varNr++)

        {

          String arg = F("Plugin_023_template");

          arg += varNr + 1;

          String tmpString = WebServer.arg(arg);

          strncpy(deviceTemplate[varNr], tmpString.c_str(), sizeof(deviceTemplate[varNr])-1);

          deviceTemplate[varNr][63]=0;

        }



        SaveCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        int index = Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 0x3C

         ? 0

         : 1;

        OLED_Settings[index].address = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        OLED_Settings[index].type = 0;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3] == 3)

        {

          OLED_Settings[index].type = OLED_128x32;

        }

        OLED_Settings[index].font_width = Size_normal;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][4] == 2)

        {

          OLED_Settings[index].font_width = Size_optimized;

        }



        Plugin_023_StartUp_OLED(OLED_Settings[index]);

        Plugin_023_clear_display(OLED_Settings[index]);

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 2)

        {

          OLED_Settings[index].type |= OLED_rotated;

          Plugin_023_sendcommand(OLED_Settings[index].address, 0xA0 | 0x1);

          Plugin_023_sendcommand(OLED_Settings[index].address, 0xC8);

        }

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3] == 2)

        {

          OLED_Settings[index].type |= OLED_64x48;

        }



        Plugin_023_sendStrXY(OLED_Settings[index], "ESP Easy ", 0, 0);

        OLED_Settings[index].displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

          pinMode(Settings.TaskDevicePin3[event->TaskIndex], INPUT_PULLUP);

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

        {

          int index = Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 0x3C

                    ? 0

                    : 1;

          if (!digitalRead(Settings.TaskDevicePin3[event->TaskIndex]))

          {

            Plugin_023_displayOn(OLED_Settings[index]);

            OLED_Settings[index].displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

          }

        }

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        int index = Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 0x3C

          ? 0

          : 1;



        if (OLED_Settings[index].displayTimer > 0)

        {

          OLED_Settings[index].displayTimer--;

          if (OLED_Settings[index].displayTimer == 0)

            Plugin_023_displayOff(OLED_Settings[index]);

        }

        break;

      }



    case PLUGIN_READ:

      {

        char deviceTemplate[8][64];

        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));

        int index = Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 0x3C

          ? 0

          : 1;



        for (byte x = 0; x < 8; x++)

        {

          String tmpString = deviceTemplate[x];

          if (tmpString.length())

          {

            String newString = P023_parseTemplate(tmpString, 16);

            Plugin_023_sendStrXY(OLED_Settings[index],newString.c_str(), x, 0);

          }

        }

        success = false;

        break;

      }



    case PLUGIN_WRITE:

      {

        int index = Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 0x3C

          ? 0

          : 1;

        String arguments = String(string);

        int dotPos = arguments.indexOf('.');

        if(dotPos > -1)

        {

          LoadTaskSettings(event->TaskIndex);

          String name = arguments.substring(0,dotPos);

          name.replace(F("["),F(""));

          name.replace(F("]"),F(""));

          if(name.equalsIgnoreCase(getTaskDeviceName(event->TaskIndex)) == true)

          {

            arguments = arguments.substring(dotPos+1);

          }

          else

          {

             return false;

          }

        }



        int argIndex = arguments.indexOf(',');

        if (argIndex)

          arguments = arguments.substring(0, argIndex);

        if (arguments.equalsIgnoreCase(F("OLEDCMD")))

        {

          success = true;

          argIndex = string.lastIndexOf(',');

          arguments = string.substring(argIndex + 1);

          if (arguments.equalsIgnoreCase(F("Off")))

            Plugin_023_displayOff(OLED_Settings[index]);

          else if (arguments.equalsIgnoreCase(F("On")))

            Plugin_023_displayOn(OLED_Settings[index]);

          else if (arguments.equalsIgnoreCase(F("Clear")))

            Plugin_023_clear_display(OLED_Settings[index]);

        }

        else if (arguments.equalsIgnoreCase(F("OLED")))

        {

          success = true;

          argIndex = string.lastIndexOf(',');

          arguments = string.substring(argIndex + 1);

          String newString = P023_parseTemplate(arguments, 16);

          Plugin_023_sendStrXY(OLED_Settings[index], newString.c_str(), event->Par1 - 1, event->Par2 - 1);

        }

        break;

      }

  }

  return success;

}



const char Plugin_023_myFont_Size[] PROGMEM = {

  0x05,

  0x05,

  0x07,

  0x08,

  0x08,

  0x08,

  0x08,

  0x06,

  0x06,

  0x06,

  0x08,

  0x08,

  0x05,

  0x08,

  0x05,

  0x08,

  0x08,

  0x07,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x06,

  0x06,

  0x07,

  0x08,

  0x07,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x06,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x08,

  0x06,

  0x08,

  0x06,

  0x08,

  0x08,

  0x06,

  0x08,

  0x08,

  0x07,

  0x08,

  0x08,

  0x07,

  0x08,

  0x08,

  0x05,

  0x06,

  0x07,

  0x06,

  0x08,

  0x07,

  0x07,

  0x07,

  0x07,

  0x07,

  0x07,

  0x06,

  0x07,

  0x08,

  0x08,

  0x08,

  0x07,

  0x08,

  0x06,

  0x05,

  0x06,

  0x08,

  0x08

};





String P023_parseTemplate(String &tmpString, byte lineSize) {

  String result = parseTemplate(tmpString, lineSize);

  const char degree[3] = {0xc2, 0xb0, 0};

  const char degree_oled[2] = {0x7F, 0};

  result.replace(degree, degree_oled);

  return result;

}







const char Plugin_023_myFont[][8] PROGMEM = {

  {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00},

  {0x00, 0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00},

  {0x00, 0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00},

  {0x00, 0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00},

  {0x00, 0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00},

  {0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x08, 0x2A, 0x1C, 0x2A, 0x08, 0x00, 0x00},

  {0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00},

  {0x00, 0xA0, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00},

  {0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00},

  {0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00},

  {0x00, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00},

  {0x00, 0x62, 0x51, 0x49, 0x49, 0x46, 0x00, 0x00},

  {0x00, 0x22, 0x41, 0x49, 0x49, 0x36, 0x00, 0x00},

  {0x00, 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00},

  {0x00, 0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00},

  {0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00},

  {0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00},

  {0x00, 0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00},

  {0x00, 0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00},

  {0x00, 0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x00, 0xAC, 0x6C, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00},

  {0x00, 0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00},

  {0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00},

  {0x00, 0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00},

  {0x00, 0x32, 0x49, 0x79, 0x41, 0x3E, 0x00, 0x00},

  {0x00, 0x7E, 0x09, 0x09, 0x09, 0x7E, 0x00, 0x00},

  {0x00, 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00},

  {0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00},

  {0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00},

  {0x00, 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00},

  {0x00, 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00},

  {0x00, 0x3E, 0x41, 0x41, 0x51, 0x72, 0x00, 0x00},

  {0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00},

  {0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00},

  {0x00, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00},

  {0x00, 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00},

  {0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00},

  {0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00},

  {0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00},

  {0x00, 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00},

  {0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00},

  {0x00, 0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00},

  {0x00, 0x26, 0x49, 0x49, 0x49, 0x32, 0x00, 0x00},

  {0x00, 0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00},

  {0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00},

  {0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00},

  {0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x00},

  {0x00, 0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00},

  {0x00, 0x03, 0x04, 0x78, 0x04, 0x03, 0x00, 0x00},

  {0x00, 0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00},

  {0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00},

  {0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00},

  {0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00},

  {0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00},

  {0x00, 0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00},

  {0x00, 0x38, 0x44, 0x44, 0x28, 0x00, 0x00, 0x00},

  {0x00, 0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00},

  {0x00, 0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00},

  {0x00, 0x08, 0x7E, 0x09, 0x02, 0x00, 0x00, 0x00},

  {0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C, 0x00, 0x00},

  {0x00, 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00},

  {0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x80, 0x84, 0x7D, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00},

  {0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00},

  {0x00, 0x7C, 0x08, 0x04, 0x7C, 0x00, 0x00, 0x00},

  {0x00, 0x38, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00},

  {0x00, 0xFC, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00},

  {0x00, 0x18, 0x24, 0x24, 0xFC, 0x00, 0x00, 0x00},

  {0x00, 0x00, 0x7C, 0x08, 0x04, 0x00, 0x00, 0x00},

  {0x00, 0x48, 0x54, 0x54, 0x24, 0x00, 0x00, 0x00},

  {0x00, 0x04, 0x7F, 0x44, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x3C, 0x40, 0x40, 0x7C, 0x00, 0x00, 0x00},

  {0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00},

  {0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, 0x00},

  {0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00},

  {0x00, 0x1C, 0xA0, 0xA0, 0x7C, 0x00, 0x00, 0x00},

  {0x00, 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00},

  {0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, 0x00},

  {0x00, 0x02, 0x01, 0x01, 0x02, 0x01, 0x00, 0x00},

  {0x00, 0x02, 0x05, 0x05, 0x02, 0x00, 0x00, 0x00}

};



void Plugin_023_reset_display(struct Plugin_023_OLED_SettingStruct &oled)

{

  Plugin_023_displayOff(oled);

  Plugin_023_clear_display(oled);

  Plugin_023_displayOn(oled);

}





void Plugin_023_StartUp_OLED(struct Plugin_023_OLED_SettingStruct &oled)

{

  Plugin_023_init_OLED(oled);

  Plugin_023_reset_display(oled);

  Plugin_023_displayOff(oled);

  Plugin_023_setXY(oled, 0, 0);

  Plugin_023_clear_display(oled);

  Plugin_023_displayOn(oled);

}





void Plugin_023_displayOn(struct Plugin_023_OLED_SettingStruct &oled)

{

  Plugin_023_sendcommand(oled.address, 0xaf);

}





void Plugin_023_displayOff(struct Plugin_023_OLED_SettingStruct &oled)

{

  Plugin_023_sendcommand(oled.address, 0xae);

}





void Plugin_023_clear_display(struct Plugin_023_OLED_SettingStruct &oled)

{

  unsigned char i, k;

  for (k = 0; k < 8; k++)

  {

    Plugin_023_setXY(oled, k, 0);

    {

      for (i = 0; i < 128; i++)

      {

        Plugin_023_SendChar(oled, 0);

      }

    }

  }

}







void Plugin_023_SendChar(struct Plugin_023_OLED_SettingStruct &oled, unsigned char data)

{

  Wire.beginTransmission(oled.address);

  Wire.write(0x40);

  Wire.write(data);

  Wire.endTransmission();

}
# 1117 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P023_OLED.ino"
void Plugin_023_sendcommand(byte address, unsigned char com)

{

  Wire.beginTransmission(address);

  Wire.write(0x80);

  Wire.write(com);

  Wire.endTransmission();

}
# 1139 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P023_OLED.ino"
void Plugin_023_setXY(struct Plugin_023_OLED_SettingStruct &oled, unsigned char row, unsigned char col)

{

  switch (oled.type)

  {

    case OLED_64x48:

      col += 4;

      break;

    case OLED_64x48 | OLED_rotated:

      col += 4;

      row += 2;

  }



  Plugin_023_sendcommand(oled.address, 0xb0 + row);

  Plugin_023_sendcommand(oled.address, 0x00 + (8 * col & 0x0f));

  Plugin_023_sendcommand(oled.address, 0x10 + ((8 * col >> 4) & 0x0f));

}
# 1211 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P023_OLED.ino"
void Plugin_023_sendStrXY(struct Plugin_023_OLED_SettingStruct &oled, const char *string, int X, int Y)

{

  Plugin_023_setXY(oled, X, Y);

  unsigned char i = 0;

  unsigned char font_width = 0;



  while (*string)

  {

    switch (oled.font_width)

    {

      case Size_optimized:

        font_width = pgm_read_byte(&(Plugin_023_myFont_Size[*string - 0x20]));

        break;

      default:

        font_width = 8;

    }



    for (i = 0; i < font_width; i++)

    {

      Plugin_023_SendChar(oled, pgm_read_byte(Plugin_023_myFont[*string - 0x20] + i));

    }

    string++;

  }

}





void Plugin_023_init_OLED(struct Plugin_023_OLED_SettingStruct &oled)

{

  unsigned char multiplex;

  unsigned char compins;

  byte address = oled.address;

  switch (oled.type)

  {

    case OLED_128x32:

      multiplex = 0x1F;

      compins = 0x02;

      break;

    default:

      multiplex = 0x3F;

      compins = 0x12;

  }



  Plugin_023_sendcommand(address, 0xAE);

  Plugin_023_sendcommand(address, 0xD5);

  Plugin_023_sendcommand(address, 0x80);

  Plugin_023_sendcommand(address, 0xA8);

  Plugin_023_sendcommand(address, multiplex);

  Plugin_023_sendcommand(address, 0xD3);

  Plugin_023_sendcommand(address, 0x00);

  Plugin_023_sendcommand(address, 0x40 | 0x0);

  Plugin_023_sendcommand(address, 0x8D);

  Plugin_023_sendcommand(address, 0x14);

  Plugin_023_sendcommand(address, 0x20);

  Plugin_023_sendcommand(address, 0x00);

  Plugin_023_sendcommand(address, 0xA0);

  Plugin_023_sendcommand(address, 0xC0);

  Plugin_023_sendcommand(address, 0xDA);

  Plugin_023_sendcommand(address, compins);

  Plugin_023_sendcommand(address, 0x81);

  Plugin_023_sendcommand(address, 0xCF);

  Plugin_023_sendcommand(address, 0xD9);

  Plugin_023_sendcommand(address, 0xF1);

  Plugin_023_sendcommand(address, 0xDB);

  Plugin_023_sendcommand(address, 0x40);

  Plugin_023_sendcommand(address, 0xA4);

  Plugin_023_sendcommand(address, 0xA6);



  Plugin_023_clear_display(oled);

  Plugin_023_sendcommand(address, 0x2E);

  Plugin_023_sendcommand(address, 0x20);

  Plugin_023_sendcommand(address, 0x00);



}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P024_MLX90614.ino"
#ifdef USES_P024
# 15 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P024_MLX90614.ino"
#define PLUGIN_024 

#define PLUGIN_ID_024 24

#define PLUGIN_NAME_024 "Environment - MLX90614"

#define PLUGIN_VALUENAME1_024 "Temperature"



boolean Plugin_024_init = false;



uint16_t readRegister024(uint8_t i2cAddress, uint8_t reg) {

  uint16_t ret;

  Wire.beginTransmission(i2cAddress);

  Wire.write(reg);

  Wire.endTransmission(false);

  Wire.requestFrom(i2cAddress, (uint8_t)3);

  ret = Wire.read();

  ret |= Wire.read() << 8;

  Wire.read();

  return ret;

}



float readTemp024(uint8_t i2c_addr, uint8_t i2c_reg)

{

  float temp;

  temp = readRegister024(i2c_addr, i2c_reg);

  temp *= .02;

  temp -= 273.15;

  return temp;

}



boolean Plugin_024(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_024;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 16;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_024);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_024));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        #define MLX90614_OPTION 2



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[MLX90614_OPTION];

        int optionValues[MLX90614_OPTION];

        optionValues[0] = (0x07);

        options[0] = F("IR object temperature");

        optionValues[1] = (0x06);

        options[1] = F("Ambient temperature");

        addFormSelector(F("Option"), F("plugin_024_option"), MLX90614_OPTION, options, optionValues, choice);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_024_option"));

        Plugin_024_init = false;

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_024_init = true;
# 205 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P024_MLX90614.ino"
        success = true;

        break;

      }



    case PLUGIN_READ:

      {







        byte unit = Settings.TaskDevicePort[event->TaskIndex];

        uint8_t address = 0x5A + unit;

        UserVar[event->BaseVarIndex] = (float) readTemp024(address, Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        String log = F("MLX90614  : Temperature: ");

        log += UserVar[event->BaseVarIndex];



        addLog(LOG_LEVEL_INFO,log);

        success = true;



        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P025_ADS1115.ino"
#ifdef USES_P025
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P025_ADS1115.ino"
#define PLUGIN_025 

#define PLUGIN_ID_025 25

#define PLUGIN_NAME_025 "Analog input - ADS1115"

#define PLUGIN_VALUENAME1_025 "Analog"



boolean Plugin_025_init = false;



uint16_t readRegister025(uint8_t i2cAddress, uint8_t reg) {

  Wire.beginTransmission(i2cAddress);

  Wire.write((0x00));

  Wire.endTransmission();

  if (Wire.requestFrom(i2cAddress, (uint8_t)2) != 2)

    return 0x8000;

  return ((Wire.read() << 8) | Wire.read());

}



boolean Plugin_025(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_025;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_025);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_025));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte port = Settings.TaskDevicePort[event->TaskIndex];

        if (port > 0)

        {

          Settings.TaskDevicePluginConfig[event->TaskIndex][1] = Settings.TaskDevicePluginConfig[event->TaskIndex][0] / 2;

          Settings.TaskDevicePluginConfig[event->TaskIndex][0] = 0x48 + ((port-1)/4);

          Settings.TaskDevicePluginConfig[event->TaskIndex][2] = ((port-1) & 3) | 4;

          Settings.TaskDevicePort[event->TaskIndex] = 0;

        }



        #define ADS1115_I2C_OPTION 4

        byte addr = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        int optionValues[ADS1115_I2C_OPTION] = { 0x48, 0x49, 0x4A, 0x4B };

        addFormSelectorI2C(F("plugin_025_i2c"), ADS1115_I2C_OPTION, optionValues, addr);



        addFormSubHeader(F("Input"));



        #define ADS1115_PGA_OPTION 6

        byte pga = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String pgaOptions[ADS1115_PGA_OPTION] = {

          F("2/3x gain (FS=6.144V)"),

          F("1x gain (FS=4.096V)"),

          F("2x gain (FS=2.048V)"),

          F("4x gain (FS=1.024V)"),

          F("8x gain (FS=0.512V)"),

          F("16x gain (FS=0.256V)")

        };

        addFormSelector(F("Gain"), F("plugin_025_gain"), ADS1115_PGA_OPTION, pgaOptions, NULL, pga);



        #define ADS1115_MUX_OPTION 8

        byte mux = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        String muxOptions[ADS1115_MUX_OPTION] = {

          F("AIN0 - AIN1 (Differential)"),

          F("AIN0 - AIN3 (Differential)"),

          F("AIN1 - AIN3 (Differential)"),

          F("AIN2 - AIN3 (Differential)"),

          F("AIN0 - GND (Single-Ended)"),

          F("AIN1 - GND (Single-Ended)"),

          F("AIN2 - GND (Single-Ended)"),

          F("AIN3 - GND (Single-Ended)"),

        };

        addFormSelector(F("Input Multiplexer"), F("plugin_025_mode"), ADS1115_MUX_OPTION, muxOptions, NULL, mux);



        addFormSubHeader(F("Two Point Calibration"));



        addFormCheckBox(F("Calibration Enabled"), F("plugin_025_cal"), Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        addFormNumericBox(F("Point 1"), F("plugin_025_adc1"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][0], -32768, 32767);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_025_out1"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0], 3), 10);



        addFormNumericBox(F("Point 2"), F("plugin_025_adc2"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][1], -32768, 32767);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_025_out2"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1], 3), 10);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_025_i2c"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_025_gain"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_025_mode"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = isFormItemChecked(F("plugin_025_cal"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = getFormItemInt(F("plugin_025_adc1"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = getFormItemFloat(F("plugin_025_out1"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = getFormItemInt(F("plugin_025_adc2"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] = getFormItemFloat(F("plugin_025_out2"));



        Plugin_025_init = false;

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_025_init = true;

        success = true;

        break;

      }



    case PLUGIN_READ:

      {
# 301 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P025_ADS1115.ino"
        uint8_t address = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        uint16_t config = (0x0003) |

                          (0x0000) |

                          (0x0000) |

                          (0x0000) |

                          (0x0080) |

                          (0x0100);



        uint16_t pga = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        config |= pga << 9;



        uint16_t mux = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        config |= mux << 12;



        config |= (0x8000);



        Wire.beginTransmission(address);

        Wire.write((uint8_t)(0x01));

        Wire.write((uint8_t)(config >> 8));

        Wire.write((uint8_t)(config & 0xFF));

        Wire.endTransmission();



        String log = F("ADS1115 : Analog value: ");



        delay(8);

        int16_t value = readRegister025((address), (0x00));

        UserVar[event->BaseVarIndex] = (float)value;

        log += value;



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3])

        {

          int adc1 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][0];

          int adc2 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][1];

          float out1 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0];

          float out2 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1];

          if (adc1 != adc2)

          {

            float normalized = (float)(value - adc1) / (float)(adc2 - adc1);

            UserVar[event->BaseVarIndex] = normalized * (out2 - out1) + out1;



            log += F(" ");

            log += UserVar[event->BaseVarIndex];

          }

        }







        addLog(LOG_LEVEL_DEBUG,log);

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P026_Sysinfo.ino"
#ifdef USES_P026
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P026_Sysinfo.ino"
#define PLUGIN_026 

#define PLUGIN_ID_026 26

#define PLUGIN_NAME_026 "Generic - System Info"

#define PLUGIN_VALUENAME1_026 ""



boolean Plugin_026(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_026;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].FormulaOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_026);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_026));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[10];

        options[0] = F("Uptime");

        options[1] = F("Free RAM");

        options[2] = F("Wifi RSSI");

        options[3] = F("Input VCC");

        options[4] = F("System load");

        options[5] = F("IP 1.Octet");

        options[6] = F("IP 2.Octet");

        options[7] = F("IP 3.Octet");

        options[8] = F("IP 4.Octet");

        options[9] = F("Web activity");

        addFormSelector(F("Indicator"), F("plugin_026"), 10, options, NULL, choice);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_026"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        float value = 0;

        switch(Settings.TaskDevicePluginConfig[event->TaskIndex][0])

        {

          case 0:

          {

            value = (wdcounter /2);

            break;

          }

          case 1:

          {

            value = ESP.getFreeHeap();

            break;

          }

          case 2:

          {

            value = WiFi.RSSI();

            break;

          }

          case 3:

          {

#if FEATURE_ADC_VCC

            value = vcc;

#else

            value = -1.0;

#endif

            break;

          }

          case 4:

          {

            value = getCPUload();

            break;

          }

          case 5:

          {

            value = WiFi.localIP()[0];

            break;

          }

          case 6:

          {

            value = WiFi.localIP()[1];

            break;

          }

          case 7:

          {

            value = WiFi.localIP()[2];

            break;

          }

          case 8:

          {

            value = WiFi.localIP()[3];

            break;

          }

          case 9:

          {

            value = (millis()-lastWeb)/1000;

            break;

          }

        }

        UserVar[event->BaseVarIndex] = value;

        String log = F("SYS  : ");

        log += value;

        addLog(LOG_LEVEL_INFO,log);

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
#ifdef USES_P027
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
#define PLUGIN_027 

#define PLUGIN_ID_027 27

#define PLUGIN_NAME_027 "Energy (DC) - INA219"

#define PLUGIN_VALUENAME1_027 "Voltage"

#define PLUGIN_VALUENAME2_027 "Current"

#define PLUGIN_VALUENAME3_027 "Power"
# 31 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
#define INA219_ADDRESS (0x40)

#define INA219_ADDRESS2 (0x41)

#define INA219_ADDRESS3 (0x44)

#define INA219_ADDRESS4 (0x45)

#define INA219_READ (0x01)

#define INA219_REG_CONFIG (0x00)

#define INA219_CONFIG_RESET (0x8000)



#define INA219_CONFIG_BVOLTAGERANGE_MASK (0x2000)

#define INA219_CONFIG_BVOLTAGERANGE_16V (0x0000)

#define INA219_CONFIG_BVOLTAGERANGE_32V (0x2000)



#define INA219_CONFIG_GAIN_MASK (0x1800)

#define INA219_CONFIG_GAIN_1_40MV (0x0000)

#define INA219_CONFIG_GAIN_2_80MV (0x0800)

#define INA219_CONFIG_GAIN_4_160MV (0x1000)

#define INA219_CONFIG_GAIN_8_320MV (0x1800)



#define INA219_CONFIG_BADCRES_MASK (0x0780)

#define INA219_CONFIG_BADCRES_9BIT (0x0080)

#define INA219_CONFIG_BADCRES_10BIT (0x0100)

#define INA219_CONFIG_BADCRES_11BIT (0x0200)

#define INA219_CONFIG_BADCRES_12BIT (0x0400)



#define INA219_CONFIG_SADCRES_MASK (0x0078)

#define INA219_CONFIG_SADCRES_9BIT_1S_84US (0x0000)

#define INA219_CONFIG_SADCRES_10BIT_1S_148US (0x0008)

#define INA219_CONFIG_SADCRES_11BIT_1S_276US (0x0010)

#define INA219_CONFIG_SADCRES_12BIT_1S_532US (0x0018)

#define INA219_CONFIG_SADCRES_12BIT_2S_1060US (0x0048)

#define INA219_CONFIG_SADCRES_12BIT_4S_2130US (0x0050)

#define INA219_CONFIG_SADCRES_12BIT_8S_4260US (0x0058)

#define INA219_CONFIG_SADCRES_12BIT_16S_8510US (0x0060)

#define INA219_CONFIG_SADCRES_12BIT_32S_17MS (0x0068)

#define INA219_CONFIG_SADCRES_12BIT_64S_34MS (0x0070)

#define INA219_CONFIG_SADCRES_12BIT_128S_69MS (0x0078)



#define INA219_CONFIG_MODE_MASK (0x0007)

#define INA219_CONFIG_MODE_POWERDOWN (0x0000)

#define INA219_CONFIG_MODE_SVOLT_TRIGGERED (0x0001)

#define INA219_CONFIG_MODE_BVOLT_TRIGGERED (0x0002)

#define INA219_CONFIG_MODE_SANDBVOLT_TRIGGERED (0x0003)

#define INA219_CONFIG_MODE_ADCOFF (0x0004)

#define INA219_CONFIG_MODE_SVOLT_CONTINUOUS (0x0005)

#define INA219_CONFIG_MODE_BVOLT_CONTINUOUS (0x0006)

#define INA219_CONFIG_MODE_SANDBVOLT_CONTINUOUS (0x0007)



#define INA219_REG_SHUNTVOLTAGE (0x01)

#define INA219_REG_BUSVOLTAGE (0x02)

#define INA219_REG_POWER (0x03)

#define INA219_REG_CURRENT (0x04)

#define INA219_REG_CALIBRATION (0x05)



typedef struct {

  uint32_t calValue;





  uint32_t currentDivider_mA;

} ina219_data;



ina219_data _ina219_data[4];

int Plugin_27_i2c_addresses[4] = { INA219_ADDRESS, INA219_ADDRESS2, INA219_ADDRESS3, INA219_ADDRESS4 };



uint8_t Plugin_027_i2c_addr(struct EventStruct *event) {

   return (uint8_t)Settings.TaskDevicePluginConfig[event->TaskIndex][1];

}



uint8_t Plugin_027_device_index(const uint8_t i2caddr) {

  switch(i2caddr) {

    case INA219_ADDRESS: return 0u;

    case INA219_ADDRESS2: return 1u;

    case INA219_ADDRESS3: return 2u;

    case INA219_ADDRESS4: return 3u;

  }

  return 0u;

}



boolean Plugin_027(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_027;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_027);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_027));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_027));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_027));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choiceMode = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String optionsMode[3];

        optionsMode[0] = F("32V, 2A");

        optionsMode[1] = F("32V, 1A");

        optionsMode[2] = F("16V, 0.4A");

        int optionValuesMode[3];

        optionValuesMode[0] = 0;

        optionValuesMode[1] = 1;

        optionValuesMode[2] = 2;

        addFormSelector(F("Measure range"), F("plugin_027_range"), 3, optionsMode, optionValuesMode, choiceMode);



        addFormSelectorI2C(F("plugin_027_i2c"), 4, Plugin_27_i2c_addresses, Plugin_027_i2c_addr(event));



        byte choiceMeasureType = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        String options[4] = { F("Voltage"), F("Current"), F("Power"), F("Voltage/Current/Power") };

        addFormSelector(F("Measurement Type"), F("plugin_027_measuretype"), 4, options, NULL, choiceMeasureType );



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_027_range"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_027_i2c"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_027_measuretype"));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

       const uint8_t i2caddr = Plugin_027_i2c_addr(event);

        const uint8_t idx = Plugin_027_device_index(i2caddr);

        _ina219_data[idx].currentDivider_mA = 0;

        String log = F("INA219 0x");

        log += String(i2caddr,HEX);

        log += F(" setting Range to: ");

        switch (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

        {

        case 0:

        {

            log += F("32V, 2A");

          Plugin_027_setCalibration_32V_2A(i2caddr);

         break;

        }

        case 1:

        {

            log += F("32V, 1A");

         Plugin_027_setCalibration_32V_1A(i2caddr);

         break;

        }

        case 2:

        {

            log += F("16V, 400mA");

         Plugin_027_setCalibration_16V_400mA(i2caddr);

         break;

        }

        }

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_READ:

      {
# 403 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
        const uint8_t i2caddr = Plugin_027_i2c_addr(event);



    float voltage = Plugin_027_getBusVoltage_V(i2caddr) + (Plugin_027_getShuntVoltage_mV(i2caddr) / 1000);

    float current = Plugin_027_getCurrent_mA(i2caddr)/1000;

    float power = voltage * current;



        UserVar[event->BaseVarIndex] = voltage;

       UserVar[event->BaseVarIndex + 1] = current;

       UserVar[event->BaseVarIndex + 2] = power;



       String log = F("INA219 0x");

       log += String(i2caddr,HEX);







        switch (Settings.TaskDevicePluginConfig[event->TaskIndex][2])

        {

          case 0:

          {

            event->sensorType = SENSOR_TYPE_SINGLE;

            UserVar[event->BaseVarIndex] = voltage;

           log += F(": Voltage: ");

           log += voltage;

            break;

          }

          case 1:

          {

            event->sensorType = SENSOR_TYPE_SINGLE;

            UserVar[event->BaseVarIndex] = current;

           log += F(" Current: ");

           log += current;

            break;

          }

          case 2:

          {

            event->sensorType = SENSOR_TYPE_SINGLE;

            UserVar[event->BaseVarIndex] = power;

           log += F(" Power: ");

           log += power;

            break;

          }

          case 3:

          {

            event->sensorType = SENSOR_TYPE_TRIPLE;

            UserVar[event->BaseVarIndex] = voltage;

            UserVar[event->BaseVarIndex+1] = current;

            UserVar[event->BaseVarIndex+2] = power;

           log += F(": Voltage: ");

           log += voltage;

           log += F(" Current: ");

           log += current;

           log += F(" Power: ");

           log += power;

            break;

          }

        }



        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }

  }

  return success;

}
# 539 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
void Plugin_027_wireWriteRegister (uint8_t i2caddr, uint8_t reg, uint16_t value)

{

  Wire.beginTransmission(i2caddr);

  Wire.write(reg);

  Wire.write((value >> 8) & 0xFF);

  Wire.write(value & 0xFF);

  Wire.endTransmission();

}
# 563 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
void Plugin_027_wireReadRegister(uint8_t i2caddr, uint8_t reg, uint16_t *value)

{



  Wire.beginTransmission(i2caddr);

  Wire.write(reg);

  Wire.endTransmission();



  delay(1);



  Wire.requestFrom(i2caddr, (uint8_t)2);



  *value = ((Wire.read() << 8) | Wire.read());

}
# 597 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
void Plugin_027_setCalibration_32V_2A(uint8_t i2caddr) {

  const uint8_t idx = Plugin_027_device_index(i2caddr);

  _ina219_data[idx].calValue = 4027;





  _ina219_data[idx].currentDivider_mA = 10;





  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CALIBRATION, _ina219_data[idx].calValue);





  uint16_t config = INA219_CONFIG_BVOLTAGERANGE_32V |

                    INA219_CONFIG_GAIN_8_320MV |

                    INA219_CONFIG_BADCRES_12BIT |

                    INA219_CONFIG_SADCRES_12BIT_1S_532US |

                    INA219_CONFIG_MODE_SANDBVOLT_CONTINUOUS;

  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CONFIG, config);

}
# 641 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
void Plugin_027_setCalibration_32V_1A(uint8_t i2caddr) {

  const uint8_t idx = Plugin_027_device_index(i2caddr);

  _ina219_data[idx].calValue = 10240;





  _ina219_data[idx].currentDivider_mA = 25;





  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CALIBRATION, _ina219_data[idx].calValue);





  uint16_t config = INA219_CONFIG_BVOLTAGERANGE_32V |

                    INA219_CONFIG_GAIN_8_320MV |

                    INA219_CONFIG_BADCRES_12BIT |

                    INA219_CONFIG_SADCRES_12BIT_1S_532US |

                    INA219_CONFIG_MODE_SANDBVOLT_CONTINUOUS;

  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CONFIG, config);

}
# 685 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
void Plugin_027_setCalibration_16V_400mA(uint8_t i2caddr) {

  const uint8_t idx = Plugin_027_device_index(i2caddr);



  _ina219_data[idx].calValue = 8192;





  _ina219_data[idx].currentDivider_mA = 20;





  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CALIBRATION, _ina219_data[idx].calValue);





  uint16_t config = INA219_CONFIG_BVOLTAGERANGE_16V |

                    INA219_CONFIG_GAIN_1_40MV |

                    INA219_CONFIG_BADCRES_12BIT |

                    INA219_CONFIG_SADCRES_12BIT_1S_532US |

                    INA219_CONFIG_MODE_SANDBVOLT_CONTINUOUS;

  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CONFIG, config);

}
# 733 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
int16_t Plugin_027_getBusVoltage_raw(uint8_t i2caddr) {

  uint16_t value;

  Plugin_027_wireReadRegister(i2caddr, INA219_REG_BUSVOLTAGE, &value);





  return (int16_t)((value >> 3) * 4);

}
# 755 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
int16_t Plugin_027_getShuntVoltage_raw(uint8_t i2caddr) {

  uint16_t value;

  Plugin_027_wireReadRegister(i2caddr, INA219_REG_SHUNTVOLTAGE, &value);

  return (int16_t)value;

}
# 773 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
int16_t Plugin_027_getCurrent_raw(uint8_t i2caddr) {

  const uint8_t idx = Plugin_027_device_index(i2caddr);

  uint16_t value;
# 789 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
  Plugin_027_wireWriteRegister(i2caddr, INA219_REG_CALIBRATION, _ina219_data[idx].calValue);





  Plugin_027_wireReadRegister(i2caddr, INA219_REG_CURRENT, &value);



  return (int16_t)value;

}
# 811 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
float Plugin_027_getShuntVoltage_mV(uint8_t i2caddr) {

  int16_t value;

  value = Plugin_027_getShuntVoltage_raw(i2caddr);

  return value * 0.01;

}
# 829 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
float Plugin_027_getBusVoltage_V(uint8_t i2caddr) {

  int16_t value = Plugin_027_getBusVoltage_raw(i2caddr);

  return value * 0.001;

}
# 847 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P027_INA219.ino"
float Plugin_027_getCurrent_mA(uint8_t i2caddr) {

  const uint8_t idx = Plugin_027_device_index(i2caddr);

  float valueDec = Plugin_027_getCurrent_raw(i2caddr);

  valueDec /= _ina219_data[idx].currentDivider_mA;

  return valueDec;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
#ifdef USES_P028
# 13 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
#include <Arduino.h>

#include <map>



#define PLUGIN_028 

#define PLUGIN_ID_028 28

#define PLUGIN_NAME_028 "Environment - BMx280"

#define PLUGIN_VALUENAME1_028 "Temperature"

#define PLUGIN_VALUENAME2_028 "Humidity"

#define PLUGIN_VALUENAME3_028 "Pressure"



#define PLUGIN_028_BME280_DEVICE "BME280"

#define PLUGIN_028_BMP280_DEVICE "BMP280"



#define BMx280_REGISTER_DIG_T1 0x88

#define BMx280_REGISTER_DIG_T2 0x8A

#define BMx280_REGISTER_DIG_T3 0x8C



#define BMx280_REGISTER_DIG_P1 0x8E

#define BMx280_REGISTER_DIG_P2 0x90

#define BMx280_REGISTER_DIG_P3 0x92

#define BMx280_REGISTER_DIG_P4 0x94

#define BMx280_REGISTER_DIG_P5 0x96

#define BMx280_REGISTER_DIG_P6 0x98

#define BMx280_REGISTER_DIG_P7 0x9A

#define BMx280_REGISTER_DIG_P8 0x9C

#define BMx280_REGISTER_DIG_P9 0x9E



#define BMx280_REGISTER_DIG_H1 0xA1

#define BMx280_REGISTER_DIG_H2 0xE1

#define BMx280_REGISTER_DIG_H3 0xE3

#define BMx280_REGISTER_DIG_H4 0xE4

#define BMx280_REGISTER_DIG_H5 0xE5

#define BMx280_REGISTER_DIG_H6 0xE7



#define BMx280_REGISTER_CHIPID 0xD0

#define BMx280_REGISTER_VERSION 0xD1

#define BMx280_REGISTER_SOFTRESET 0xE0



#define BMx280_REGISTER_CAL26 0xE1



#define BMx280_REGISTER_CONTROLHUMID 0xF2

#define BMx280_REGISTER_STATUS 0xF3

#define BMx280_REGISTER_CONTROL 0xF4

#define BMx280_REGISTER_CONFIG 0xF5

#define BMx280_REGISTER_PRESSUREDATA 0xF7

#define BMx280_REGISTER_TEMPDATA 0xFA

#define BMx280_REGISTER_HUMIDDATA 0xFD



#define BME280_CONTROL_SETTING_HUMIDITY 0x02



#define BME280_TEMP_PRESS_CALIB_DATA_ADDR 0x88

#define BME280_HUMIDITY_CALIB_DATA_ADDR 0xE1

#define BME280_DATA_ADDR 0xF7



#define BME280_TEMP_PRESS_CALIB_DATA_LEN 26

#define BME280_HUMIDITY_CALIB_DATA_LEN 7

#define BME280_P_T_H_DATA_LEN 8



typedef struct

{

  uint16_t dig_T1;

  int16_t dig_T2;

  int16_t dig_T3;



  uint16_t dig_P1;

  int16_t dig_P2;

  int16_t dig_P3;

  int16_t dig_P4;

  int16_t dig_P5;

  int16_t dig_P6;

  int16_t dig_P7;

  int16_t dig_P8;

  int16_t dig_P9;



  uint8_t dig_H1;

  int16_t dig_H2;

  uint8_t dig_H3;

  int16_t dig_H4;

  int16_t dig_H5;

  int8_t dig_H6;

  int32_t t_fine;

} bme280_calib_data;



struct bme280_uncomp_data {



 uint32_t pressure;



 uint32_t temperature;



 uint32_t humidity;

};



enum BMx_ChipId {

  Unknown_DEVICE = 0,

  BMP280_DEVICE_SAMPLE1 = 0x56,

  BMP280_DEVICE_SAMPLE2 = 0x57,

  BMP280_DEVICE = 0x58,

  BME280_DEVICE = 0x60

};



enum BMx_state {

  BMx_Uninitialized = 0,

  BMx_Initialized,

  BMx_Wait_for_samples,

  BMx_New_values,

  BMx_Values_read

};



struct P028_sensordata {

  P028_sensordata() :

    last_hum_val(0.0),

    last_press_val(0.0),

    last_temp_val(0.0),

    last_dew_temp_val(0.0),

    last_measurement(0),

    sensorID(Unknown_DEVICE),

    i2cAddress(0),

    state(BMx_Uninitialized) {}



    byte get_config_settings() const {

      switch (sensorID) {

        case BMP280_DEVICE_SAMPLE1:

        case BMP280_DEVICE_SAMPLE2:

        case BMP280_DEVICE: return 0x28;

        case BME280_DEVICE: return 0x28;

        default: return 0;

      }

    }



    byte get_control_settings() const {

      switch (sensorID) {

        case BMP280_DEVICE_SAMPLE1:

        case BMP280_DEVICE_SAMPLE2:

        case BMP280_DEVICE: return 0x93;

        case BME280_DEVICE: return 0x93;

        default: return 0;

      }

    }



    String getFullDeviceName() const {

      String devicename = getDeviceName();

      if (sensorID == BMP280_DEVICE_SAMPLE1 ||

          sensorID == BMP280_DEVICE_SAMPLE2)

      {

        devicename += " sample";

      }

      return devicename;

    }



    String getDeviceName() const {

      switch (sensorID) {

        case BMP280_DEVICE_SAMPLE1:

        case BMP280_DEVICE_SAMPLE2:

        case BMP280_DEVICE: return PLUGIN_028_BMP280_DEVICE;

        case BME280_DEVICE: return PLUGIN_028_BME280_DEVICE;

        default: return "Unknown";

      }

    }



    boolean hasHumidity() const {

      switch (sensorID) {

        case BMP280_DEVICE_SAMPLE1:

        case BMP280_DEVICE_SAMPLE2:

        case BMP280_DEVICE: return false;

        case BME280_DEVICE: return true;

        default: return false;

      }

    }



    bool initialized() const {

      return state != BMx_Uninitialized;

    }



    void setUninitialized() {

      state = BMx_Uninitialized;

    }



  bme280_uncomp_data uncompensated;

  bme280_calib_data calib;

  float last_hum_val;

  float last_press_val;

  float last_temp_val;

  float last_dew_temp_val;

  unsigned long last_measurement;

  BMx_ChipId sensorID;

  uint8_t i2cAddress;

  unsigned long moment_next_step;

  BMx_state state;

};



std::map<uint8_t, P028_sensordata> P028_sensors;



int Plugin_28_i2c_addresses[2] = { 0x76, 0x77 };



uint8_t Plugin_028_i2c_addr(struct EventStruct *event) {

  uint8_t i2cAddress = (uint8_t)Settings.TaskDevicePluginConfig[event->TaskIndex][0];

  if (i2cAddress != Plugin_28_i2c_addresses[0] && i2cAddress != Plugin_28_i2c_addresses[1]) {



    i2cAddress = Plugin_28_i2c_addresses[0];

  }

  if (P028_sensors.count(i2cAddress) == 0) {

    P028_sensors[i2cAddress] = P028_sensordata();

  }

  return i2cAddress;

}



boolean Plugin_028(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_028;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM_BARO;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_028);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_028));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_028));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_028));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        const uint8_t i2cAddress = Plugin_028_i2c_addr(event);

        P028_sensordata& sensor = P028_sensors[i2cAddress];

        addFormSelectorI2C(F("plugin_028_bme280_i2c"), 2, Plugin_28_i2c_addresses, i2cAddress);

        if (sensor.sensorID != Unknown_DEVICE) {

          String detectedString = F("Detected: ");

          detectedString += sensor.getFullDeviceName();

          addUnit(detectedString);

        }

        addFormNote(F("SDO Low=0x76, High=0x77"));



        addFormNumericBox(F("Altitude"), F("plugin_028_bme280_elev"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        addUnit(F("m"));



        addFormNumericBox(F("Temperature offset"), F("plugin_028_bme280_tempoffset"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);

        addUnit(F("x 0.1C"));

        String offsetNote = F("Offset in units of 0.1 degree Celcius");

        if (sensor.hasHumidity()) {

          offsetNote += F(" (also correct humidity)");

        }

        addFormNote(offsetNote);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        const uint8_t i2cAddress = getFormItemInt(F("plugin_028_bme280_i2c"));

        Plugin_028_check(i2cAddress);

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = i2cAddress;

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_028_bme280_elev"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_028_bme280_tempoffset"));

        success = true;

        break;

      }

    case PLUGIN_ONCE_A_SECOND:

      {

        const uint8_t i2cAddress = Plugin_028_i2c_addr(event);

        const float tempOffset = Settings.TaskDevicePluginConfig[event->TaskIndex][2] / 10.0;

        if (Plugin_028_update_measurements(i2cAddress, tempOffset, event->TaskIndex)) {



          schedule_task_device_timer(event->TaskIndex, millis() + 10);

        }

        break;

      }



    case PLUGIN_READ:

      {

        const uint8_t i2cAddress = Plugin_028_i2c_addr(event);

        P028_sensordata& sensor = P028_sensors[i2cAddress];

        if (sensor.state != BMx_New_values) {

          success = false;

          break;

        }

        sensor.state = BMx_Values_read;

        if (!sensor.hasHumidity()) {



          event->sensorType = SENSOR_TYPE_TEMP_EMPTY_BARO;

        }

        UserVar[event->BaseVarIndex] = sensor.last_temp_val;

        UserVar[event->BaseVarIndex + 1] = sensor.last_hum_val;

        const int elev = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        if (elev) {

           UserVar[event->BaseVarIndex + 2] = Plugin_028_pressureElevation(sensor.last_press_val, elev);

        } else {

           UserVar[event->BaseVarIndex + 2] = sensor.last_press_val;

        }

        if (loglevelActiveFor(LOG_LEVEL_INFO)) {

          String log;

          log.reserve(40);

          log = sensor.getDeviceName();

          log += F(" : Address: 0x");

          log += String(i2cAddress,HEX);

          addLog(LOG_LEVEL_INFO, log);

          log = sensor.getDeviceName();

          log += F(" : Temperature: ");

          log += UserVar[event->BaseVarIndex];

          addLog(LOG_LEVEL_INFO, log);

          if (sensor.hasHumidity()) {

            log = sensor.getDeviceName();

            log += F(" : Humidity: ");

            log += UserVar[event->BaseVarIndex + 1];

            addLog(LOG_LEVEL_INFO, log);

          }

          log = sensor.getDeviceName();

          log += F(" : Barometric Pressure: ");

          log += UserVar[event->BaseVarIndex + 2];

          addLog(LOG_LEVEL_INFO, log);

        }

        success = true;

        break;

      }

      case PLUGIN_EXIT:

      {

        const uint8_t i2cAddress = Plugin_028_i2c_addr(event);

        P028_sensors.erase(i2cAddress);

        break;

      }

  }

  return success;

}







bool Plugin_028_update_measurements(const uint8_t i2cAddress, float tempOffset, unsigned long task_index) {

  P028_sensordata& sensor = P028_sensors[i2cAddress];

  const unsigned long current_time = millis();

  Plugin_028_check(i2cAddress);

  if (!sensor.initialized()) {

    if (!Plugin_028_begin(i2cAddress)) {

      return false;

    }

    sensor.state = BMx_Initialized;

    sensor.last_measurement = 0;

  }

  if (sensor.state != BMx_Wait_for_samples) {

    if (sensor.last_measurement != 0 &&

        !timeOutReached(sensor.last_measurement + (Settings.TaskDeviceTimer[task_index] * 1000))) {



      return false;

    }



    sensor.last_measurement = current_time;



    I2C_write8_reg(i2cAddress, BMx280_REGISTER_CONTROL, 0x00);

    if (sensor.hasHumidity()) {

      I2C_write8_reg(i2cAddress, BMx280_REGISTER_CONTROLHUMID, BME280_CONTROL_SETTING_HUMIDITY);

    }

    I2C_write8_reg(i2cAddress, BMx280_REGISTER_CONFIG, sensor.get_config_settings());

    I2C_write8_reg(i2cAddress, BMx280_REGISTER_CONTROL, sensor.get_control_settings());

    sensor.state = BMx_Wait_for_samples;

    return false;

  }
# 775 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
  if (!timeOutReached(sensor.last_measurement + 1587)) {

    return false;

  }

  if (!Plugin_028_readUncompensatedData(i2cAddress)) {

    return false;

  }



  I2C_write8_reg(i2cAddress, BMx280_REGISTER_CONTROL, 0x00);



  sensor.last_measurement = current_time;

  sensor.state = BMx_New_values;

  sensor.last_temp_val = Plugin_028_readTemperature(i2cAddress);

  sensor.last_press_val = ((float)Plugin_028_readPressure(i2cAddress)) / 100;

  sensor.last_hum_val = ((float)Plugin_028_readHumidity(i2cAddress));





  String log;

  if (loglevelActiveFor(LOG_LEVEL_INFO)) {

    log.reserve(120);

    log = sensor.getDeviceName();

    log += F(":");

  }

  boolean logAdded = false;

  if (sensor.hasHumidity()) {





    sensor.last_dew_temp_val = compute_dew_point_temp(sensor.last_temp_val + (tempOffset / 2.0), sensor.last_hum_val);

  } else {



    sensor.last_dew_temp_val = sensor.last_temp_val;

  }

  if (tempOffset > 0.1 || tempOffset < -0.1) {



    if (loglevelActiveFor(LOG_LEVEL_INFO)) {

      log += F(" Apply temp offset ");

      log += tempOffset;

      log += F("C");

    }

    if (sensor.hasHumidity()) {

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {

        log += F(" humidity ");

        log += sensor.last_hum_val;

      }

      sensor.last_hum_val = compute_humidity_from_dewpoint(sensor.last_temp_val + tempOffset, sensor.last_dew_temp_val);

      if (loglevelActiveFor(LOG_LEVEL_INFO)) {

        log += F("% => ");

        log += sensor.last_hum_val;

        log += F("%");

      }

    } else {

      sensor.last_hum_val = 0.0;

    }

    if (loglevelActiveFor(LOG_LEVEL_INFO)) {

      log += F(" temperature ");

      log += sensor.last_temp_val;

    }

    sensor.last_temp_val = sensor.last_temp_val + tempOffset;

    if (loglevelActiveFor(LOG_LEVEL_INFO)) {

      log += F("C => ");

      log += sensor.last_temp_val;

      log += F("C");

      logAdded = true;

    }

  }

  if (sensor.hasHumidity()) {

    if (loglevelActiveFor(LOG_LEVEL_INFO)) {

      log += F(" dew point ");

      log += sensor.last_dew_temp_val;

      log += F("C");

      logAdded = true;

    }

  }

  if (logAdded && loglevelActiveFor(LOG_LEVEL_INFO))

    addLog(LOG_LEVEL_INFO, log);

  return true;

}
# 937 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
bool Plugin_028_check(uint8_t i2cAddress) {

  bool wire_status = false;

  const uint8_t chip_id = I2C_read8_reg(i2cAddress, BMx280_REGISTER_CHIPID, &wire_status);

  P028_sensordata& sensor = P028_sensors[i2cAddress];

  if (!wire_status) sensor.setUninitialized();

  switch (chip_id) {

    case BMP280_DEVICE_SAMPLE1:

    case BMP280_DEVICE_SAMPLE2:

    case BMP280_DEVICE:

    case BME280_DEVICE: {

      if (wire_status) {



        if (sensor.sensorID != chip_id) {

          sensor.sensorID = static_cast<BMx_ChipId>(chip_id);

          sensor.setUninitialized();

          String log = F("BMx280 : Detected ");

          log += sensor.getFullDeviceName();

          addLog(LOG_LEVEL_INFO, log);

        }

      } else {

        sensor.sensorID = Unknown_DEVICE;

      }

      break;

    }

    default:

      sensor.sensorID = Unknown_DEVICE;

      break;

  }

  if (sensor.sensorID == Unknown_DEVICE) {

    String log = F("BMx280 : Unable to detect chip ID");

    addLog(LOG_LEVEL_INFO, log);

    return false;

  }

  return wire_status;

}
# 1015 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
bool Plugin_028_begin(uint8_t i2cAddress) {

  if (! Plugin_028_check(i2cAddress))

    return false;



  I2C_write8_reg(i2cAddress, BMx280_REGISTER_SOFTRESET, 0xB6);

  delay(2);

  Plugin_028_readCoefficients(i2cAddress);



  return true;

}
# 1045 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
void Plugin_028_readCoefficients(uint8_t i2cAddress)

{

  P028_sensordata& sensor = P028_sensors[i2cAddress];

  sensor.calib.dig_T1 = I2C_read16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_T1);

  sensor.calib.dig_T2 = I2C_readS16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_T2);

  sensor.calib.dig_T3 = I2C_readS16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_T3);



  sensor.calib.dig_P1 = I2C_read16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_P1);

  sensor.calib.dig_P2 = I2C_readS16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_P2);

  sensor.calib.dig_P3 = I2C_readS16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_P3);

  sensor.calib.dig_P4 = I2C_readS16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_P4);

  sensor.calib.dig_P5 = I2C_readS16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_P5);

  sensor.calib.dig_P6 = I2C_readS16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_P6);

  sensor.calib.dig_P7 = I2C_readS16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_P7);

  sensor.calib.dig_P8 = I2C_readS16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_P8);

  sensor.calib.dig_P9 = I2C_readS16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_P9);



  if (sensor.hasHumidity()) {

    sensor.calib.dig_H1 = I2C_read8_reg(i2cAddress, BMx280_REGISTER_DIG_H1);

    sensor.calib.dig_H2 = I2C_readS16_LE_reg(i2cAddress, BMx280_REGISTER_DIG_H2);

    sensor.calib.dig_H3 = I2C_read8_reg(i2cAddress, BMx280_REGISTER_DIG_H3);

    sensor.calib.dig_H4 = (I2C_read8_reg(i2cAddress, BMx280_REGISTER_DIG_H4) << 4) | (I2C_read8_reg(i2cAddress, BMx280_REGISTER_DIG_H4 + 1) & 0xF);

    sensor.calib.dig_H5 = (I2C_read8_reg(i2cAddress, BMx280_REGISTER_DIG_H5 + 1) << 4) | (I2C_read8_reg(i2cAddress, BMx280_REGISTER_DIG_H5) >> 4);

    sensor.calib.dig_H6 = (int8_t)I2C_read8_reg(i2cAddress, BMx280_REGISTER_DIG_H6);

  }

}



bool Plugin_028_readUncompensatedData(uint8_t i2cAddress) {





  if (I2C_read8_reg(i2cAddress, BMx280_REGISTER_STATUS) & 0x08)

    return false;



  I2Cdata_bytes BME280_data(BME280_P_T_H_DATA_LEN, BME280_DATA_ADDR);

  bool allDataRead = I2C_read_bytes(i2cAddress, BME280_data);

  if (!allDataRead) {

    return false;

  }



 uint32_t data_xlsb;

 uint32_t data_lsb;

 uint32_t data_msb;



  P028_sensordata& sensor = P028_sensors[i2cAddress];





 data_msb = (uint32_t)BME280_data[BME280_DATA_ADDR + 0] << 12;

 data_lsb = (uint32_t)BME280_data[BME280_DATA_ADDR + 1] << 4;

 data_xlsb = (uint32_t)BME280_data[BME280_DATA_ADDR + 2] >> 4;

 sensor.uncompensated.pressure = data_msb | data_lsb | data_xlsb;





 data_msb = (uint32_t)BME280_data[BME280_DATA_ADDR + 3] << 12;

 data_lsb = (uint32_t)BME280_data[BME280_DATA_ADDR + 4] << 4;

 data_xlsb = (uint32_t)BME280_data[BME280_DATA_ADDR + 5] >> 4;

 sensor.uncompensated.temperature = data_msb | data_lsb | data_xlsb;





 data_lsb = (uint32_t)BME280_data[BME280_DATA_ADDR + 6] << 8;

 data_msb = (uint32_t)BME280_data[BME280_DATA_ADDR + 7];

 sensor.uncompensated.humidity = data_msb | data_lsb;

  return true;

}
# 1179 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
float Plugin_028_readTemperature(uint8_t i2cAddress)

{

  P028_sensordata& sensor = P028_sensors[i2cAddress];

  int32_t var1, var2;

  int32_t adc_T = sensor.uncompensated.temperature;

  var1 = ((((adc_T >> 3) - ((int32_t)sensor.calib.dig_T1 << 1))) *

           ((int32_t)sensor.calib.dig_T2)) >> 11;



  var2 = (((((adc_T >> 4) - ((int32_t)sensor.calib.dig_T1)) *

             ((adc_T >> 4) - ((int32_t)sensor.calib.dig_T1))) >> 12) *

           ((int32_t)sensor.calib.dig_T3)) >> 14;



  sensor.calib.t_fine = var1 + var2;



  float T = (sensor.calib.t_fine * 5 + 128) >> 8;

  return T / 100;

}
# 1221 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
float Plugin_028_readPressure(uint8_t i2cAddress)

{

  P028_sensordata& sensor = P028_sensors[i2cAddress];

  int64_t var1, var2, p;

  int32_t adc_P = sensor.uncompensated.pressure;



  var1 = ((int64_t)sensor.calib.t_fine) - 128000;

  var2 = var1 * var1 * (int64_t)sensor.calib.dig_P6;

  var2 = var2 + ((var1 * (int64_t)sensor.calib.dig_P5) << 17);

  var2 = var2 + (((int64_t)sensor.calib.dig_P4) << 35);

  var1 = ((var1 * var1 * (int64_t)sensor.calib.dig_P3) >> 8) +

         ((var1 * (int64_t)sensor.calib.dig_P2) << 12);

  var1 = (((((int64_t)1) << 47) + var1)) * ((int64_t)sensor.calib.dig_P1) >> 33;



  if (var1 == 0) {

    return 0;

  }

  p = 1048576 - adc_P;

  p = (((p << 31) - var2) * 3125) / var1;

  var1 = (((int64_t)sensor.calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;

  var2 = (((int64_t)sensor.calib.dig_P8) * p) >> 19;



  p = ((p + var1 + var2) >> 8) + (((int64_t)sensor.calib.dig_P7) << 4);

  return (float)p / 256;

}
# 1279 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
float Plugin_028_readHumidity(uint8_t i2cAddress)

{

  P028_sensordata& sensor = P028_sensors[i2cAddress];

  if (!sensor.hasHumidity()) {



    return 0.0;

  }

  int32_t adc_H = sensor.uncompensated.humidity;



  int32_t v_x1_u32r;



  v_x1_u32r = (sensor.calib.t_fine - ((int32_t)76800));



  v_x1_u32r = (((((adc_H << 14) - (((int32_t)sensor.calib.dig_H4) << 20) -

                  (((int32_t)sensor.calib.dig_H5) * v_x1_u32r)) + ((int32_t)16384)) >> 15) *

               (((((((v_x1_u32r * ((int32_t)sensor.calib.dig_H6)) >> 10) *

                    (((v_x1_u32r * ((int32_t)sensor.calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +

                  ((int32_t)2097152)) * ((int32_t)sensor.calib.dig_H2) + 8192) >> 14));



  v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) *

                             ((int32_t)sensor.calib.dig_H1)) >> 4));



  v_x1_u32r = (v_x1_u32r < 0) ? 0 : v_x1_u32r;

  v_x1_u32r = (v_x1_u32r > 419430400) ? 419430400 : v_x1_u32r;

  float h = (v_x1_u32r >> 12);

  return h / 1024.0;

}
# 1347 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
float Plugin_028_readAltitude(uint8_t i2cAddress, float seaLevel)

{
# 1365 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
  float atmospheric = Plugin_028_readPressure(i2cAddress) / 100.0F;

  return 44330.0 * (1.0 - pow(atmospheric / seaLevel, 0.1903));

}
# 1379 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P028_BME280.ino"
float Plugin_028_pressureElevation(float atmospheric, int altitude) {

  return atmospheric / pow(1.0 - (altitude/44330.0), 5.255);

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P029_Output.ino"
#ifdef USES_P029
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P029_Output.ino"
#define PLUGIN_029 

#define PLUGIN_ID_029 29

#define PLUGIN_NAME_029 "Output - Domoticz MQTT Helper"

#define PLUGIN_VALUENAME1_029 "Output"

boolean Plugin_029(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_029;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_029);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_029));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {



        byte controllerNr = 0;

          for (byte i=0; i < CONTROLLER_MAX; i++)

          {



            if (Settings.Protocol[i] == 2) { controllerNr = i; }

          }



        addHtml(F("<TR><TD>IDX:<TD>"));

        String id = F("TDID");

        id += controllerNr + 1;

        addNumericBox(id, Settings.TaskDeviceID[controllerNr][event->TaskIndex], 0, DOMOTICZ_MAX_IDX);

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P030_BMP280.ino"
#ifdef USES_P030
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P030_BMP280.ino"
#define PLUGIN_030 

#define PLUGIN_ID_030 30

#define PLUGIN_NAME_030 "Environment - BMP280"

#define PLUGIN_VALUENAME1_030 "Temperature"

#define PLUGIN_VALUENAME2_030 "Pressure"



enum

{

  BMP280_REGISTER_DIG_T1 = 0x88,

  BMP280_REGISTER_DIG_T2 = 0x8A,

  BMP280_REGISTER_DIG_T3 = 0x8C,



  BMP280_REGISTER_DIG_P1 = 0x8E,

  BMP280_REGISTER_DIG_P2 = 0x90,

  BMP280_REGISTER_DIG_P3 = 0x92,

  BMP280_REGISTER_DIG_P4 = 0x94,

  BMP280_REGISTER_DIG_P5 = 0x96,

  BMP280_REGISTER_DIG_P6 = 0x98,

  BMP280_REGISTER_DIG_P7 = 0x9A,

  BMP280_REGISTER_DIG_P8 = 0x9C,

  BMP280_REGISTER_DIG_P9 = 0x9E,



  BMP280_REGISTER_CHIPID = 0xD0,

  BMP280_REGISTER_VERSION = 0xD1,

  BMP280_REGISTER_SOFTRESET = 0xE0,



  BMP280_REGISTER_CAL26 = 0xE1,



  BMP280_REGISTER_CONTROL = 0xF4,

  BMP280_REGISTER_CONFIG = 0xF5,

  BMP280_REGISTER_PRESSUREDATA = 0xF7,

  BMP280_REGISTER_TEMPDATA = 0xFA,



  BMP280_CONTROL_SETTING = 0x57,

  BMP280_CONFIG_SETTING = 0xE0,

};



typedef struct

{

  uint16_t dig_T1;

  int16_t dig_T2;

  int16_t dig_T3;



  uint16_t dig_P1;

  int16_t dig_P2;

  int16_t dig_P3;

  int16_t dig_P4;

  int16_t dig_P5;

  int16_t dig_P6;

  int16_t dig_P7;

  int16_t dig_P8;

  int16_t dig_P9;

} bmp280_calib_data;



bmp280_calib_data _bmp280_calib[2];



uint8_t bmp280_i2caddr;

int32_t bmp280_sensorID;

int32_t bmp280_t_fine;



boolean Plugin_030_init[2] = {false, false};



boolean Plugin_030(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_030;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_BARO;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_030);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_030));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_030));

        break;

      }

    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        int optionValues[2] = { 0x76, 0x77 };

        addFormSelectorI2C(F("plugin_030_bmp280_i2c"), 2, optionValues, choice);

        addFormNote(F("SDO Low=0x76, High=0x77"));



        addFormNumericBox(F("Altitude"), F("plugin_030_bmp280_elev"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        addUnit(F("m"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_030_bmp280_i2c"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_030_bmp280_elev"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        uint8_t idx = Settings.TaskDevicePluginConfig[event->TaskIndex][0] & 0x1;

        Plugin_030_init[idx] &= Plugin_030_check(Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        Plugin_030_init[idx] &= (I2C_read8_reg(bmp280_i2caddr, BMP280_REGISTER_CONTROL) == BMP280_CONTROL_SETTING);



        if (!Plugin_030_init[idx])

        {

          Plugin_030_init[idx] = Plugin_030_begin(Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

          delay(65);

        }



        if (Plugin_030_init[idx])

        {

          UserVar[event->BaseVarIndex] = Plugin_030_readTemperature(idx);

          int elev = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

          if (elev)

          {

             UserVar[event->BaseVarIndex + 1] = Plugin_030_pressureElevation((float)Plugin_030_readPressure(idx) / 100, elev);

          } else {

             UserVar[event->BaseVarIndex + 1] = ((float)Plugin_030_readPressure(idx)) / 100;

          }



          String log = F("BMP280  : Address: 0x");

          log += String(bmp280_i2caddr,HEX);

          addLog(LOG_LEVEL_INFO, log);

          log = F("BMP280  : Temperature: ");

          log += UserVar[event->BaseVarIndex];

          addLog(LOG_LEVEL_INFO, log);

          log = F("BMP280  : Barometric Pressure: ");

          log += UserVar[event->BaseVarIndex + 1];

          addLog(LOG_LEVEL_INFO, log);
# 369 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P030_BMP280.ino"
          success = true;

        }

        break;

      }



  }

  return success;

}
# 393 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P030_BMP280.ino"
bool Plugin_030_check(uint8_t a) {

  bmp280_i2caddr = a?a:0x76;

  bool wire_status = false;

  if (I2C_read8_reg(bmp280_i2caddr, BMP280_REGISTER_CHIPID, &wire_status) != 0x58) {

      return false;

  } else {

      return wire_status;

  }

}
# 419 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P030_BMP280.ino"
bool Plugin_030_begin(uint8_t a) {

  if (! Plugin_030_check(a))

    return false;



  Plugin_030_readCoefficients(a & 0x1);

  I2C_write8_reg(bmp280_i2caddr, BMP280_REGISTER_CONTROL, BMP280_CONTROL_SETTING);

  I2C_write8_reg(bmp280_i2caddr, BMP280_REGISTER_CONFIG, BMP280_CONFIG_SETTING);

  return true;

}
# 445 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P030_BMP280.ino"
void Plugin_030_readCoefficients(uint8_t idx)

{

  _bmp280_calib[idx].dig_T1 = I2C_read16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_T1);

  _bmp280_calib[idx].dig_T2 = I2C_readS16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_T2);

  _bmp280_calib[idx].dig_T3 = I2C_readS16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_T3);



  _bmp280_calib[idx].dig_P1 = I2C_read16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_P1);

  _bmp280_calib[idx].dig_P2 = I2C_readS16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_P2);

  _bmp280_calib[idx].dig_P3 = I2C_readS16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_P3);

  _bmp280_calib[idx].dig_P4 = I2C_readS16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_P4);

  _bmp280_calib[idx].dig_P5 = I2C_readS16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_P5);

  _bmp280_calib[idx].dig_P6 = I2C_readS16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_P6);

  _bmp280_calib[idx].dig_P7 = I2C_readS16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_P7);

  _bmp280_calib[idx].dig_P8 = I2C_readS16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_P8);

  _bmp280_calib[idx].dig_P9 = I2C_readS16_LE_reg(bmp280_i2caddr, BMP280_REGISTER_DIG_P9);

}
# 485 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P030_BMP280.ino"
float Plugin_030_readTemperature(uint8_t idx)

{

  int32_t var1, var2;



  int32_t adc_T = I2C_read24_reg(bmp280_i2caddr, BMP280_REGISTER_TEMPDATA);

  adc_T >>= 4;



  var1 = ((((adc_T >> 3) - ((int32_t)_bmp280_calib[idx].dig_T1 << 1))) *

           ((int32_t)_bmp280_calib[idx].dig_T2)) >> 11;



  var2 = (((((adc_T >> 4) - ((int32_t)_bmp280_calib[idx].dig_T1)) *

             ((adc_T >> 4) - ((int32_t)_bmp280_calib[idx].dig_T1))) >> 12) *

           ((int32_t)_bmp280_calib[idx].dig_T3)) >> 14;



  bmp280_t_fine = var1 + var2;



  float T = (bmp280_t_fine * 5 + 128) >> 8;

  return T / 100;

}
# 531 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P030_BMP280.ino"
float Plugin_030_readPressure(uint8_t idx) {

  int64_t var1, var2, p;



  int32_t adc_P = I2C_read24_reg(bmp280_i2caddr, BMP280_REGISTER_PRESSUREDATA);

  adc_P >>= 4;



  var1 = ((int64_t)bmp280_t_fine) - 128000;

  var2 = var1 * var1 * (int64_t)_bmp280_calib[idx].dig_P6;

  var2 = var2 + ((var1 * (int64_t)_bmp280_calib[idx].dig_P5) << 17);

  var2 = var2 + (((int64_t)_bmp280_calib[idx].dig_P4) << 35);

  var1 = ((var1 * var1 * (int64_t)_bmp280_calib[idx].dig_P3) >> 8) +

         ((var1 * (int64_t)_bmp280_calib[idx].dig_P2) << 12);

  var1 = (((((int64_t)1) << 47) + var1)) * ((int64_t)_bmp280_calib[idx].dig_P1) >> 33;



  if (var1 == 0) {

    return 0;

  }

  p = 1048576 - adc_P;

  p = (((p << 31) - var2) * 3125) / var1;

  var1 = (((int64_t)_bmp280_calib[idx].dig_P9) * (p >> 13) * (p >> 13)) >> 25;

  var2 = (((int64_t)_bmp280_calib[idx].dig_P8) * p) >> 19;



  p = ((p + var1 + var2) >> 8) + (((int64_t)_bmp280_calib[idx].dig_P7) << 4);

  return (float)p / 256;

}
# 595 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P030_BMP280.ino"
float Plugin_030_readAltitude(float seaLevel)

{

  float atmospheric = Plugin_030_readPressure(bmp280_i2caddr & 0x01) / 100.0F;

  return 44330.0 * (1.0 - pow(atmospheric / seaLevel, 0.1903));

}
# 613 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P030_BMP280.ino"
float Plugin_030_pressureElevation(float atmospheric, int altitude) {

  return atmospheric / pow(1.0 - (altitude/44330.0), 5.255);

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P031_SHT1X.ino"
#ifdef USES_P031
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P031_SHT1X.ino"
#define PLUGIN_031 

#define PLUGIN_ID_031 31

#define PLUGIN_NAME_031 "Environment - SHT1X"

#define PLUGIN_VALUENAME1_031 "Temperature"

#define PLUGIN_VALUENAME2_031 "Humidity"



boolean Plugin_031_init = false;

byte Plugin_031_DATA_Pin = 0;

byte Plugin_031_CLOCK_Pin = 0;

int input_mode;



enum {

  SHT1X_CMD_MEASURE_TEMP = B00000011,

  SHT1X_CMD_MEASURE_RH = B00000101,

  SHT1X_CMD_READ_STATUS = B00000111,

  SHT1X_CMD_SOFT_RESET = B00011110

};



boolean Plugin_031(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_031;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = true;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_031);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_031));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_031));

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_031_init = true;

        Plugin_031_DATA_Pin = Settings.TaskDevicePin1[event->TaskIndex];

        Plugin_031_CLOCK_Pin = Settings.TaskDevicePin2[event->TaskIndex];

        if (Settings.TaskDevicePin1PullUp[event->TaskIndex]) {

          input_mode = INPUT_PULLUP;

          String log = F("SHT1X: Setting PullUp on pin ");

          log += String(Plugin_031_DATA_Pin);

          addLog(LOG_LEVEL_DEBUG, log);

        }

        else {

          input_mode = INPUT;

        }

        pinMode(Plugin_031_DATA_Pin, input_mode);

        pinMode(Plugin_031_CLOCK_Pin, OUTPUT);

        Plugin_031_reset();

        byte status = Plugin_031_readStatus();

        String log = F("SHT1X : Status byte: ");

        log += String(status, HEX);

        log += F(" - resolution: ");

        log += (status & 1 ? F("low") : F("high"));

        log += F(" reload from OTP: ");

        log += ((status >> 1) & 1 ? F("yes") : F("no"));

        log += F(", heater: ");

        log += ((status >> 2) & 1 ? F("on") : F("off"));

        addLog(LOG_LEVEL_DEBUG, log);

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (!Plugin_031_init) {

          addLog(LOG_LEVEL_ERROR, F("SHT1X : not yet initialized!"));

          break;

        }

        UserVar[event->BaseVarIndex] = Plugin_031_readTemperature();

        UserVar[event->BaseVarIndex+1] = Plugin_031_readRelHumidity(UserVar[event->BaseVarIndex]);

        success = true;

        break;

      }

  }

  return success;

}



float Plugin_031_readTemperature()

{

  float tempRaw, tempC;



  Plugin_031_sendCommand(SHT1X_CMD_MEASURE_TEMP);

  Plugin_031_awaitResult();

  tempRaw = Plugin_031_readData(16);





  const float d1 = -39.7;

  const float d2 = 0.01;



  tempC = d1 + (tempRaw * d2);



  String log = F("SHT1X : Read temperature (raw): ");

  log += String(tempRaw);

  log += F(" (Celcius): ");

  log += String(tempC);

  addLog(LOG_LEVEL_DEBUG, log);



  return tempC;

}



float Plugin_031_readRelHumidity(float tempC)

{

  float raw, rhLinear, rhTrue;



  Plugin_031_sendCommand(SHT1X_CMD_MEASURE_RH);

  Plugin_031_awaitResult();

  raw = Plugin_031_readData(16);





  const float c1 = -2.0468;

  const float c2 = 0.0367;

  const float c3 = -1.5955E-6;

  const float t1 = 0.01;

  const float t2 = 0.00008;



  rhLinear = c1 + c2 * raw + c3 * raw * raw;

  rhTrue = (tempC - 25) * (t1 + t2 * raw) + rhLinear;



  String log = F("SHT1X : Read humidity (raw): ");

  log += String(raw);

  log += F(" (Linear): ");

  log += String(rhLinear);

  log += F(" (True): ");

  log += String(rhTrue);

  addLog(LOG_LEVEL_DEBUG, log);



  return rhTrue;

}





void Plugin_031_reset()

{

  delay(11);

  for (int i=0; i<9; i++) {

    digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

    digitalWrite(Plugin_031_CLOCK_Pin, LOW);

  }

  Plugin_031_sendCommand(SHT1X_CMD_SOFT_RESET);

  delay(11);

}



byte Plugin_031_readStatus()

{

  Plugin_031_sendCommand(SHT1X_CMD_READ_STATUS);

  return Plugin_031_readData(8);

}



void Plugin_031_sendCommand(const byte cmd)

{

  pinMode(Plugin_031_DATA_Pin, OUTPUT);





  digitalWrite(Plugin_031_DATA_Pin, HIGH);

  digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

  digitalWrite(Plugin_031_DATA_Pin, LOW);

  digitalWrite(Plugin_031_CLOCK_Pin, LOW);

  digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

  digitalWrite(Plugin_031_DATA_Pin, HIGH);

  digitalWrite(Plugin_031_CLOCK_Pin, LOW);





  shiftOut(Plugin_031_DATA_Pin, Plugin_031_CLOCK_Pin, MSBFIRST, cmd);





  bool ackerror = false;

  digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

  pinMode(Plugin_031_DATA_Pin, input_mode);

  if (digitalRead(Plugin_031_DATA_Pin) != LOW) ackerror = true;

  digitalWrite(Plugin_031_CLOCK_Pin, LOW);



  if (cmd == SHT1X_CMD_MEASURE_TEMP || cmd == SHT1X_CMD_MEASURE_RH) {

    delayMicroseconds(1);

    if (digitalRead(Plugin_031_DATA_Pin) != HIGH) ackerror = true;

  }



  if (ackerror) {

    addLog(LOG_LEVEL_ERROR, F("SHT1X : Sensor did not ACK command"));

  }

}



void Plugin_031_awaitResult()

{



  for (int i=0; i<16; i++) {

    if (digitalRead(Plugin_031_DATA_Pin) == LOW) return;

    delay(20);

  }

  if (digitalRead(Plugin_031_DATA_Pin) != LOW) {

    addLog(LOG_LEVEL_ERROR, F("SHT1X : Data not ready"));

  }

}



int Plugin_031_readData(const int bits)

{

  int val = 0;



  if (bits == 16) {



    val = shiftIn(Plugin_031_DATA_Pin, Plugin_031_CLOCK_Pin, 8);

    val <<= 8;





    pinMode(Plugin_031_DATA_Pin, OUTPUT);

    digitalWrite(Plugin_031_DATA_Pin, LOW);

    digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

    digitalWrite(Plugin_031_CLOCK_Pin, LOW);

    pinMode(Plugin_031_DATA_Pin, input_mode);

  }





  val |= shiftIn(Plugin_031_DATA_Pin, Plugin_031_CLOCK_Pin, 8);





  digitalWrite(Plugin_031_CLOCK_Pin, HIGH);

  digitalWrite(Plugin_031_CLOCK_Pin, LOW);



  return val;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P032_MS5611.ino"
#ifdef USES_P032
# 13 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P032_MS5611.ino"
#define PLUGIN_032 

#define PLUGIN_ID_032 32

#define PLUGIN_NAME_032 "Environment - MS5611 (GY-63)"

#define PLUGIN_VALUENAME1_032 "Temperature"

#define PLUGIN_VALUENAME2_032 "Pressure"



enum

{

  MS5xxx_CMD_RESET = 0x1E,

  MS5xxx_CMD_ADC_READ = 0x00,

  MS5xxx_CMD_ADC_CONV = 0x40,

  MS5xxx_CMD_ADC_D1 = 0x00,

  MS5xxx_CMD_ADC_D2 = 0x10,

  MS5xxx_CMD_ADC_256 = 0x00,

  MS5xxx_CMD_ADC_512 = 0x02,

  MS5xxx_CMD_ADC_1024 = 0x04,

  MS5xxx_CMD_ADC_2048 = 0x06,

  MS5xxx_CMD_ADC_4096 = 0x08,

  MS5xxx_CMD_PROM_RD = 0xA0

};







uint8_t ms5611_i2caddr;

unsigned int ms5611_prom[8];

double ms5611_pressure;

double ms5611_temperature;



boolean Plugin_032_init = false;



boolean Plugin_032(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_032;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_BARO;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_032);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_032));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_032));

        break;

      }

    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        int optionValues[2] = { 0x77, 0x76 };

        addFormSelectorI2C(F("plugin_032_ms5611_i2c"), 2, optionValues, choice);



        addFormNumericBox(F("Altitude [m]"), F("plugin_032_ms5611_elev"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_032_ms5611_i2c"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_032_ms5611_elev"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (!Plugin_032_init)

        {

          Plugin_032_init = Plugin_032_begin(Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        }



        if (Plugin_032_init) {

          Plugin_032_read_prom();

          Plugin_032_readout();



          UserVar[event->BaseVarIndex] = ms5611_temperature / 100;

          int elev = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

          if (elev)

          {

             UserVar[event->BaseVarIndex + 1] = Plugin_032_pressureElevation(ms5611_pressure, elev);

          } else {

             UserVar[event->BaseVarIndex + 1] = ms5611_pressure;

          }



          String log = F("MS5611  : Temperature: ");

          log += UserVar[event->BaseVarIndex];

          addLog(LOG_LEVEL_INFO, log);

          log = F("MS5611  : Barometric Pressure: ");

          log += UserVar[event->BaseVarIndex + 1];

          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }

        break;

      }



  }

  return success;

}
# 259 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P032_MS5611.ino"
bool Plugin_032_begin(uint8_t a) {

  ms5611_i2caddr = a;



  Wire.beginTransmission((uint8_t)ms5611_i2caddr);

  uint8_t ret=Wire.endTransmission(true);

  return ret==0;

}
# 291 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P032_MS5611.ino"
void Plugin_032_read_prom() {

  I2C_write8(ms5611_i2caddr, MS5xxx_CMD_RESET);

  delay(3);



  for(uint8_t i=0;i<8;i++)

  {

      ms5611_prom[i] = I2C_read16_reg(ms5611_i2caddr, MS5xxx_CMD_PROM_RD+2*i);

  }

}
# 317 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P032_MS5611.ino"
unsigned long Plugin_032_read_adc(unsigned char aCMD)

{

  I2C_write8(ms5611_i2caddr, MS5xxx_CMD_ADC_CONV+aCMD);

  switch (aCMD & 0x0f)

  {

    case MS5xxx_CMD_ADC_256 : delayMicroseconds(900);

    break;

    case MS5xxx_CMD_ADC_512 : delay(3);

    break;

    case MS5xxx_CMD_ADC_1024: delay(4);

    break;

    case MS5xxx_CMD_ADC_2048: delay(6);

    break;

    case MS5xxx_CMD_ADC_4096: delay(10);

    break;

  }



  return I2C_read24_reg(ms5611_i2caddr, MS5xxx_CMD_ADC_READ);

}
# 365 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P032_MS5611.ino"
void Plugin_032_readout() {



  unsigned long D1=0, D2=0;



  double dT;

  double OFF;

  double SENS;



  D2=Plugin_032_read_adc(MS5xxx_CMD_ADC_D2+MS5xxx_CMD_ADC_4096);

  D1=Plugin_032_read_adc(MS5xxx_CMD_ADC_D1+MS5xxx_CMD_ADC_4096);





  dT=D2-ms5611_prom[5]*pow(2,8);

  OFF=ms5611_prom[2]*pow(2,16)+dT*ms5611_prom[4]/pow(2,7);

  SENS=ms5611_prom[1]*pow(2,15)+dT*ms5611_prom[3]/pow(2,8);

  ms5611_temperature=(2000+(dT*ms5611_prom[6])/pow(2,23));

  ms5611_pressure=(((D1*SENS)/pow(2,21)-OFF)/pow(2,15));





  double T2=0., OFF2=0., SENS2=0.;

  if(ms5611_temperature<2000) {

    T2=dT*dT/pow(2,31);

    OFF2=5*(ms5611_temperature-2000)*(ms5611_temperature-2000)/pow(2,1);

    SENS2=5*(ms5611_temperature-2000)*(ms5611_temperature-2000)/pow(2,2);

    if(ms5611_temperature<-1500) {

      OFF2+=7*(ms5611_temperature+1500)*(ms5611_temperature+1500);

      SENS2+=11*(ms5611_temperature+1500)*(ms5611_temperature+1500)/pow(2,1);

    }

  }



  ms5611_temperature-=T2;

  OFF-=OFF2;

  SENS-=SENS2;

  ms5611_pressure=(((D1*SENS)/pow(2,21)-OFF)/pow(2,15));

}
# 443 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P032_MS5611.ino"
double Plugin_032_pressureElevation(double atmospheric, int altitude) {

  return atmospheric / pow(1.0 - (altitude/44330.0), 5.255);

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P033_Dummy.ino"
#ifdef USES_P033
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P033_Dummy.ino"
#define PLUGIN_033 

#define PLUGIN_ID_033 33

#define PLUGIN_NAME_033 "Generic - Dummy Device"

#define PLUGIN_VALUENAME1_033 "Dummy"

boolean Plugin_033(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_033;

        Device[deviceCount].Type = DEVICE_TYPE_DUMMY;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].DecimalsOnly = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_033);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_033));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[11];

        options[0] = F("SENSOR_TYPE_SINGLE");

        options[1] = F("SENSOR_TYPE_TEMP_HUM");

        options[2] = F("SENSOR_TYPE_TEMP_BARO");

        options[3] = F("SENSOR_TYPE_TEMP_HUM_BARO");

        options[4] = F("SENSOR_TYPE_DUAL");

        options[5] = F("SENSOR_TYPE_TRIPLE");

        options[6] = F("SENSOR_TYPE_QUAD");

        options[7] = F("SENSOR_TYPE_SWITCH");

        options[8] = F("SENSOR_TYPE_DIMMER");

        options[9] = F("SENSOR_TYPE_LONG");

        options[10] = F("SENSOR_TYPE_WIND");

        int optionValues[11];

        optionValues[0] = SENSOR_TYPE_SINGLE;

        optionValues[1] = SENSOR_TYPE_TEMP_HUM;

        optionValues[2] = SENSOR_TYPE_TEMP_BARO;

        optionValues[3] = SENSOR_TYPE_TEMP_HUM_BARO;

        optionValues[4] = SENSOR_TYPE_DUAL;

        optionValues[5] = SENSOR_TYPE_TRIPLE;

        optionValues[6] = SENSOR_TYPE_QUAD;

        optionValues[7] = SENSOR_TYPE_SWITCH;

        optionValues[8] = SENSOR_TYPE_DIMMER;

        optionValues[9] = SENSOR_TYPE_LONG;

        optionValues[10] = SENSOR_TYPE_WIND;



        addFormSelector(F("Simulate Data Type"), F("plugin_033_sensortype"), 11, options, optionValues, choice );



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_033_sensortype"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        event->sensorType = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        for (byte x=0; x<4;x++)

        {

          String log = F("Dummy: value ");

          log += x+1;

          log += F(": ");

          log += UserVar[event->BaseVarIndex+x];

          addLog(LOG_LEVEL_INFO,log);

        }

        success = true;

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P034_DHT12.ino"
#ifdef USES_P034
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P034_DHT12.ino"
#define PLUGIN_034 

#define PLUGIN_ID_034 34

#define PLUGIN_NAME_034 "Environment - DHT12 (I2C)"

#define PLUGIN_VALUENAME1_034 "Temperature"

#define PLUGIN_VALUENAME2_034 "Humidity"



boolean Plugin_034_init = false;



#define DHT12_I2C_ADDRESS 0x5C



boolean Plugin_034(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_034;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_034);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_034));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_034));

        break;

      }



    case PLUGIN_READ:

      {

        byte dht_dat[5];



        byte i;



        boolean error = false;



        Wire.beginTransmission(DHT12_I2C_ADDRESS);

        Wire.write(0);

        Wire.endTransmission();



        Wire.beginTransmission(DHT12_I2C_ADDRESS);

        if (Wire.requestFrom(DHT12_I2C_ADDRESS, 5) == 5) {

          for (i = 0; i < 5; i++)

          {

            dht_dat[i] = Wire.read();

          }

        } else {

          error = true;

        }

        if (!error)

        {



          byte dht_check_sum = dht_dat[0] + dht_dat[1] + dht_dat[2] + dht_dat[3];



          if (dht_dat[4] == dht_check_sum)

          {

            float temperature = float(dht_dat[2]*10 + (dht_dat[3] & 0x7f)) / 10.0;

            if (dht_dat[3] & 0x80) { temperature = -temperature; }

            float humidity = float(dht_dat[0]*10+dht_dat[1]) / 10.0;



            UserVar[event->BaseVarIndex] = temperature;

            UserVar[event->BaseVarIndex + 1] = humidity;

            String log = F("DHT12: Temperature: ");

            log += UserVar[event->BaseVarIndex];

            addLog(LOG_LEVEL_INFO, log);

            log = F("DHT12: Humidity: ");

            log += UserVar[event->BaseVarIndex + 1];

            addLog(LOG_LEVEL_INFO, log);
# 199 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P034_DHT12.ino"
            success = true;

          }

        }

        if(!success)

        {

          addLog(LOG_LEVEL_INFO, F("DHT12: No reading!"));

          UserVar[event->BaseVarIndex] = NAN;

          UserVar[event->BaseVarIndex + 1] = NAN;

        }

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
#ifdef USES_P035
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
#ifdef ESP8266

#include <IRremoteESP8266.h>

#endif

#include <IRsend.h>

#include <IRutils.h>



IRsend *Plugin_035_irSender;





#define PLUGIN_035 

#define PLUGIN_ID_035 35

#define PLUGIN_NAME_035 "Communication - IR Transmit"



boolean Plugin_035(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_035;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].SendDataOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_035);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        break;

      }



    case PLUGIN_INIT:

      {

        int irPin = Settings.TaskDevicePin1[event->TaskIndex];

        if (Plugin_035_irSender == 0 && irPin != -1)

        {

          addLog(LOG_LEVEL_INFO, F("INIT: IR TX"));

          Plugin_035_irSender = new IRsend(irPin);

          Plugin_035_irSender->begin();

        }

        if (Plugin_035_irSender != 0 && irPin == -1)

        {

          addLog(LOG_LEVEL_INFO, F("INIT: IR TX Removed"));

          delete Plugin_035_irSender;

          Plugin_035_irSender = 0;

        }

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String IrType;

        uint64_t IrCode=0;

        unsigned int IrBits=0;





        char command[120];

        command[0] = 0;

        char TmpStr1[100];

        TmpStr1[0] = 0;

        string.toCharArray(command, 120);



        String cmdCode = string;

        int argIndex = cmdCode.indexOf(',');

        if (argIndex) cmdCode = cmdCode.substring(0, argIndex);



        if (cmdCode.equalsIgnoreCase(F("IRSEND")) && Plugin_035_irSender != 0)

        {

          success = true;

          #ifdef PLUGIN_016

          if (irReceiver != 0) irReceiver->disableIRIn();

          #endif



          if (GetArgv(command, TmpStr1, 100, 2)) IrType = TmpStr1;



          if (IrType.equalsIgnoreCase(F("RAW"))) {

            String IrRaw;

            uint16_t IrHz=0;

            unsigned int IrPLen=0;

            unsigned int IrBLen=0;



            if (GetArgv(command, TmpStr1, 100, 3)) IrRaw = TmpStr1;

            if (GetArgv(command, TmpStr1, 100, 4)) IrHz = str2int(TmpStr1);

            if (GetArgv(command, TmpStr1, 100, 5)) IrPLen = str2int(TmpStr1);

            if (GetArgv(command, TmpStr1, 100, 6)) IrBLen = str2int(TmpStr1);



            printWebString += F("<a href='https://en.wikipedia.org/wiki/Base32#base32hex'>Base32Hex</a> RAW Code: ");

            printWebString += IrRaw;

            printWebString += F("<BR>");



            printWebString += F("kHz: ");

            printWebString += IrHz;

            printWebString += F("<BR>");



            printWebString += F("Pulse Len: ");

            printWebString += IrPLen;

            printWebString += F("<BR>");



            printWebString += F("Blank Len: ");

            printWebString += IrBLen;

            printWebString += F("<BR>");



            uint16_t buf[200];

            uint16_t idx = 0;

            unsigned int c0 = 0;

            unsigned int c1 = 0;



            printWebString += F("Interpreted RAW Code: ");



            for(unsigned int i = 0; i < IrRaw.length(); i++)

            {





              char c = ((IrRaw[i] | ('A' ^ 'a')) - '0') % 39;





              for (unsigned int shft = 1; shft < 6; shft++)

              {



                if ((c & 16) != 0) {



                  c1++;





                  if (c0 > 0) {





                    buf[idx++] = c0 * IrBLen;



                    for (uint t = 0; t < c0; t++)

                      printWebString += F("0");

                  }







                  c0 = 0;

                } else {







                  if (c0+c1 != 0) {



                    c0++;





                    if (c1 > 0) {





                      buf[idx++] = c1 * IrPLen;



                      for (uint t = 0; t < c1; t++)

                        printWebString += F("1");

                    }







                    c1 = 0;

                  }

                }





                c <<= 1;

              }

            }
# 365 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
            if (c0 > 0) {

              buf[idx] = c0 * IrBLen;

              for (uint t = 0; t < c0; t++)

                printWebString += F("0");

            }



            if (c1 > 0) {

              buf[idx] = c1 * IrPLen;

              for (uint t = 0; t < c1; t++)

                printWebString += F("1");

            }



            printWebString += F("<BR>");



            Plugin_035_irSender->sendRaw(buf, idx+1, IrHz);
# 405 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
          } else {





            char ircodestr[100];

            if (GetArgv(command, TmpStr1,100, 2)) IrType = TmpStr1;

                       if (GetArgv(command, TmpStr1, 100, 3)){ IrCode = strtoul(TmpStr1, NULL, 16);

                                                          memcpy(ircodestr, TmpStr1, sizeof(TmpStr1[0])*100);

                                                        }
# 431 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
            if (IrType.equalsIgnoreCase(F("NEC"))) Plugin_035_irSender->sendNEC(IrCode);

            if (IrType.equalsIgnoreCase(F("SONY"))) Plugin_035_irSender->sendSony(IrCode);

            if (IrType.equalsIgnoreCase(F("Sherwood"))) Plugin_035_irSender->sendSherwood(IrCode);

            if (IrType.equalsIgnoreCase(F("SAMSUNG"))) Plugin_035_irSender->sendSAMSUNG(IrCode);

            if (IrType.equalsIgnoreCase(F("LG"))) Plugin_035_irSender->sendLG(IrCode);

            if (IrType.equalsIgnoreCase(F("SharpRaw"))) Plugin_035_irSender->sendSharpRaw(IrBits);

            if (IrType.equalsIgnoreCase(F("JVC"))) Plugin_035_irSender->sendJVC(IrCode);

            if (IrType.equalsIgnoreCase(F("Denon"))) Plugin_035_irSender->sendDenon(IrCode);

            if (IrType.equalsIgnoreCase(F("SanyoLC7461"))) Plugin_035_irSender->sendSanyoLC7461(IrCode);

            if (IrType.equalsIgnoreCase(F("DISH"))) Plugin_035_irSender->sendDISH(IrCode);

            if (IrType.equalsIgnoreCase(F("Panasonic64"))) Plugin_035_irSender->sendPanasonic64(IrCode);

            if (IrType.equalsIgnoreCase(F("Panasonic"))) Plugin_035_irSender->sendPanasonic64(IrCode);



            if (IrType.equalsIgnoreCase(F("RC5"))) Plugin_035_irSender->sendRC5(IrCode);

            if (IrType.equalsIgnoreCase(F("RC6"))) Plugin_035_irSender->sendRC6(IrCode);

            if (IrType.equalsIgnoreCase(F("RCMM"))) Plugin_035_irSender->sendRCMM(IrCode);

            if (IrType.equalsIgnoreCase(F("COOLIX"))) Plugin_035_irSender->sendCOOLIX(IrCode);

            if (IrType.equalsIgnoreCase(F("Whynter"))) Plugin_035_irSender->sendWhynter(IrCode);

            if (IrType.equalsIgnoreCase(F("Mitsubishi"))) Plugin_035_irSender->sendMitsubishi(IrCode);

            if (IrType.equalsIgnoreCase(F("Mitsubishi2"))) Plugin_035_irSender->sendMitsubishi2(IrCode);

            if (IrType.equalsIgnoreCase(F("MitsubishiAC"))) parseStringAndSendAirCon(MITSUBISHI_AC, ircodestr);

            if (IrType.equalsIgnoreCase(F("FujitsuAC"))) parseStringAndSendAirCon(FUJITSU_AC, ircodestr);

            if (IrType.equalsIgnoreCase(F("GC"))) parseStringAndSendGC(ircodestr);

            if (IrType.equalsIgnoreCase(F("Kelvinator"))) parseStringAndSendAirCon(KELVINATOR, ircodestr);

            if (IrType.equalsIgnoreCase(F("Daikin"))) parseStringAndSendAirCon(DAIKIN, ircodestr);

            if (IrType.equalsIgnoreCase(F("AiwaRCT501"))) Plugin_035_irSender->sendAiwaRCT501(IrCode);

            if (IrType.equalsIgnoreCase(F("GREE"))) parseStringAndSendAirCon(GREE, ircodestr);

            if (IrType.equalsIgnoreCase(F("Pronto"))) parseStringAndSendPronto(ircodestr, 0);

            if (IrType.equalsIgnoreCase(F("Argo"))) parseStringAndSendAirCon(ARGO, ircodestr);

            if (IrType.equalsIgnoreCase(F("Trotec"))) parseStringAndSendAirCon(TROTEC, ircodestr);

            if (IrType.equalsIgnoreCase(F("Nikai"))) Plugin_035_irSender->sendNikai(IrCode);

            if (IrType.equalsIgnoreCase(F("ToshibaAC"))) parseStringAndSendAirCon(TOSHIBA_AC, ircodestr);

            if (IrType.equalsIgnoreCase(F("Midea"))) Plugin_035_irSender->sendMidea(IrCode);

            if (IrType.equalsIgnoreCase(F("MagiQuest"))) Plugin_035_irSender->sendMagiQuest(IrCode);

            if (IrType.equalsIgnoreCase(F("Lasertag"))) Plugin_035_irSender->sendLasertag(IrCode);

            if (IrType.equalsIgnoreCase(F("CarrierAC"))) Plugin_035_irSender->sendCarrierAC(IrCode);

            if (IrType.equalsIgnoreCase(F("HaierAC"))) parseStringAndSendAirCon(HAIER_AC, ircodestr);

            if (IrType.equalsIgnoreCase(F("HitachiAC"))) parseStringAndSendAirCon(HITACHI_AC, ircodestr);

            if (IrType.equalsIgnoreCase(F("HitachiAC1"))) parseStringAndSendAirCon(HITACHI_AC1, ircodestr);

            if (IrType.equalsIgnoreCase(F("HitachiAC2"))) parseStringAndSendAirCon(HITACHI_AC2, ircodestr);

            if (IrType.equalsIgnoreCase(F("GICable"))) Plugin_035_irSender->sendGICable(IrCode);

          }



          addLog(LOG_LEVEL_INFO, F("IRTX :IR Code Sent"));

          if (printToWeb)

          {

            printWebString += F("IR Code Sent ");

            printWebString += IrType;

            printWebString += F("<BR>");

          }



          #ifdef PLUGIN_016

          if (irReceiver != 0) irReceiver->enableIRIn();

          #endif

        }

        break;

      }

  }

  return success;

}
# 563 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
void parseStringAndSendAirCon(const uint16_t irType, const String str) {

  uint8_t strOffset = 0;

  uint8_t state[STATE_SIZE_MAX] = {0};

  uint16_t stateSize = 0;



  if (str.startsWith("0x") || str.startsWith("0X"))

    strOffset = 2;



  uint16_t inputLength = str.length() - strOffset;

  if (inputLength == 0) {



    return;

  }



  switch (irType) {

    case KELVINATOR:

      stateSize = KELVINATOR_STATE_LENGTH;

      break;

    case TOSHIBA_AC:

      stateSize = TOSHIBA_AC_STATE_LENGTH;

      break;

    case DAIKIN:

      stateSize = DAIKIN_COMMAND_LENGTH;

      break;

    case MITSUBISHI_AC:

      stateSize = MITSUBISHI_AC_STATE_LENGTH;

      break;

    case TROTEC:

      stateSize = TROTEC_COMMAND_LENGTH;

      break;

    case ARGO:

      stateSize = ARGO_COMMAND_LENGTH;

      break;

    case GREE:

      stateSize = GREE_STATE_LENGTH;

      break;

    case FUJITSU_AC:
# 645 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
      stateSize = inputLength / 2;



      stateSize = std::max(stateSize,

                           (uint16_t) (FUJITSU_AC_STATE_LENGTH_SHORT - 1));



      if (stateSize > FUJITSU_AC_STATE_LENGTH_SHORT)



        stateSize = std::max(stateSize,

                             (uint16_t) (FUJITSU_AC_STATE_LENGTH - 1));



      stateSize = std::min(stateSize, (uint16_t) FUJITSU_AC_STATE_LENGTH);

      break;

    case HAIER_AC:

      stateSize = HAIER_AC_STATE_LENGTH;

      break;

    case HITACHI_AC:

      stateSize = HITACHI_AC_STATE_LENGTH;

      break;

    case HITACHI_AC1:

      stateSize = HITACHI_AC1_STATE_LENGTH;

      break;

    case HITACHI_AC2:

      stateSize = HITACHI_AC2_STATE_LENGTH;

      break;

    default:



      return;

  }

  if (inputLength > stateSize * 2) {



    return;

  }





  uint8_t *statePtr = &state[stateSize - 1];





  for (uint16_t i = 0; i < inputLength; i++) {



    uint8_t c = tolower(str[inputLength + strOffset - i - 1]);

    if (isxdigit(c)) {

      if (isdigit(c))

        c -= '0';

      else

        c = c - 'a' + 10;

    } else {



      return;

    }

    if (i % 2 == 1) {

      *statePtr += (c << 4);

      statePtr--;

    } else {

      *statePtr = c;

    }

  }





  switch (irType) {

#if SEND_KELVINATOR

    case KELVINATOR:

      Plugin_035_irSender->sendKelvinator(reinterpret_cast<uint8_t *>(state));

      break;

#endif

#if SEND_TOSHIBA_AC

    case TOSHIBA_AC:

      Plugin_035_irSender->sendToshibaAC(reinterpret_cast<uint8_t *>(state));

      break;

#endif

#if SEND_DAIKIN

    case DAIKIN:

      Plugin_035_irSender->sendDaikin(reinterpret_cast<uint8_t *>(state));

      break;

#endif

#if MITSUBISHI_AC

    case MITSUBISHI_AC:

      Plugin_035_irSender->sendMitsubishiAC(reinterpret_cast<uint8_t *>(state));

      break;

#endif

#if SEND_TROTEC

    case TROTEC:

      Plugin_035_irSender->sendTrotec(reinterpret_cast<uint8_t *>(state));

      break;

#endif

#if SEND_ARGO

    case ARGO:

      Plugin_035_irSender->sendArgo(reinterpret_cast<uint8_t *>(state));

      break;

#endif

#if SEND_GREE

    case GREE:

      Plugin_035_irSender->sendGree(reinterpret_cast<uint8_t *>(state));

      break;

#endif

#if SEND_FUJITSU_AC

    case FUJITSU_AC:

      Plugin_035_irSender->sendFujitsuAC(reinterpret_cast<uint8_t *>(state), stateSize);

      break;

#endif

#if SEND_HAIER_AC

    case HAIER_AC:

      Plugin_035_irSender->sendHaierAC(reinterpret_cast<uint8_t *>(state));

      break;

#endif

#if SEND_HITACHI_AC

    case HITACHI_AC:

      Plugin_035_irSender->sendHitachiAC(reinterpret_cast<uint8_t *>(state));

      break;

#endif

#if SEND_HITACHI_AC1

    case HITACHI_AC1:

      Plugin_035_irSender->sendHitachiAC1(reinterpret_cast<uint8_t *>(state));

      break;

#endif

#if SEND_HITACHI_AC2

    case HITACHI_AC2:

      Plugin_035_irSender->sendHitachiAC2(reinterpret_cast<uint8_t *>(state));

      break;

#endif

  }



}



#if SEND_PRONTO
# 919 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
void parseStringAndSendPronto(const String str, uint16_t repeats) {

  uint16_t count;

  uint16_t *code_array;

  int16_t index = -1;

  uint16_t start_from = 0;





  count = countValuesInStr(str, ',');





  if (str.startsWith("R") || str.startsWith("r")) {



    index = str.indexOf(',', start_from);

    repeats = str.substring(start_from + 1, index).toInt();

    start_from = index + 1;

    count--;

  }





  if (count < PRONTO_MIN_LENGTH) return;





  code_array = reinterpret_cast<uint16_t*>(malloc(count * sizeof(uint16_t)));







  count = 0;

  do {

    index = str.indexOf(',', start_from);



    code_array[count] = strtoul(str.substring(start_from, index).c_str(),

                                NULL, 16);

    start_from = index + 1;

    count++;

  } while (index != -1);



  Plugin_035_irSender->sendPronto(code_array, count, repeats);

  free(code_array);

}

#endif
# 1081 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
#if SEND_GLOBALCACHE
# 1099 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
void parseStringAndSendGC(const String str) {

  uint16_t count;

  uint16_t *code_array;

  String tmp_str;





  if (str.startsWith("1:1,1,"))

    tmp_str = str.substring(6);

  else

    tmp_str = str;





  count = countValuesInStr(tmp_str, ',');





  code_array = reinterpret_cast<uint16_t*>(malloc(count * sizeof(uint16_t)));





  count = 0;

  uint16_t start_from = 0;

  int16_t index = -1;

  do {

    index = tmp_str.indexOf(',', start_from);

    code_array[count] = tmp_str.substring(start_from, index).toInt();

    start_from = index + 1;

    count++;

  } while (index != -1);



  Plugin_035_irSender->sendGC(code_array, count);

  free(code_array);

}

#endif
# 1177 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
uint16_t countValuesInStr(const String str, char sep) {

  int16_t index = -1;

  uint16_t count = 1;

  do {

    index = str.indexOf(sep, index + 1);

    count++;

  } while (index != -1);

  return count;

}
# 1235 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P035_IRTX.ino"
#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P036_FrameOLED.ino"
#ifdef USES_P036
# 29 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P036_FrameOLED.ino"
#define PLUGIN_036 

#define PLUGIN_ID_036 36

#define PLUGIN_NAME_036 "Display - OLED SSD1306/SH1106 Framed"

#define PLUGIN_VALUENAME1_036 "OLED"



#define P36_Nlines 12

#define P36_Nchars 32



#define P36_CONTRAST_OFF 1

#define P36_CONTRAST_LOW 64

#define P36_CONTRAST_MED 0xCF

#define P36_CONTRAST_HIGH 0xFF





#include "SSD1306.h"

#include "SH1106Wire.h"

#include "OLED_SSD1306_SH1106_images.h"

#include "Dialog_Plain_12_font.h"



#define P36_WIFI_STATE_UNSET -2

#define P36_WIFI_STATE_NOT_CONNECTED -1



static int8_t lastWiFiState = P36_WIFI_STATE_UNSET;







OLEDDisplay *display=NULL;



char P036_deviceTemplate[P36_Nlines][P36_Nchars];



boolean Plugin_036(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  static byte displayTimer = 0;

  static byte frameCounter = 0;



  static byte nrFramesToDisplay = 0;

  static byte currentFrameToDisplay = 0;



  int linesPerFrame;

  int NFrames;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_036;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_036);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_036));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {





        byte choice5 = Settings.TaskDevicePluginConfig[event->TaskIndex][5];

        String options5[2];

        options5[0] = F("SSD1306");

        options5[1] = F("SH1106");

        int optionValues5[2] = { 1, 2 };

        addFormSelector(F("Controler"), F("plugin_036_controler"), 2, options5, optionValues5, choice5);



        byte choice0 = Settings.TaskDevicePluginConfig[event->TaskIndex][0];
# 209 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P036_FrameOLED.ino"
        int optionValues0[2];

        optionValues0[0] = 0x3C;

        optionValues0[1] = 0x3D;

        addFormSelectorI2C(F("plugin_036_adr"), 2, optionValues0, choice0);



        byte choice1 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options1[2];

        options1[0] = F("Normal");

        options1[1] = F("Rotated");

        int optionValues1[2] = { 1, 2 };

        addFormSelector(F("Rotation"), F("plugin_036_rotate"), 2, options1, optionValues1, choice1);



        byte choice2 = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        String options2[4];

        options2[0] = F("1");

        options2[1] = F("2");

        options2[2] = F("3");

        options2[3] = F("4");

        int optionValues2[4] = { 1, 2, 3, 4 };

        addFormSelector(F("Lines per Frame"), F("plugin_036_nlines"), 4, options2, optionValues2, choice2);



        byte choice3 = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

        String options3[5];

        options3[0] = F("Very Slow");

        options3[1] = F("Slow");

        options3[2] = F("Fast");

        options3[3] = F("Very Fast");

        options3[4] = F("Instant");

        int optionValues3[5];

        optionValues3[0] = 1;

        optionValues3[1] = 2;

        optionValues3[2] = 4;

        optionValues3[3] = 8;

        optionValues3[4] = 32;

        addFormSelector(F("Scroll"), F("plugin_036_scroll"), 5, options3, optionValues3, choice3);



        LoadCustomTaskSettings(event->TaskIndex, (byte*)&P036_deviceTemplate, sizeof(P036_deviceTemplate));



        for (byte varNr = 0; varNr < P36_Nlines; varNr++)

        {

          addFormTextBox(String(F("Line ")) + (varNr + 1), String(F("Plugin_036_template")) + (varNr + 1), P036_deviceTemplate[varNr], P36_Nchars);

        }



        addFormPinSelect(F("Display button"), F("taskdevicepin3"), Settings.TaskDevicePin3[event->TaskIndex]);



        addFormNumericBox(F("Display Timeout"), F("plugin_036_timer"), Settings.TaskDevicePluginConfig[event->TaskIndex][4]);



        byte choice6 = Settings.TaskDevicePluginConfig[event->TaskIndex][6];

        if (choice6 == 0) choice6 = P36_CONTRAST_HIGH;

        String options6[3];

        options6[0] = F("Low");

        options6[1] = F("Medium");

        options6[2] = F("High");

        int optionValues6[3];

        optionValues6[0] = P36_CONTRAST_LOW;

        optionValues6[1] = P36_CONTRAST_MED;

        optionValues6[2] = P36_CONTRAST_HIGH;

        addFormSelector(F("Contrast"), F("plugin_036_contrast"), 3, options6, optionValues6, choice6);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {



        schedule_task_device_timer(event->TaskIndex,

           millis() + (Settings.TaskDeviceTimer[event->TaskIndex] * 1000));

        frameCounter=0;



        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_036_adr"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_036_rotate"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_036_nlines"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("plugin_036_scroll"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][4] = getFormItemInt(F("plugin_036_timer"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][5] = getFormItemInt(F("plugin_036_controler"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][6] = getFormItemInt(F("plugin_036_contrast"));



        String argName;



        for (byte varNr = 0; varNr < P36_Nlines; varNr++)

        {

          argName = F("Plugin_036_template");

          argName += varNr + 1;

          strncpy(P036_deviceTemplate[varNr], WebServer.arg(argName).c_str(), sizeof(P036_deviceTemplate[varNr]));

        }



        SaveCustomTaskSettings(event->TaskIndex, (byte*)&P036_deviceTemplate, sizeof(P036_deviceTemplate));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        lastWiFiState = P36_WIFI_STATE_UNSET;



        LoadCustomTaskSettings(event->TaskIndex, (byte*)&P036_deviceTemplate, sizeof(P036_deviceTemplate));





        if (display)

        {

          display->end();

          delete display;

        }



        uint8_t OLED_address = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][5] == 1) {

          display = new SSD1306Wire(OLED_address, Settings.Pin_i2c_sda, Settings.Pin_i2c_scl);

        } else {

          display = new SH1106Wire(OLED_address, Settings.Pin_i2c_sda, Settings.Pin_i2c_scl);

        }

        display->init();

        display->displayOn();



        uint8_t OLED_contrast = Settings.TaskDevicePluginConfig[event->TaskIndex][6];

        P36_setContrast(OLED_contrast);





        UserVar[event->BaseVarIndex] = 1;





        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 2)display->flipScreenVertically();





        display_header();

        display_logo();

        display->display();





        displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][4];



        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

        {

          pinMode(Settings.TaskDevicePin3[event->TaskIndex], INPUT_PULLUP);

        }





        frameCounter = 0;

        nrFramesToDisplay = 1;

        currentFrameToDisplay = 0;



        success = true;

        break;

      }



    case PLUGIN_EXIT:

      {

          if (display)

          {

            display->end();

            delete display;

            display=NULL;

          }

          break;

      }





    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePin3[event->TaskIndex] != -1)

        {

          if (!digitalRead(Settings.TaskDevicePin3[event->TaskIndex]))

          {

            display->displayOn();

            UserVar[event->BaseVarIndex] = 1;

            displayTimer = Settings.TaskDevicePluginConfig[event->TaskIndex][4];

          }

        }

        break;

      }





    case PLUGIN_ONCE_A_SECOND:

      {



        if ( displayTimer > 0)

        {

          displayTimer--;

          if (displayTimer == 0)

          {

            display->displayOff();

            UserVar[event->BaseVarIndex] = 0;

          }

        }

        if (UserVar[event->BaseVarIndex] == 1) {



          if (display && display_wifibars()) {



            display->display();

          }

        }



        success = true;

        break;

      }



    case PLUGIN_READ:

      {
# 623 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P036_FrameOLED.ino"
        linesPerFrame = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        NFrames = P36_Nlines / linesPerFrame;





        String tmpString;

        tmpString.reserve(P36_Nchars);

        String newString[4];

        String oldString[4];





        for (byte i = 0; i < linesPerFrame; i++)

        {

          tmpString = P036_deviceTemplate[(linesPerFrame * frameCounter) + i];

          oldString[i] = P36_parseTemplate(tmpString, 20);

          oldString[i].trim();

        }
# 663 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P036_FrameOLED.ino"
        boolean foundText = false;

        int ntries = 0;

        while (!foundText) {





          ntries += 1;

          if (ntries > NFrames) break;





          frameCounter = frameCounter + 1;

          if ( frameCounter > NFrames - 1) {

            frameCounter = 0;

            currentFrameToDisplay = 0;

          }





          for (byte i = 0; i < linesPerFrame; i++)

          {

            tmpString = P036_deviceTemplate[(linesPerFrame * frameCounter) + i];

            newString[i] = P36_parseTemplate(tmpString, 20);

            newString[i].trim();

            if (newString[i].length() > 0) foundText = true;

          }

          if (foundText) {

            if (frameCounter != 0) {

              ++currentFrameToDisplay;

            }

          }

        }

        if ((currentFrameToDisplay + 1) > nrFramesToDisplay) {

          nrFramesToDisplay = currentFrameToDisplay + 1;

        }





        display_header();

        display_indicator(currentFrameToDisplay, nrFramesToDisplay);



        display->display();



        int scrollspeed = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

        display_scroll(oldString, newString, linesPerFrame, scrollspeed);



        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String tmpString = string;

        int argIndex = tmpString.indexOf(',');

        if (argIndex)

          tmpString = tmpString.substring(0, argIndex);

        if (tmpString.equalsIgnoreCase(F("OLEDFRAMEDCMD")) && display)

        {

          success = true;

          argIndex = string.lastIndexOf(',');

          tmpString = string.substring(argIndex + 1);

          if (tmpString.equalsIgnoreCase(F("Off")))

            P36_setContrast(P36_CONTRAST_OFF);

          else if (tmpString.equalsIgnoreCase(F("On")))

            display->displayOn();

          else if (tmpString.equalsIgnoreCase(F("Low")))

            P36_setContrast(P36_CONTRAST_LOW);

          else if (tmpString.equalsIgnoreCase(F("Med")))

            P36_setContrast(P36_CONTRAST_MED);

          else if (tmpString.equalsIgnoreCase(F("High")))

            P36_setContrast(P36_CONTRAST_HIGH);

        }

        break;

      }



  }

  return success;

}
# 819 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P036_FrameOLED.ino"
void P36_setContrast(uint8_t OLED_contrast) {

  char contrast = 100;

  char precharge = 241;

  char comdetect = 64;

  switch (OLED_contrast) {

    case P36_CONTRAST_OFF:

      if (display) {

        display->displayOff();

      }

      return;

    case P36_CONTRAST_LOW:

      contrast = 10; precharge = 5; comdetect = 0;

      break;

    case P36_CONTRAST_MED:

      contrast = P36_CONTRAST_MED; precharge = 0x1F; comdetect = 64;

      break;

    case P36_CONTRAST_HIGH:

    default:

      contrast = P36_CONTRAST_HIGH; precharge = 241; comdetect = 64;

      break;

  }

  if (display) {

    display->displayOn();

    display->setContrast(contrast, precharge, comdetect);

  }

}





String P36_parseTemplate(String &tmpString, byte lineSize) {

  String result = parseTemplate(tmpString, lineSize);
# 929 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P036_FrameOLED.ino"
  return result;

}







void display_header() {

  static boolean showWiFiName = true;

  if (showWiFiName && (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED) ) {

    String newString = WiFi.SSID();

    newString.trim();

    display_title(newString);

  } else {

    String dtime = F("%sysname%");

    String newString = parseTemplate(dtime, 10);

    newString.trim();

    display_title(newString);

  }

  showWiFiName = !showWiFiName;



  display_time();

  display_wifibars();

}



void display_time() {

  String dtime = F("%systime%");

  String newString = parseTemplate(dtime, 10);

  display->setTextAlignment(TEXT_ALIGN_LEFT);

  display->setFont(ArialMT_Plain_10);

  display->setColor(BLACK);

  display->fillRect(0, 0, 28, 10);

  display->setColor(WHITE);

  display->drawString(0, 0, newString.substring(0, 5));

}



void display_title(String& title) {

  display->setTextAlignment(TEXT_ALIGN_CENTER);

  display->setFont(ArialMT_Plain_10);

  display->setColor(BLACK);

  display->fillRect(0, 0, 128, 13);

  display->setColor(WHITE);

  display->drawString(64, 0, title);

}



void display_logo() {

  display->setTextAlignment(TEXT_ALIGN_LEFT);

  display->setFont(ArialMT_Plain_16);

  display->setColor(BLACK);

  display->fillRect(0, 14, 128, 64);

  display->setColor(WHITE);

  display->drawString(65, 15, F("ESP"));

  display->drawString(65, 34, F("Easy"));

  display->drawXbm(24, 14, espeasy_logo_width, espeasy_logo_height, espeasy_logo_bits);

}







void display_indicator(int iframe, int frameCount) {







  display->setColor(BLACK);

  display->fillRect(0, 54, 128, 10);

  display->setColor(WHITE);





  if (frameCount <= 1) return;





  for (byte i = 0; i < frameCount; i++) {

    const char *image;

    if (iframe == i) {

      image = activeSymbole;

    } else {

      image = inactiveSymbole;

    }



    int x, y;



    y = 56;
# 1095 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P036_FrameOLED.ino"
    const int number_spaces = frameCount - 1;

    if (number_spaces <= 0)

      return;

    int margin = 20;

    int spacing = (128 - 2 * margin) / number_spaces;



    if (spacing > 30) {

      spacing = 30;

      margin = (128 - number_spaces * spacing) / 2;

    }



    x = margin + (spacing * i);

    display->drawXbm(x, y, 8, 8, image);

  }

}



void display_scroll(String outString[], String inString[], int nlines, int scrollspeed)

{
# 1141 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P036_FrameOLED.ino"
  int ypos[4];



  if (nlines == 1)

  {

    display->setFont(ArialMT_Plain_24);

    ypos[0] = 20;

  }



  if (nlines == 2)

  {

    display->setFont(ArialMT_Plain_16);

    ypos[0] = 15;

    ypos[1] = 34;

  }



  if (nlines == 3)

  {

    display->setFont(Dialog_plain_12);

    ypos[0] = 13;

    ypos[1] = 25;

    ypos[2] = 37;

  }



  if (nlines == 4)

  {

    display->setFont(ArialMT_Plain_10);

    ypos[0] = 12;

    ypos[1] = 22;

    ypos[2] = 32;

    ypos[3] = 42;

  }



  display->setTextAlignment(TEXT_ALIGN_CENTER);



  for (byte i = 0; i < 33; i = i + scrollspeed)

  {







    display->setColor(BLACK);



    display->fillRect(0, 12, 128, 42);

    display->setColor(WHITE);







    for (byte j = 0; j < nlines; j++)

    {



      display->drawString(64 + (4 * i), ypos[j], outString[j]);



      display->drawString(-64 + (4 * i), ypos[j], inString[j]);

    }



    display->display();



    delay(2);





  }

}





bool display_wifibars() {

  const bool connected = wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED;

  const int nbars_filled = (WiFi.RSSI() + 100) / 8;

  const int newState = connected ? nbars_filled : P36_WIFI_STATE_UNSET;

  if (newState == lastWiFiState)

    return false;



  int x = 105;

  int y = 0;

  int size_x = 15;

  int size_y = 10;

  int nbars = 5;

  int16_t width = (size_x / nbars);

  size_x = width * nbars - 1;
# 1307 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P036_FrameOLED.ino"
  display->setColor(BLACK);

  display->fillRect(x , y, size_x, size_y);

  display->setColor(WHITE);

  if (wifiStatus == ESPEASY_WIFI_SERVICES_INITIALIZED) {

    for (byte ibar = 0; ibar < nbars; ibar++) {

      int16_t height = size_y * (ibar + 1) / nbars;

      int16_t xpos = x + ibar * width;

      int16_t ypos = y + size_y - height;

      if (ibar <= nbars_filled) {



        display->fillRect(xpos, ypos, width - 1, height);

      } else {



        display->fillRect(xpos, ypos, width - 1, 1);

        display->fillRect(xpos, y + size_y - 1, width - 1, 1);

      }

    }

  } else {



  }

  return true;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P037_MQTTImport.ino"
#ifdef USES_P037
# 19 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P037_MQTTImport.ino"
#define PLUGIN_037 

#define PLUGIN_ID_037 37

#define PLUGIN_NAME_037 "Generic - MQTT Import"



#define PLUGIN_VALUENAME1_037 "Value1"

#define PLUGIN_VALUENAME2_037 "Value2"

#define PLUGIN_VALUENAME3_037 "Value3"

#define PLUGIN_VALUENAME4_037 "Value4"



#define PLUGIN_IMPORT 37
# 47 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P037_MQTTImport.ino"
WiFiClient espclient_037;

PubSubClient *MQTTclient_037 = NULL;

bool MQTTclient_037_connected = false;

int reconnectCount = 0;



String getClientName() {







  String tmpClientName = F("%sysname%-Import");

  String ClientName = parseTemplate(tmpClientName, 20);

  if (reconnectCount != 0) ClientName += reconnectCount;

  return ClientName;

}



void Plugin_037_try_connect() {

  Plugin_037_update_connect_status();

  if (MQTTclient_037_connected) return;



  espclient_037 = WiFiClient();



  if (MQTTclient_037 == NULL) {

    MQTTclient_037 = new PubSubClient(espclient_037);

  }

  if (MQTTConnect_037())

  {



    MQTTSubscribe_037();

  } else {

    MQTTclient_037->disconnect();

  }

  Plugin_037_update_connect_status();

}



void Plugin_037_update_connect_status() {

  bool connected = false;

  if (MQTTclient_037 != NULL) {

    connected = MQTTclient_037->connected();

  }

  if (MQTTclient_037_connected != connected) {

    MQTTclient_037_connected = !MQTTclient_037_connected;

    if (Settings.UseRules) {

      String event = connected ? F("MQTTimport#Connected") : F("MQTTimport#Disconnected");

      rulesProcessing(event);

    }

    if (!connected) {



      espclient_037 = WiFiClient();

      ++reconnectCount;

      addLog(LOG_LEVEL_ERROR, F("IMPT : MQTT 037 Connection lost"));

    }

  }

}



boolean Plugin_037(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  char deviceTemplate[4][41];



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_037;

        Device[deviceCount].Type = DEVICE_TYPE_DUMMY;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_037);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_037));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_037));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_037));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_037));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {



        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



        for (byte varNr = 0; varNr < 4; varNr++)

        {

         addFormTextBox(String(F("MQTT Topic ")) + (varNr + 1), String(F("Plugin_037_template")) +

           (varNr + 1), deviceTemplate[varNr], 40);

        }

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        String argName;



        for (byte varNr = 0; varNr < 4; varNr++)

        {

          argName = F("Plugin_037_template");

          argName += varNr + 1;

          strncpy(deviceTemplate[varNr], WebServer.arg(argName).c_str(), sizeof(deviceTemplate[varNr]));

        }



        SaveCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        success = false;





        if (MQTTclient_037 != NULL) {

          MQTTclient_037->disconnect();

          if (MQTTConnect_037())

          {



            MQTTSubscribe_037();

            success = true;

          }

        }

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (MQTTclient_037 != NULL && !MQTTclient_037->loop()) {

          Plugin_037_update_connect_status();

        }

        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {



        Plugin_037_try_connect();

        if (MQTTclient_037 != NULL) {

          if (!MQTTclient_037->connected() || MQTTclient_should_reconnect) {

            if (MQTTclient_should_reconnect) {

              addLog(LOG_LEVEL_ERROR, F("IMPT : MQTT 037 Intentional reconnect"));

            }



            MQTTclient_037->disconnect();

            Plugin_037_update_connect_status();

            delay(250);



            if (! MQTTConnect_037()) {

              success = false;

              break;

            }



            MQTTSubscribe_037();

          }

          success = true;

        }

        break;

      }



    case PLUGIN_READ:

      {





        success = false;

        break;

      }



    case PLUGIN_IMPORT:

      {







        LoadTaskSettings(event->TaskIndex);



        String Payload = event->String2;

        float floatPayload;

        if (!string2float(Payload, floatPayload)) {

          String log = F("IMPT : Bad Import MQTT Command ");

          log += event->String1;

          addLog(LOG_LEVEL_ERROR, log);

          log = F("ERR  : Illegal Payload ");

          log += Payload;

          log += "  ";

          log += getTaskDeviceName(event->TaskIndex);

          addLog(LOG_LEVEL_INFO, log);

          success = false;

          break;

        }







        String Topic = event->String1;



        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



        for (byte x = 0; x < 4; x++)

        {

          String subscriptionTopic = deviceTemplate[x];

          subscriptionTopic.trim();

          if (subscriptionTopic.length() == 0) continue;





          parseSystemVariables(subscriptionTopic, false);

          if (MQTTCheckSubscription_037(Topic, subscriptionTopic))

          {

            UserVar[event->BaseVarIndex + x] = floatPayload;







            String log = F("IMPT : [");

            log += getTaskDeviceName(event->TaskIndex);

            log += F("#");

            log += ExtraTaskSettings.TaskDeviceValueNames[x];

            log += F("] : ");

            log += floatPayload;

            addLog(LOG_LEVEL_INFO, log);







            if (Settings.UseRules)

            {

              String RuleEvent = F("");

              RuleEvent += getTaskDeviceName(event->TaskIndex);

              RuleEvent += F("#");

              RuleEvent += ExtraTaskSettings.TaskDeviceValueNames[x];

              RuleEvent += F("=");

              RuleEvent += floatPayload;

              rulesProcessing(RuleEvent);

            }



            success = true;

          }

        }



        break;



      }

  }



  return success;

}

boolean MQTTSubscribe_037()

{

  if (!MQTTclient_037_connected) return false;
# 575 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P037_MQTTImport.ino"
  char deviceTemplate[4][41];







  for (byte y = 0; y < TASKS_MAX; y++)

  {

    if (Settings.TaskDeviceNumber[y] == PLUGIN_ID_037)

    {

      LoadCustomTaskSettings(y, (byte*)&deviceTemplate, sizeof(deviceTemplate));







      for (byte x = 0; x < 4; x++)

      {

        String subscribeTo = deviceTemplate[x];



        if (subscribeTo.length() > 0)

        {

          parseSystemVariables(subscribeTo, false);

          if (MQTTclient_037 != NULL && MQTTclient_037->subscribe(subscribeTo.c_str()))

          {

            String log = F("IMPT : [");

            LoadTaskSettings(y);

            log += getTaskDeviceName(y);

            log += F("#");

            log += ExtraTaskSettings.TaskDeviceValueNames[x];

            log += F("] subscribed to ");

            log += subscribeTo;

            addLog(LOG_LEVEL_INFO, log);

          }

          else

          {

            String log = F("IMPT : Error subscribing to ");

            log += subscribeTo;

            addLog(LOG_LEVEL_ERROR, log);

            return false;

          }



        }

      }

    }

  }

  return true;

}







void mqttcallback_037(char* c_topic, byte* b_payload, unsigned int length)

{



  String topic = c_topic;



  char cpayload[256];

  strncpy(cpayload, (char*)b_payload, length);

  cpayload[length] = 0;

  String payload = cpayload;

  payload.trim();



  byte DeviceIndex = getDeviceIndex(PLUGIN_ID_037);







  struct EventStruct TempEvent;



  TempEvent.String1 = topic;

  TempEvent.String2 = payload;







  for (byte y = 0; y < TASKS_MAX; y++)

  {

    if (Settings.TaskDeviceNumber[y] == PLUGIN_ID_037)

    {

      TempEvent.TaskIndex = y;

      LoadTaskSettings(TempEvent.TaskIndex);

      TempEvent.BaseVarIndex = y * VARS_PER_TASK;

      schedule_plugin_task_event_timer(DeviceIndex, PLUGIN_IMPORT, &TempEvent);

    }

  }

}
# 747 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P037_MQTTImport.ino"
boolean MQTTConnect_037()

{

  boolean result = false;

  if (MQTTclient_037 == NULL) return false;

  String clientid = getClientName();



  int enabledMqttController = firstEnabledMQTTController();

  if (enabledMqttController < 0) {



    return false;

  }



  if (MQTTclient_037->connected()) return true;





  if (!WiFiConnected(100)) {

    Plugin_037_update_connect_status();

    return false;

  }

  ControllerSettingsStruct ControllerSettings;

  LoadControllerSettings(enabledMqttController, ControllerSettings);

  if (ControllerSettings.UseDNS) {

    MQTTclient_037->setServer(ControllerSettings.getHost().c_str(), ControllerSettings.Port);

  } else {

    MQTTclient_037->setServer(ControllerSettings.getIP(), ControllerSettings.Port);

  }

  MQTTclient_037->setCallback(mqttcallback_037);







  for (byte x = 1; x < 4; x++)

  {

    String log = "";



    if ((SecuritySettings.ControllerUser[enabledMqttController][0] != 0) && (SecuritySettings.ControllerPassword[enabledMqttController][0] != 0))

      result = MQTTclient_037->connect(clientid.c_str(), SecuritySettings.ControllerUser[enabledMqttController], SecuritySettings.ControllerPassword[enabledMqttController]);

    else

      result = MQTTclient_037->connect(clientid.c_str());





    if (result)

    {

      log = F("IMPT : Connected to MQTT broker with Client ID=");

      log += clientid;

      addLog(LOG_LEVEL_INFO, log);



      break;

    }

    else

    {

      log = F("IMPT : Failed to connect to MQTT broker - attempt ");

      log += x;

      addLog(LOG_LEVEL_ERROR, log);

    }



    delay(500);

  }

  Plugin_037_update_connect_status();

  return MQTTclient_037->connected();

}
# 875 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P037_MQTTImport.ino"
boolean MQTTCheckSubscription_037(String Topic, String Subscription) {



  String tmpTopic = Topic;

  String tmpSub = Subscription;



  tmpTopic.trim();

  tmpSub.trim();







  if (tmpTopic.substring(0, 1) == "/")tmpTopic = tmpTopic.substring(1);

  if (tmpSub.substring(0, 1) == "/")tmpSub = tmpSub.substring(1);







  int lenTopic = tmpTopic.length();

  if (tmpTopic.substring(lenTopic - 1, lenTopic) != "/")tmpTopic += F("/");



  int lenSub = tmpSub.length();

  if (tmpSub.substring(lenSub - 1, lenSub) != "/")tmpSub += F("/");







  int SlashTopic;

  int SlashSub;

  int count = 0;



  String pTopic;

  String pSub;



  while (count < 10) {







    SlashTopic = tmpTopic.indexOf('/');

    SlashSub = tmpSub.indexOf('/');
# 955 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P037_MQTTImport.ino"
    if ((SlashTopic == -1) && (SlashSub == -1)) return true;

    if ((SlashTopic == -1) && (SlashSub != -1)) return false;

    if ((SlashTopic != -1) && (SlashSub == -1)) return false;







    pTopic = tmpTopic.substring(0, SlashTopic);

    pSub = tmpSub.substring(0, SlashSub);







    tmpTopic = tmpTopic.substring(SlashTopic + 1);

    tmpSub = tmpSub.substring(SlashSub + 1);





    if (pSub == "#") return true;

    if ((pTopic != pSub) && (pSub != "+"))return false;



    count = count + 1;

  }

  return false;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P038_NeoPixel.ino"
#ifdef USES_P038
# 47 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P038_NeoPixel.ino"
#include <Adafruit_NeoPixel.h>



Adafruit_NeoPixel *Plugin_038_pixels;



#define PLUGIN_038 

#define PLUGIN_ID_038 38

#define PLUGIN_NAME_038 "Output - NeoPixel (Basic)"

#define PLUGIN_VALUENAME1_038 ""



int MaxPixels = 0;



boolean Plugin_038(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_038;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].Custom = true;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_038);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_038));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        const String options[] = { F("GRB"), F("GRBW") };

        int indices[] = { 1, 2 };



       addFormNumericBox(F("Led Count"), F("plugin_038_leds"), Settings.TaskDevicePluginConfig[event->TaskIndex][0],1,999);

       addFormPinSelect(F("GPIO"), F("taskdevicepin1"), Settings.TaskDevicePin1[event->TaskIndex]);

        addFormSelector(F("Strip Type"), F("plugin_038_strip"), 2, options, indices, Settings.TaskDevicePluginConfig[event->TaskIndex][1] );



       success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_038_leds"));

        MaxPixels = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_038_strip"));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_038_pixels)

        {

          byte striptype = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

          if (striptype == 1)

            Plugin_038_pixels = new Adafruit_NeoPixel(Settings.TaskDevicePluginConfig[event->TaskIndex][0], Settings.TaskDevicePin1[event->TaskIndex], NEO_GRB + NEO_KHZ800);

          else if (striptype == 2)

            Plugin_038_pixels = new Adafruit_NeoPixel(Settings.TaskDevicePluginConfig[event->TaskIndex][0], Settings.TaskDevicePin1[event->TaskIndex], NEO_GRBW + NEO_KHZ800);

          else

            Plugin_038_pixels = new Adafruit_NeoPixel(Settings.TaskDevicePluginConfig[event->TaskIndex][0], Settings.TaskDevicePin1[event->TaskIndex], NEO_GRB + NEO_KHZ800);



          Plugin_038_pixels->begin();

        }

        MaxPixels = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (Plugin_038_pixels)

        {

          String tmpString = string;

          int argIndex = tmpString.indexOf(',');

          if (argIndex)

            tmpString = tmpString.substring(0, argIndex);



          if (tmpString.equalsIgnoreCase(F("NeoPixel")))

          {
# 241 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P038_NeoPixel.ino"
            Plugin_038_pixels->setPixelColor(event->Par1 - 1, Plugin_038_pixels->Color(event->Par2, event->Par3, event->Par4, event->Par5));

            Plugin_038_pixels->show();

            success = true;

          }



          if (tmpString.equalsIgnoreCase(F("NeoPixelAll")))

      {
# 263 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P038_NeoPixel.ino"
       for (int i = 0; i < MaxPixels; i++)

       {

                Plugin_038_pixels->setPixelColor(i, Plugin_038_pixels->Color(event->Par1, event->Par2, event->Par3, event->Par4));

       }

       Plugin_038_pixels->show();

       success = true;

          }



          if (tmpString.equalsIgnoreCase(F("NeoPixelLine")))

      {
# 299 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P038_NeoPixel.ino"
       for (int i = event->Par1 - 1; i < event->Par2; i++)

       {

        Plugin_038_pixels->setPixelColor(i, Plugin_038_pixels->Color(event->Par3, event->Par4, event->Par5));

       }

       Plugin_038_pixels->show();

       success = true;

          }

        }

        break;

      }



  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P039_Thermocouple.ino"
#ifdef USES_P039
# 73 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P039_Thermocouple.ino"
#include <SPI.h>



#define PLUGIN_039 

#define PLUGIN_ID_039 39

#define PLUGIN_NAME_039 "Environment - Thermocouple"

#define PLUGIN_VALUENAME1_039 "Temperature"



uint8_t Plugin_039_SPI_CS_Pin = 15;

bool Plugin_039_SensorAttached = true;

uint32_t Plugin_039_Sensor_fault = 0;

double Plugin_039_Celsius = 0.0;



boolean Plugin_039(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_039;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_039);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_039));

        break;

      }



    case PLUGIN_INIT:

      {





        if (Settings.TaskDevicePin1[event->TaskIndex] != 0)

        {



          Plugin_039_SPI_CS_Pin = Settings.TaskDevicePin1[event->TaskIndex];

        }





        pinMode(Plugin_039_SPI_CS_Pin, OUTPUT);



        SPI.setHwCs(false);

        SPI.begin();



        addLog(LOG_LEVEL_INFO, F("P039 : SPI Init"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormNote(F("<b>1st GPIO</b> = CS (Usable GPIOs : 0, 2, 4, 5, 15)"));





        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[2];

        options[0] = F("MAX 6675");

        options[1] = F("MAX 31855");



        int optionValues[2] = { 1, 2 };

        addFormSelector(F("Adapter IC"), F("plugin_039_maxtype"), 2, options, optionValues, choice);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_039_maxtype"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {





        byte MaxType = Settings.TaskDevicePluginConfig[event->TaskIndex][0];







        Plugin_039_SPI_CS_Pin = Settings.TaskDevicePin1[event->TaskIndex];



        switch (MaxType) {

          case 1:

            Plugin_039_Celsius = readMax6675();

            break;

          case 2:

            Plugin_039_Celsius = readMax31855();

            break;

          case 3:



            break;

        }



        if (Plugin_039_Celsius != NAN)

        {

          UserVar[event->BaseVarIndex] = Plugin_039_Celsius;

          String log = F("P039 : Temperature ");

          log += UserVar[event->BaseVarIndex];

          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }

        else

        {

          UserVar[event->BaseVarIndex] = NAN;

          UserVar[event->BaseVarIndex + 1] = NAN;

          addLog(LOG_LEVEL_INFO, F("P039 : No Sensor attached !"));

          success = false;

        }



        break;

      }

  }

  return success;

}



double readMax6675()

{

  uint16_t rawvalue = 0;



  digitalWrite(Plugin_039_SPI_CS_Pin, LOW);
# 363 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P039_Thermocouple.ino"
  rawvalue = SPI.transfer16(0x0);



  digitalWrite(Plugin_039_SPI_CS_Pin, HIGH);



  String log = F("P039 : MAX6675 : RAW - BIN:");

  log += String(rawvalue, BIN);

  log += " HEX:";

  log += String(rawvalue, HEX);

  log += " DEC:";

  log += String(rawvalue);

  addLog(LOG_LEVEL_DEBUG, log);
# 395 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P039_Thermocouple.ino"
  Plugin_039_SensorAttached = !(rawvalue & 0x0004);



  if (Plugin_039_SensorAttached)

  {



    rawvalue >>= 3;





    return rawvalue * 0.25;

  }

  else

  {

    return NAN;

  }

}



double readMax31855()

{

  uint32_t rawvalue = 0;



  digitalWrite(Plugin_039_SPI_CS_Pin, LOW);



  rawvalue = SPI.transfer16(0x0);



  rawvalue <<= 16;



  rawvalue |= SPI.transfer16(0x0);



  digitalWrite(Plugin_039_SPI_CS_Pin, HIGH);



  String log = F("P039 : MAX31855 : RAW - BIN:");

  log += String(rawvalue, BIN);

  log += " HEX:";

  log += String(rawvalue, HEX);

  log += " DEC:";

  log += String(rawvalue);

  addLog(LOG_LEVEL_DEBUG, log);



  if (Plugin_039_Sensor_fault != (rawvalue & 0x7)) {



    Plugin_039_Sensor_fault = (rawvalue & 0x7);

    log = F("P039 : MAX31855");

    if (Plugin_039_Sensor_fault == 0) {

      log += F("Fault resolved");

    } else {

      log += F("Fault code:");

      if (rawvalue & 0x01) {

        log += F(" Open (no connection)");

      }

      if (rawvalue & 0x02) {

        log += F(" Short-circuit to GND");

      }

      if (rawvalue & 0x04) {

        log += F(" Short-circuit to Vcc");

      }

    }

    addLog(LOG_LEVEL_DEBUG, log);

  }



  Plugin_039_SensorAttached = !(rawvalue & 0x00010000);

  if (Plugin_039_SensorAttached)

  {





    rawvalue >>= 18;
# 541 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P039_Thermocouple.ino"
    int temperature = Plugin_039_convert_two_complement(rawvalue, 14);



    return temperature * 0.25;

  }

  else

  {



    return NAN;

  }

}



int Plugin_039_convert_two_complement(uint32_t value, int nr_bits) {

  const bool negative = (value & (1 << (nr_bits - 1))) != 0;

  int nativeInt;

  if (negative) {



    nativeInt = value | ~((1 << nr_bits) - 1);

  } else {

    nativeInt = value;

  }

  return nativeInt;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P040_ID12.ino"
#ifdef USES_P040
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P040_ID12.ino"
#define PLUGIN_040 

#define PLUGIN_ID_040 40

#define PLUGIN_NAME_040 "RFID - ID12LA/RDM6300"

#define PLUGIN_VALUENAME1_040 "Tag"



boolean Plugin_040_init = false;



boolean Plugin_040(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_040;

        Device[deviceCount].VType = SENSOR_TYPE_LONG;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_040);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_040));

        break;

      }





    case PLUGIN_INIT:

      {

        Plugin_040_init = true;

        Serial.begin(9600);

        success = true;

        break;

      }





    case PLUGIN_SERIAL_IN:

      {

        if (Plugin_040_init)

        {

          byte val = 0;

          byte code[6];

          byte checksum = 0;

          byte bytesread = 0;

          byte tempbyte = 0;



          if ((val = Serial.read()) == 2)

          {

            bytesread = 0;

            while (bytesread < 12) {

              if ( Serial.available() > 0) {

                val = Serial.read();

                if ((val == 0x0D) || (val == 0x0A) || (val == 0x03) || (val == 0x02)) {



                  break;

                }





                if ((val >= '0') && (val <= '9')) {

                  val = val - '0';

                }

                else if ((val >= 'A') && (val <= 'F')) {

                  val = 10 + val - 'A';

                }





                if ( (bytesread & 1) == 1) {





                  code[bytesread >> 1] = (val | (tempbyte << 4));



                  if (bytesread >> 1 != 5) {

                    checksum ^= code[bytesread >> 1];

                  };

                }

                else {

                  tempbyte = val;

                };

                bytesread++;

              }

            }

          }



          if (bytesread == 12)

          {

            if (code[5] == checksum)

            {



              byte index = 0;

              for (byte y = 0; y < TASKS_MAX; y++)

                if (Settings.TaskDeviceNumber[y] == PLUGIN_ID_040)

                  index = y;

              byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[index]);

              event->TaskIndex = index;

              event->BaseVarIndex = index * VARS_PER_TASK;

              event->sensorType = Device[DeviceIndex].VType;





              unsigned long key = 0;

              for (byte i = 1; i < 5; i++) key = key | (((unsigned long) code[i] << ((4 - i) * 8)));

              UserVar[event->BaseVarIndex] = (key & 0xFFFF);

              UserVar[event->BaseVarIndex + 1] = ((key >> 16) & 0xFFFF);

              String log = F("RFID : Tag: ");

              log += key;

              addLog(LOG_LEVEL_INFO, log);

              sendData(event);

            }

          }

          success = true;

        }

        break;

      }



  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P041_NeoClock.ino"
#ifdef USES_P041







#include <Adafruit_NeoPixel.h>



#define NUM_LEDS 114



byte Plugin_041_red = 0;

byte Plugin_041_green = 0;

byte Plugin_041_blue = 0;



Adafruit_NeoPixel *Plugin_041_pixels;



#define PLUGIN_041 

#define PLUGIN_ID_041 41

#define PLUGIN_NAME_041 "Output - NeoPixel (Word Clock)"

#define PLUGIN_VALUENAME1_041 "Clock"

boolean Plugin_041(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_041;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_041);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_041));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormNumericBox(F("Red"), F("plugin_041_red"), Settings.TaskDevicePluginConfig[event->TaskIndex][0], 0, 255);

       addFormNumericBox(F("Green"), F("plugin_041_green"), Settings.TaskDevicePluginConfig[event->TaskIndex][1], 0, 255);

       addFormNumericBox(F("Blue"), F("plugin_041_blue"), Settings.TaskDevicePluginConfig[event->TaskIndex][2], 0, 255);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_041_red"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_041_green"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_041_blue"));

        Plugin_041_red = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Plugin_041_green = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        Plugin_041_blue = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_041_pixels)

        {

          Plugin_041_pixels = new Adafruit_NeoPixel(NUM_LEDS, Settings.TaskDevicePin1[event->TaskIndex], NEO_GRB + NEO_KHZ800);

          Plugin_041_pixels->begin();

        }

        Plugin_041_red = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Plugin_041_green = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        Plugin_041_blue = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        success = true;

        break;

      }



    case PLUGIN_CLOCK_IN:

      {

        Plugin_041_update();

        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {
# 201 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P041_NeoClock.ino"
        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String tmpString = string;

        int argIndex = tmpString.indexOf(',');

        if (argIndex)

          tmpString = tmpString.substring(0, argIndex);



        if (tmpString.equalsIgnoreCase(F("NeoClockColor")))

        {

          Plugin_041_red = event->Par1;

          Plugin_041_green = event->Par2;

          Plugin_041_blue = event->Par3;

          Plugin_041_update();

          success = true;

        }



        if (tmpString.equalsIgnoreCase(F("NeoTestAll")))

        {

          for (int i = 0; i < NUM_LEDS; i++)

            Plugin_041_pixels->setPixelColor(i, Plugin_041_pixels->Color(event->Par1, event->Par2, event->Par3));

          Plugin_041_pixels->show();

          success = true;

        }



        if (tmpString.equalsIgnoreCase(F("NeoTestLoop")))

        {

          for (int i = 0; i < NUM_LEDS; i++)

          {

            resetAndBlack();

            Plugin_041_pixels->setPixelColor(i, Plugin_041_pixels->Color(event->Par1, event->Par2, event->Par3));

            Plugin_041_pixels->show();

            delay(200);

          }

          success = true;

        }



        break;

      }



  }

  return success;

}



void Plugin_041_update()

{

  byte Hours = hour();

  byte Minutes = minute();

  resetAndBlack();

  timeToStrip(Hours, Minutes);

  Plugin_041_pixels->show();

}





void resetAndBlack() {

  for (int i = 0; i < NUM_LEDS; i++) {

    Plugin_041_pixels->setPixelColor(i, Plugin_041_pixels->Color(0, 0, 0));

  }

}



void pushToStrip(int ledId) {

  Plugin_041_pixels->setPixelColor(ledId, Plugin_041_pixels->Color(Plugin_041_red, Plugin_041_green, Plugin_041_blue));

}



void timeToStrip(uint8_t hours, uint8_t minutes)

{

  pushIT_IS();



  if (minutes >= 5 && minutes < 10) {

    pushFIVE1();

    pushAFTER();

  } else if (minutes >= 10 && minutes < 15) {

    pushTEN1();

    pushAFTER();

  } else if (minutes >= 15 && minutes < 20) {

    pushQUATER();

    pushAFTER();

  } else if (minutes >= 20 && minutes < 25) {

    pushTEN1();

    pushFOR();

    pushHALF();

  } else if (minutes >= 25 && minutes < 30) {

    pushFIVE1();

    pushFOR();

    pushHALF();

  } else if (minutes >= 30 && minutes < 35) {

    pushHALF();

  } else if (minutes >= 35 && minutes < 40) {

    pushFIVE1();

    pushAFTER();

    pushHALF();

  } else if (minutes >= 40 && minutes < 45) {

    pushTEN1();

    pushAFTER();

    pushHALF();

  } else if (minutes >= 45 && minutes < 50) {

    pushQUATER();

    pushFOR();

  } else if (minutes >= 50 && minutes < 55) {

    pushTEN1();

    pushFOR();

  } else if (minutes >= 55 && minutes < 60) {

    pushFIVE1();

    pushFOR();

  }



  int singleMinutes = minutes % 5;

  switch (singleMinutes) {

    case 1:

      pushM_ONE();

      break;

    case 2:

      pushM_ONE();

      pushM_TWO();

      break;

    case 3:

      pushM_ONE();

      pushM_TWO();

      pushM_THREE();

      break;

    case 4:

      pushM_ONE();

      pushM_TWO();

      pushM_THREE();

      pushM_FOUR();

      break;

  }

  if (hours >= 12) {

    hours -= 12;

  }

  if (hours == 12) {

    hours = 0;

  }

  if (minutes >= 20) {

    hours++;

  }





  switch (hours) {

    case 0:

      pushTWELVE();

      break;

    case 1:

      pushONE();

      break;

    case 2:

      pushTWO();

      break;

    case 3:

      pushTHREE();

      break;

    case 4:

      pushFOUR();

      break;

    case 5:

      pushFIVE2();

      break;

    case 6:

      pushSIX();

      break;

    case 7:

      pushSEVEN();

      break;

    case 8:

      pushEIGHT();

      break;

    case 9:

      pushNINE();

      break;

    case 10:

      pushTEN();

      break;

    case 11:

      pushELEVEN();

      break;

    case 12:

      pushTWELVE();

      break;

  }



  if (minutes < 5) {

    pushHOURE();

  }

}



void pushM_ONE() {

  pushToStrip(0);

}

void pushM_TWO() {

  pushToStrip(12);

}

void pushM_THREE() {

  pushToStrip(101);

}

void pushM_FOUR() {

  pushToStrip(113);

}

void pushIT_IS() {

  pushToStrip(1);

  pushToStrip(2);

  pushToStrip(3);

  pushToStrip(5);

  pushToStrip(6);

}

void pushAFTER() {

  pushToStrip(36);

  pushToStrip(37);

  pushToStrip(38);

  pushToStrip(39);

}

void pushQUATER() {

  pushToStrip(30);

  pushToStrip(31);

  pushToStrip(32);

  pushToStrip(33);

  pushToStrip(34);

}

void pushFOR() {

  pushToStrip(41);

  pushToStrip(42);

  pushToStrip(43);

  pushToStrip(44);

}

void pushHALF() {

  pushToStrip(50);

  pushToStrip(51);

  pushToStrip(52);

  pushToStrip(53);

}

void pushONE() {

  pushToStrip(63);

  pushToStrip(64);

  pushToStrip(65);

}

void pushTWO() {

  pushToStrip(64);

  pushToStrip(65);

  pushToStrip(66);

  pushToStrip(67);

}

void pushTHREE() {

  pushToStrip(109);

  pushToStrip(110);

  pushToStrip(111);

  pushToStrip(112);

}

void pushFOUR() {

  pushToStrip(57);

  pushToStrip(58);

  pushToStrip(59);

  pushToStrip(60);

}

void pushFIVE1() {

  pushToStrip(8);

  pushToStrip(9);

  pushToStrip(10);

  pushToStrip(11);

}

void pushFIVE2() {

  pushToStrip(92);

  pushToStrip(93);

  pushToStrip(94);

  pushToStrip(95);

}

void pushSIX() {

  pushToStrip(69);

  pushToStrip(88);

  pushToStrip(91);

}

void pushSEVEN() {

  pushToStrip(69);

  pushToStrip(70);

  pushToStrip(71);

  pushToStrip(72);

  pushToStrip(73);

}

void pushEIGHT() {

  pushToStrip(97);

  pushToStrip(98);

  pushToStrip(99);

  pushToStrip(100);

}

void pushNINE() {

  pushToStrip(73);

  pushToStrip(74);

  pushToStrip(75);

  pushToStrip(76);

  pushToStrip(77);

}

void pushTEN() {

  pushToStrip(54);

  pushToStrip(59);

  pushToStrip(76);

  pushToStrip(81);

}

void pushTEN1() {

  pushToStrip(25);

  pushToStrip(26);

  pushToStrip(27);

  pushToStrip(28);

}

void pushELEVEN() {

  pushToStrip(107);

  pushToStrip(108);

  pushToStrip(109);

}

void pushTWELVE() {

  pushToStrip(82);

  pushToStrip(83);

  pushToStrip(84);

  pushToStrip(85);

  pushToStrip(86);

  pushToStrip(87);

}

void pushTWENTY() {

  pushToStrip(16);

  pushToStrip(17);

  pushToStrip(18);

  pushToStrip(19);

  pushToStrip(20);

  pushToStrip(21);

  pushToStrip(22);

}

void pushHOURE() {

  pushToStrip(102);

  pushToStrip(103);

  pushToStrip(104);

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P042_Candle.ino"
#ifdef USES_P042
# 105 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P042_Candle.ino"
#include <Adafruit_NeoPixel.h>



#define NUM_PIXEL 20

#define NUM_PIXEL_ROW 5

#define RANDOM_PIXEL 70

#define BRIGHT_START 128

#define BASE_TEMP 21



enum SimType {

  TypeOff,

  TypeSimpleCandle,

  TypeAdvancedCandle,

  TypeStaticLight,

  TypePolice,

  TypeBlink,

  TypeStrobe,

  TypeColorFader

};



enum ColorType {

  ColorDefault,

  ColorSelected

};



byte Candle_red = 0;

byte Candle_green = 0;

byte Candle_blue = 0;

byte Candle_bright = 128;

SimType Candle_type = TypeSimpleCandle;

ColorType Candle_color = ColorDefault;





unsigned long Candle_Update = 0;

word Candle_Temp[4] = { 0, 0, 0 };

int Candle_Temp4 = 0;

boolean GPIO_Set = false;



Adafruit_NeoPixel *Candle_pixels;



#define PLUGIN_042 

#define PLUGIN_ID_042 42

#define PLUGIN_NAME_042 "Output - NeoPixel (Candle)"

#define PLUGIN_VALUENAME1_042 "Color"

#define PLUGIN_VALUENAME2_042 "Brightness"

#define PLUGIN_VALUENAME3_042 "Type"



boolean Plugin_042(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_042;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_042);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_042));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_042));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_042));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addHtml(F("<script src=\"jscolor.min.js\"></script>\n"));



        char tmpString[128];

        String options[8];





        options[0] = F("Off");

        options[1] = F("Static Light");

        options[2] = F("Simple Candle");

        options[3] = F("Advanced Candle");

        options[4] = F("Police");

        options[5] = F("Blink");

        options[6] = F("Strobe");

        options[7] = F("Color Fader");



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][4];

        if (choice > sizeof(options) - 1)

        {

          choice = 2;

        }





        addFormSelector(F("Flame Type"), F("web_Candle_Type"), 8, options, NULL, choice);





        Candle_color = (ColorType)Settings.TaskDevicePluginConfig[event->TaskIndex][5];

        addHtml(F("<TR><TD>Color Handling:<TD>"));

        addHtml(F("<input type='radio' id='web_Color_Default' name='web_Color_Type' value='0'"));

        if (Candle_color == ColorDefault) {

          addHtml(F(" checked>"));

        } else {

          addHtml(F(">"));

        }

        addHtml(F("<label for='web_Color_Default'> Use default color</label><br>"));

        addHtml(F("<input type='radio' id='web_Color_Selected' name='web_Color_Type' value='1'"));

        if (Candle_color == ColorSelected) {

          addHtml(F(" checked>"));

        } else {

          addHtml(F(">"));

        }

        addHtml(F("<label for='web_Color_Selected'> Use selected color</label><br>"));





        char hexvalue[7] = {0};

        sprintf(hexvalue, "%02X%02X%02X",

                Settings.TaskDevicePluginConfig[event->TaskIndex][0],

                Settings.TaskDevicePluginConfig[event->TaskIndex][1],

                Settings.TaskDevicePluginConfig[event->TaskIndex][2]);





        addHtml(F("<TR><TD>Color:<TD><input class=\"jscolor {onFineChange:'update(this)'}\" value='"));

        addHtml(hexvalue);

        addHtml(F("'>"));

        addFormNumericBox(F("RGB Color"), F("web_RGB_Red"), Settings.TaskDevicePluginConfig[event->TaskIndex][0], 0, 255);

        addNumericBox(F("web_RGB_Green"), Settings.TaskDevicePluginConfig[event->TaskIndex][1], 0, 255);

        addNumericBox(F("web_RGB_Blue"), Settings.TaskDevicePluginConfig[event->TaskIndex][2], 0, 255);





        addHtml(F("<TR><TD>Brightness:<TD>min<input type='range' id='web_Bright_Slide' min='0' max='255' value='"));

        addHtml(String(Settings.TaskDevicePluginConfig[event->TaskIndex][3]));

        addHtml(F("'> max"));



        sprintf_P(tmpString, PSTR("<TR><TD>Brightness Value:<TD><input type='text' name='web_Bright_Text' id='web_Bright_Text' size='3' value='%u'>"), Settings.TaskDevicePluginConfig[event->TaskIndex][3]);

        addHtml(tmpString);





        addHtml(F("<script script type='text/javascript'>"));

        addHtml(F("function update(picker) {"));

        addHtml(F("    document.getElementById('web_RGB_Red').value = Math.round(picker.rgb[0]);"));

        addHtml(F("    document.getElementById('web_RGB_Green').value = Math.round(picker.rgb[1]);"));

        addHtml(F("    document.getElementById('web_RGB_Blue').value = Math.round(picker.rgb[2]);"));

        addHtml(F("}"));

        addHtml(F("</script>"));



        addHtml(F("<script type='text/javascript'>window.addEventListener('load', function(){"));

        addHtml(F("var slider = document.getElementById('web_Bright_Slide');"));

        addHtml(F("slider.addEventListener('change', function(){"));

        addHtml(F("document.getElementById('web_Bright_Text').value = this.value;"));

        addHtml(F("});"));

        addHtml(F("});</script>"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("web_RGB_Red"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("web_RGB_Green"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("web_RGB_Blue"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("web_Bright_Text"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][4] = getFormItemInt(F("web_Candle_Type"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][5] = getFormItemInt(F("web_Color_Type"));



        Candle_red = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Candle_green = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        Candle_blue = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        if (Candle_bright > 255) {

          Candle_bright = 255;

        }

        Candle_bright = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

        Candle_type = (SimType)Settings.TaskDevicePluginConfig[event->TaskIndex][4];

        Candle_color = (ColorType)Settings.TaskDevicePluginConfig[event->TaskIndex][5];



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Candle_red = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Candle_green = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        Candle_blue = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        Candle_bright = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

        if (Candle_red == 0 && Candle_green == 0 && Candle_blue == 0) {

          Candle_bright = BRIGHT_START;

        }

        Candle_type = (SimType)Settings.TaskDevicePluginConfig[event->TaskIndex][4];

        Candle_color = (ColorType)Settings.TaskDevicePluginConfig[event->TaskIndex][5];



        if (!Candle_pixels || GPIO_Set == false)

        {

          GPIO_Set = Settings.TaskDevicePin1[event->TaskIndex] > -1;

          if (Candle_pixels) {

            delete Candle_pixels;

          }

          Candle_pixels = new Adafruit_NeoPixel(NUM_PIXEL, Settings.TaskDevicePin1[event->TaskIndex], NEO_GRB + NEO_KHZ800);

          SetPixelsBlack();

          Candle_pixels->setBrightness(Candle_bright);

          Candle_pixels->begin();

          String log = F("CAND : Init WS2812 Pin : ");

          log += Settings.TaskDevicePin1[event->TaskIndex];

          addLog(LOG_LEVEL_DEBUG, log);

        }



        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        Candle_pixels->setBrightness(Candle_bright);

        Candle_pixels->show();

        success = true;

        break;

      }



    case PLUGIN_FIFTY_PER_SECOND:

      {

        switch (Candle_type)

        {

          case 0:

            {

              type_Off();

              break;

            }



          case 1:

            {

              type_Static_Light();

              break;

            }



          case 2:

          case 3:

            {

              if (timeOutReached(Candle_Update)) {

                if (Candle_type == 2) {

                  type_Simple_Candle();

                }

                if (Candle_type == 3) {

                  type_Advanced_Candle();

                }

                Candle_Update = millis() + random(25, 150);

              }

              break;

            }



          case 4:

            {

              if (timeOutReached(Candle_Update)) {

                type_Police();

                Candle_Update = millis() + 150;

              }

              break;

            }



          case 5:

            {

              if (timeOutReached(Candle_Update)) {

                type_BlinkStrobe();

                Candle_Update = millis() + 100;

              }

              break;

            }



          case 6:

            {

              type_BlinkStrobe();

              break;

            }

          case 7:

            {

              if (timeOutReached(Candle_Update)) {

                type_ColorFader();

                Candle_Update = millis() + 2000;

              }

              break;

            }

        }



        Candle_pixels->show();



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        UserVar[event->BaseVarIndex] = Candle_red * 65536 + Candle_green * 256 + Candle_blue;

        UserVar[event->BaseVarIndex + 1] = Candle_bright;

        UserVar[event->BaseVarIndex + 2] = Candle_type;



        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String tmpString = string;
# 771 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P042_Candle.ino"
        if (tmpString.startsWith(F("CANDLE:"))){

          int idx1 = tmpString.indexOf(':');

          int idx2 = tmpString.indexOf(':', idx1+1);

          int idx3 = tmpString.indexOf(':', idx2+1);

          int idx4 = tmpString.indexOf(':', idx3+1);

          String val_Type = tmpString.substring(idx1+1, idx2);

          String val_Color = tmpString.substring(idx2+1, idx3);

          String val_Bright = tmpString.substring(idx3+1, idx4);



          if (val_Type != "") {

             if (val_Type.toInt() > -1 && val_Type.toInt() < 8) {

                Settings.TaskDevicePluginConfig[event->TaskIndex][4] = val_Type.toInt();

                Candle_type = (SimType)Settings.TaskDevicePluginConfig[event->TaskIndex][4];

                String log = F("CAND : CMD - Type : ");

                log += val_Type;

                addLog(LOG_LEVEL_DEBUG, log);

             }

          }



          if (val_Bright != "") {

             if (val_Bright.toInt() > -1 && val_Bright.toInt() < 256) {

                Settings.TaskDevicePluginConfig[event->TaskIndex][3] = val_Bright.toInt();

                Candle_bright = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

                String log = F("CAND : CMD - Bright : ");

                log += val_Bright;

                addLog(LOG_LEVEL_DEBUG, log);

             }

          }



          if (val_Color != "") {

            long number = strtol( &val_Color[0], NULL, 16);



            byte r = number >> 16;

            byte g = number >> 8 & 0xFF;

            byte b = number & 0xFF;



            Settings.TaskDevicePluginConfig[event->TaskIndex][0] = r;

            Settings.TaskDevicePluginConfig[event->TaskIndex][1] = g;

            Settings.TaskDevicePluginConfig[event->TaskIndex][2] = b;

            Candle_red = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

            Candle_green = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

            Candle_blue = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

            Settings.TaskDevicePluginConfig[event->TaskIndex][5] = 1;

            Candle_color = (ColorType)Settings.TaskDevicePluginConfig[event->TaskIndex][5];



            String log = F("CAND : CMD - R ");

            log += r;

            log += F(" G ");

            log += g;

            log += F(" B ");

            log += b;

            addLog(LOG_LEVEL_DEBUG, log);

          } else {

            Settings.TaskDevicePluginConfig[event->TaskIndex][5] = 0;

            Candle_color = (ColorType)Settings.TaskDevicePluginConfig[event->TaskIndex][5];

            addLog(LOG_LEVEL_DEBUG, F("CAND : CMD - Color : DEFAULT"));

          }
# 893 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P042_Candle.ino"
          success = true;

        }



        break;

      }



  }

  return success;

}



void SetPixelsBlack() {

  for (int i = 0; i < NUM_PIXEL; i++) {

    Candle_pixels->setPixelColor(i, Candle_pixels->Color(0, 0, 0));

  }

}



void SetPixelToColor(int PixelIdx) {

  Candle_pixels->setPixelColor(PixelIdx, Candle_pixels->Color(Candle_red, Candle_green, Candle_blue));

}



void type_Off() {

  SetPixelsBlack();

}



void type_Static_Light() {

  for (int i = 0; i < NUM_PIXEL; i++) {

    if (Candle_color == ColorDefault) {

      Candle_pixels->setPixelColor(i, 255, 255, 255);

    } else {

      Candle_pixels->setPixelColor(i, Candle_red, Candle_green, Candle_blue);

    }

  }

}



void type_Simple_Candle() {

  int r, g, b;

  if (Candle_color == ColorDefault) {

    r = 226, g = 042, b = 35;





  } else {

    r = Candle_red, g = Candle_green, b = Candle_blue;

  }





  for (int i = 0; i < NUM_PIXEL; i++) {

    int flicker = random(0, RANDOM_PIXEL);

    int r1 = r - flicker;

    int g1 = g - flicker;

    int b1 = b - flicker;

    if (g1 < 0) g1 = 0;

    if (r1 < 0) r1 = 0;

    if (b1 < 0) b1 = 0;

    Candle_pixels->setPixelColor(i, r1, g1, b1);

  }

}



void type_Advanced_Candle() {

  Candle_Temp[0] = random(1, 4);

  Candle_Temp[1] = random(1, 4) + Candle_Temp[0];

  Candle_Temp[2] = random(0, 2);



  int colorbase[3];

  int color1[3];

  int color2[3];

  int color3[3];



  if (Candle_color == ColorDefault) {

    colorbase[0] = 255; colorbase[1] = 120; colorbase[2] = 0;

    color1[0] = 115; color1[1] = 50; color1[2] = 0;

    color2[0] = 180; color2[1] = 80; color2[2] = 0;

    color3[0] = 70; color3[1] = 30; color3[2] = 0;

  } else {

    colorbase[0] = Candle_red; colorbase[1] = Candle_green; colorbase[2] = Candle_blue;

    double hsv[3];



    RGBtoHSV(Candle_red, Candle_green, Candle_blue, hsv);

    double newH = hsv[0] - 5;

    if (newH < 0) { newH += 359; }

    double newV = hsv[2] / 2;

    double newV2 = hsv[2] / 4;



    HSVtoRGB(newH, hsv[1], hsv[2], color1);

    HSVtoRGB(hsv[0], hsv[1], newV, color2);

    HSVtoRGB(newH, hsv[1], newV2, color3);

  }



  for (int j = 0; j < 4; j++) {

    for (unsigned int i = 1; i < 6; i++){

      if (i <= Candle_Temp[0]) {

        Candle_pixels->setPixelColor(j * 5 + i - 1, colorbase[0], colorbase[1], colorbase[2]);

      }

      if (i > Candle_Temp[0] && i <= Candle_Temp[1]) {

        if (Candle_Temp[2] == 0){

          Candle_pixels->setPixelColor(j * 5 + i - 1, color1[0], color1[1], color1[2]);

        } else {

          Candle_pixels->setPixelColor(j * 5 + i - 1, color2[0], color2[1], color2[2]);

        }

      }

      if (i > Candle_Temp[1]) {

        Candle_pixels->setPixelColor(j * 5 + i - 1, color3[0], color3[1], color3[2]);

      }

    }

  }

}



void type_Police() {

  Candle_Temp[0]++;

  if (Candle_Temp[0] > 3) {

    Candle_Temp[0] = 0;

  }



  for (unsigned int i = 0; i < 4; i++) {

    if (i == Candle_Temp[0])

    {

      for (int j = 0; j < 5; j++) {

        if (Candle_color == ColorDefault) {

          Candle_pixels->setPixelColor(i * 5 + j, 0, 0, 255);

        } else {

          Candle_pixels->setPixelColor(i * 5 + j, Candle_red, Candle_green, Candle_blue);

        }

      }

    } else {

      for (int j = 0; j < 5; j++) {

        Candle_pixels->setPixelColor(i * 5 + j, 0, 0, 0);

      }

    }

  }

}



void type_BlinkStrobe() {

  Candle_Temp[0]++;

  if (Candle_Temp[0] > 1) {

    Candle_Temp[0] = 0;

  }



  for (int i = 0; i < NUM_PIXEL; i++) {

    if (Candle_Temp[0] == 0) {

      Candle_pixels->setPixelColor(i, 0, 0, 0);

    } else {

      if (Candle_color == ColorDefault) {

        Candle_pixels->setPixelColor(i, 255, 255, 255);

      } else {

        Candle_pixels->setPixelColor(i, Candle_red, Candle_green, Candle_blue);

      }

    }

  }

}



void type_ColorFader() {

  int colors[3];

  double hsv[3];

  if (Candle_color != ColorDefault) {

    if (Candle_Temp[0] > 254 && Candle_Temp[1] == 1) {

      Candle_Temp[1] = 0;

    }

    if (Candle_Temp[0] < 55 && Candle_Temp[1] == 0) {

      Candle_Temp[1] = 1;

    }



    if (Candle_Temp[1] > 0) {

      Candle_Temp[0]++;

    } else {

      Candle_Temp[0]--;

    }







    RGBtoHSV(Candle_red, Candle_green, Candle_blue, hsv);
# 1239 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P042_Candle.ino"
    HSVtoRGB(hsv[0], hsv[1], Candle_Temp[0], colors);



    for (int i = 0; i < NUM_PIXEL; i++) {

      Candle_pixels->setPixelColor(i, colors[0], colors[1], colors[2]);

    }

  } else {

    Candle_Temp[0]++;

    if (Candle_Temp[0] > 359) {

      Candle_Temp[0] = 0;

    }





    HSVtoRGB(Candle_Temp[0], 255, 255, colors);



    for (int i = 0; i < NUM_PIXEL; i++) {

      Candle_pixels->setPixelColor(i, colors[0], colors[1], colors[2]);

    }

  }

}





void HSVtoRGB(int hue, int sat, int val, int colors[3]) {



  int r=0, g=0, b=0, base=0;



  if (sat == 0) {

    colors[0]=val;

    colors[1]=val;

    colors[2]=val;

  }

  else {

    base = ((255 - sat) * val)>>8;

    switch(hue/60) {

    case 0:

      r = val;

      g = (((val-base)*hue)/60)+base;

      b = base;

      break;

    case 1:

      r = (((val-base)*(60-(hue%60)))/60)+base;

      g = val;

      b = base;

      break;

    case 2:

      r = base;

      g = val;

      b = (((val-base)*(hue%60))/60)+base;

      break;

    case 3:

      r = base;

      g = (((val-base)*(60-(hue%60)))/60)+base;

      b = val;

      break;

    case 4:

      r = (((val-base)*(hue%60))/60)+base;

      g = base;

      b = val;

      break;

    case 5:

      r = val;

      g = base;

      b = (((val-base)*(60-(hue%60)))/60)+base;

      break;

    }

    colors[0]=r;

    colors[1]=g;

    colors[2]=b;

  }

}





void RGBtoHSV(byte r, byte g, byte b, double hsv[3]) {

    double rd = (double) r/255;

    double gd = (double) g/255;

    double bd = (double) b/255;

    double maxval = rd;

    if (gd > maxval) { maxval = gd; }

    if (bd > maxval) { maxval = bd; }

    double minval = rd;

    if (gd < minval) { minval = gd; }

    if (bd < minval) { minval = bd; }

    double h = 0, s, v = maxval;

    double d = maxval - minval;



    s = maxval == 0 ? 0 : d / maxval;



    if (maxval == minval) {

        h = 0;

    } else {

        if (maxval == rd) {

            h = (gd - bd) / d + (gd < bd ? 6 : 0);

        } else if (maxval == gd) {

            h = (bd - rd) / d + 2;

        } else if (maxval == bd) {

            h = (rd - gd) / d + 4;

        }

        h /= 6;

    }



    hsv[0] = h * 360;

    hsv[1] = s * 255;

    hsv[2] = v * 255;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P043_ClkOutput.ino"
#ifdef USES_P043







#define PLUGIN_043 

#define PLUGIN_ID_043 43

#define PLUGIN_NAME_043 "Output - Clock"

#define PLUGIN_VALUENAME1_043 "Output"

#define PLUGIN_043_MAX_SETTINGS 8



boolean Plugin_043(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_043;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_043);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_043));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        String options[3];

        options[0] = F("");

        options[1] = F("Off");

        options[2] = F("On");



        for (byte x = 0; x < PLUGIN_043_MAX_SETTINGS; x++)

        {

         addFormTextBox(String(F("Day,Time ")) + (x + 1), String(F("plugin_043_clock")) + (x), timeLong2String(ExtraTaskSettings.TaskDevicePluginConfigLong[x]), 32);
# 123 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P043_ClkOutput.ino"
          addHtml(F(" "));

          byte choice = ExtraTaskSettings.TaskDevicePluginConfig[x];

          addSelector(String(F("plugin_043_state")) + (x), 3, options, NULL, NULL, choice, false);

        }

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        for (byte x = 0; x < PLUGIN_043_MAX_SETTINGS; x++)

        {

          String argc = F("plugin_043_clock");

          argc += x;

          String plugin1 = WebServer.arg(argc);

          ExtraTaskSettings.TaskDevicePluginConfigLong[x] = string2TimeLong(plugin1);



          argc = F("plugin_043_state");

          argc += x;

          String plugin2 = WebServer.arg(argc);

          ExtraTaskSettings.TaskDevicePluginConfig[x] = plugin2.toInt();

        }

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        success = true;

        break;

      }



    case PLUGIN_CLOCK_IN:

      {

        LoadTaskSettings(event->TaskIndex);

        for (byte x = 0; x < PLUGIN_043_MAX_SETTINGS; x++)

        {

          unsigned long clockEvent = (unsigned long)minute() % 10 | (unsigned long)(minute() / 10) << 4 | (unsigned long)(hour() % 10) << 8 | (unsigned long)(hour() / 10) << 12 | (unsigned long)weekday() << 16;

          unsigned long clockSet = ExtraTaskSettings.TaskDevicePluginConfigLong[x];



          if (matchClockEvent(clockEvent,clockSet))

          {

            byte state = ExtraTaskSettings.TaskDevicePluginConfig[x];

            if (state != 0)

            {

              state--;

              pinMode(Settings.TaskDevicePin1[event->TaskIndex], OUTPUT);

              digitalWrite(Settings.TaskDevicePin1[event->TaskIndex], state);

              UserVar[event->BaseVarIndex] = state;

              String log = F("TCLK : State ");

              log += state;

              addLog(LOG_LEVEL_INFO, log);

              sendData(event);

            }

          }

        }

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P044_P1WifiGateway.ino"
#ifdef USES_P044
# 23 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P044_P1WifiGateway.ino"
#define PLUGIN_044 

#define PLUGIN_ID_044 44

#define PLUGIN_NAME_044 "Communication - P1 Wifi Gateway"

#define PLUGIN_VALUENAME1_044 "P1WifiGateway"



#define P044_STATUS_LED 12

#define P044_BUFFER_SIZE 1024

#define P044_NETBUF_SIZE 128

#define P044_DISABLED 0

#define P044_WAITING 1

#define P044_READING 2

#define P044_CHECKSUM 3

#define P044_DONE 4



boolean Plugin_044_init = false;

boolean serialdebug = false;

char* Plugin_044_serial_buf;

unsigned int bytes_read = 0;

boolean CRCcheck = false;

unsigned int currCRC = 0;

int checkI = 0;



WiFiServer *P1GatewayServer = nullptr;

WiFiClient P1GatewayClient;



boolean Plugin_044(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static byte connectionState = 0;

  static int state = P044_DISABLED;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_044;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].Custom = true;

        Device[deviceCount].TimerOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_044);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_044));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormNumericBox(F("TCP Port"), F("plugin_044_port"), ExtraTaskSettings.TaskDevicePluginConfigLong[0]);

       addFormNumericBox(F("Baud Rate"), F("plugin_044_baud"), ExtraTaskSettings.TaskDevicePluginConfigLong[1]);

       addFormNumericBox(F("Data bits"), F("plugin_044_data"), ExtraTaskSettings.TaskDevicePluginConfigLong[2]);



        byte choice = ExtraTaskSettings.TaskDevicePluginConfigLong[3];

        String options[3];

        options[0] = F("No parity");

        options[1] = F("Even");

        options[2] = F("Odd");

        int optionValues[3] = { 0, 2, 3 };

        addFormSelector(F("Parity"), F("plugin_044_parity"), 3, options, optionValues, choice);



       addFormNumericBox(F("Stop bits"), F("plugin_044_stop"), ExtraTaskSettings.TaskDevicePluginConfigLong[4]);



       addFormPinSelect(F("Reset target after boot"), F("taskdevicepin1"), Settings.TaskDevicePin1[event->TaskIndex]);



       addFormNumericBox(F("RX Receive Timeout (mSec)"), F("plugin_044_rxwait"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        ExtraTaskSettings.TaskDevicePluginConfigLong[0] = getFormItemInt(F("plugin_044_port"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[1] = getFormItemInt(F("plugin_044_baud"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[2] = getFormItemInt(F("plugin_044_data"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[3] = getFormItemInt(F("plugin_044_parity"));

        ExtraTaskSettings.TaskDevicePluginConfigLong[4] = getFormItemInt(F("plugin_044_stop"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_044_rxwait"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        pinMode(P044_STATUS_LED, OUTPUT);

        digitalWrite(P044_STATUS_LED, 0);



        LoadTaskSettings(event->TaskIndex);

        if ((ExtraTaskSettings.TaskDevicePluginConfigLong[0] != 0) && (ExtraTaskSettings.TaskDevicePluginConfigLong[1] != 0))

        {

          #if defined(ESP8266)

            byte serialconfig = 0x10;

          #endif

          #if defined(ESP32)

            uint32_t serialconfig = 0x8000010;

          #endif

          serialconfig += ExtraTaskSettings.TaskDevicePluginConfigLong[3];

          serialconfig += (ExtraTaskSettings.TaskDevicePluginConfigLong[2] - 5) << 2;

          if (ExtraTaskSettings.TaskDevicePluginConfigLong[4] == 2)

            serialconfig += 0x20;

          #if defined(ESP8266)

            Serial.begin(ExtraTaskSettings.TaskDevicePluginConfigLong[1], (SerialConfig)serialconfig);

          #endif

          #if defined(ESP32)

            Serial.begin(ExtraTaskSettings.TaskDevicePluginConfigLong[1], serialconfig);

          #endif

          if (P1GatewayServer)

          {

            P1GatewayServer->close();

            delete P1GatewayServer;

          }

          P1GatewayServer = new WiFiServer(ExtraTaskSettings.TaskDevicePluginConfigLong[0]);

          P1GatewayServer->begin();



          if (!Plugin_044_serial_buf)

            Plugin_044_serial_buf = (char *)malloc(P044_BUFFER_SIZE);



          if (Settings.TaskDevicePin1[event->TaskIndex] != -1)

          {

            pinMode(Settings.TaskDevicePin1[event->TaskIndex], OUTPUT);

            digitalWrite(Settings.TaskDevicePin1[event->TaskIndex], LOW);

            delay(500);

            digitalWrite(Settings.TaskDevicePin1[event->TaskIndex], HIGH);

            pinMode(Settings.TaskDevicePin1[event->TaskIndex], INPUT_PULLUP);

          }



          Plugin_044_init = true;

        }



        blinkLED();



        if (ExtraTaskSettings.TaskDevicePluginConfigLong[1] == 115200) {

          addLog(LOG_LEVEL_DEBUG, F("P1   : DSMR version 4 meter, CRC on"));

          CRCcheck = true;

        } else {

          addLog(LOG_LEVEL_DEBUG, F("P1   : DSMR version 4 meter, CRC off"));

          CRCcheck = false;

        }





        state = P044_WAITING;

        success = true;

        break;

      }



    case PLUGIN_EXIT:

      {

        if (P1GatewayServer) {

          P1GatewayServer->close();

          delete P1GatewayServer;

          P1GatewayServer = NULL;

        }

        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_044_init)

        {

          if (P1GatewayServer->hasClient())

          {

            if (P1GatewayClient) P1GatewayClient.stop();

            P1GatewayClient = P1GatewayServer->available();

            addLog(LOG_LEVEL_ERROR, F("P1   : Client connected!"));

          }



          if (P1GatewayClient.connected())

          {

            connectionState = 1;

            uint8_t net_buf[P044_NETBUF_SIZE];

            int count = P1GatewayClient.available();

            if (count > 0)

            {

              size_t net_bytes_read;

              if (count > P044_NETBUF_SIZE)

                count = P044_NETBUF_SIZE;

              net_bytes_read = P1GatewayClient.read(net_buf, count);

              Serial.write(net_buf, net_bytes_read);

              Serial.flush();



              if (count == P044_NETBUF_SIZE)

              {

                count--;



                addLog(LOG_LEVEL_ERROR, F("P1   : Error: network buffer full!"));

              }

              net_buf[count] = 0;

              char log[P044_NETBUF_SIZE + 40];

              sprintf_P(log, PSTR("P1   : Error: N>: %s"), (char*)net_buf);

              addLog(LOG_LEVEL_DEBUG, log);

            }

          }

          else

          {

            if (connectionState == 1)

            {

              connectionState = 0;

              addLog(LOG_LEVEL_ERROR, F("P1   : Client disconnected!"));

            }



            while (Serial.available())

              Serial.read();

          }



          success = true;

        }

        break;

      }



    case PLUGIN_SERIAL_IN:

      {

        if (Plugin_044_init)

        {

          if (P1GatewayClient.connected())

          {

            int RXWait = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

            if (RXWait == 0)

              RXWait = 1;

            int timeOut = RXWait;

            while (timeOut > 0)

            {

              while (Serial.available() && state != P044_DONE) {

                if (bytes_read < P044_BUFFER_SIZE - 5) {

                  char ch = Serial.read();

                  digitalWrite(P044_STATUS_LED, 1);

                  switch (state) {

                    case P044_DISABLED:

                      break;

                    case P044_WAITING:

                      if (ch == '/') {

                        Plugin_044_serial_buf[0] = ch;

                        bytes_read=1;

                        state = P044_READING;

                      }

                      break;

                    case P044_READING:

                      if (ch == '!') {

                        if (CRCcheck) {

                          state = P044_CHECKSUM;

                        } else {

                          state = P044_DONE;

                        }

                      }

                      if (validP1char(ch)) {

                        Plugin_044_serial_buf[bytes_read] = ch;

                        bytes_read++;

                      } else if (ch=='/') {

                        addLog(LOG_LEVEL_DEBUG, F("P1   : Error: Start detected, discarded input."));

                        Plugin_044_serial_buf[0] = ch;

                        bytes_read = 1;

                      } else {

                        addLog(LOG_LEVEL_DEBUG, F("P1   : Error: DATA corrupt, discarded input."));

                        Serial.flush();

                        bytes_read = 0;

                        state = P044_WAITING;

                      }

                      break;

                    case P044_CHECKSUM:

                      checkI ++;

                      if (checkI == 4) {

                        checkI = 0;

                        state = P044_DONE;

                      }

                      Plugin_044_serial_buf[bytes_read] = ch;

                      bytes_read++;

                      break;

                    case P044_DONE:







                      break;

                  }

                }

                else

                {

                  Serial.read();

                  bytes_read = 0;

                  state = P044_WAITING;

                }

                digitalWrite(P044_STATUS_LED, 0);

                timeOut = RXWait;

              }

              delay(1);

              timeOut--;

            }



            if (state == P044_DONE) {

              if (checkDatagram(bytes_read)) {

                Plugin_044_serial_buf[bytes_read] = '\r';

                bytes_read++;

                Plugin_044_serial_buf[bytes_read] = '\n';

                bytes_read++;

                Plugin_044_serial_buf[bytes_read] = 0;

                P1GatewayClient.write((const uint8_t*)Plugin_044_serial_buf, bytes_read);

                P1GatewayClient.flush();

                addLog(LOG_LEVEL_DEBUG, F("P1   : data send!"));

                blinkLED();



                if (Settings.UseRules)

                {

                  LoadTaskSettings(event->TaskIndex);

                  String eventString = getTaskDeviceName(event->TaskIndex);

                  eventString += F("#Data");

                  rulesProcessing(eventString);

                }



              } else {

                addLog(LOG_LEVEL_DEBUG, F("P1   : Error: Invalid CRC, dropped data"));

              }



              bytes_read = 0;

              state = P044_WAITING;

            }

          }

          success = true;

        }

        break;

      }



  }

  return success;

}

void blinkLED() {

  digitalWrite(P044_STATUS_LED, 1);

  delay(500);

  digitalWrite(P044_STATUS_LED, 0);

}
# 707 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P044_P1WifiGateway.ino"
bool validP1char(char ch) {

  if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch == '.') || (ch == '!') || (ch == ' ') || (ch == 92) || (ch == 13) || (ch == '\n') || (ch == '(') || (ch == ')') || (ch == '-') || (ch == '*') || (ch == ':') )

  {

    return true;

  } else {

    addLog(LOG_LEVEL_DEBUG, F("P1   : Error: invalid char read from P1"));

    if (serialdebug) {

      Serial.print(F("faulty char>"));

      Serial.print(ch);

      Serial.println(F("<"));

    }

    return false;

  }

}



int FindCharInArrayRev(char array[], char c, int len) {

  for (int i = len - 1; i >= 0; i--) {

    if (array[i] == c) {

      return i;

    }

  }

  return -1;

}
# 765 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P044_P1WifiGateway.ino"
unsigned int CRC16(unsigned int crc, unsigned char *buf, int len)

{

  for (int pos = 0; pos < len; pos++)

  {

    crc ^= (unsigned int)buf[pos];



    for (int i = 8; i != 0; i--) {

      if ((crc & 0x0001) != 0) {

        crc >>= 1;

        crc ^= 0xA001;

      }

      else

        crc >>= 1;

    }

  }



  return crc;

}
# 815 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P044_P1WifiGateway.ino"
bool checkDatagram(int len) {

  int startChar = FindCharInArrayRev(Plugin_044_serial_buf, '/', len);

  int endChar = FindCharInArrayRev(Plugin_044_serial_buf, '!', len);

  bool validCRCFound = false;



  if (!CRCcheck) return true;



  if (serialdebug) {

    Serial.print(F("input length: "));

    Serial.println(len);

    Serial.print("Start char \\ : ");

    Serial.println(startChar);

    Serial.print(F("End char ! : "));

    Serial.println(endChar);

  }



  if (endChar >= 0)

  {

    currCRC = CRC16(0x0000, (unsigned char *) Plugin_044_serial_buf, endChar - startChar + 1);



    char messageCRC[5];

    strncpy(messageCRC, Plugin_044_serial_buf + endChar + 1, 4);

    messageCRC[4] = 0;

    if (serialdebug) {

      for (int cnt = 0; cnt < len; cnt++)

        Serial.print(Plugin_044_serial_buf[cnt]);

    }



    validCRCFound = (strtoul(messageCRC, NULL, 16) == currCRC);

    if (!validCRCFound) {

      addLog(LOG_LEVEL_DEBUG, F("P1   : Error: invalid CRC found"));

    }

    currCRC = 0;

  }

  return validCRCFound;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P045_MPU6050.ino"
#ifdef USES_P045
# 117 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P045_MPU6050.ino"
#define MPU6050_RA_GYRO_CONFIG 0x1B

#define MPU6050_RA_ACCEL_CONFIG 0x1C

#define MPU6050_RA_ACCEL_XOUT_H 0x3B

#define MPU6050_RA_PWR_MGMT_1 0x6B

#define MPU6050_ACONFIG_AFS_SEL_BIT 4

#define MPU6050_ACONFIG_AFS_SEL_LENGTH 2

#define MPU6050_GCONFIG_FS_SEL_BIT 4

#define MPU6050_GCONFIG_FS_SEL_LENGTH 2

#define MPU6050_CLOCK_PLL_XGYRO 0x01

#define MPU6050_GYRO_FS_250 0x00

#define MPU6050_ACCEL_FS_2 0x00

#define MPU6050_PWR1_SLEEP_BIT 6

#define MPU6050_PWR1_CLKSEL_BIT 2

#define MPU6050_PWR1_CLKSEL_LENGTH 3



#define PLUGIN_045 

#define PLUGIN_ID_045 45

#define PLUGIN_NAME_045 "Gyro - MPU 6050 [TESTING]"

#define PLUGIN_VALUENAME1_045 ""



int16_t _P045_axis[3][5][2];

unsigned long _P045_time[2];



boolean Plugin_045(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_045;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].FormulaOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_045);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_045));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {



        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];
# 243 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P045_MPU6050.ino"
        int optionValues[2];

        optionValues[0] = 0x68;

        optionValues[1] = 0x69;

        addFormSelectorI2C(F("plugin_045_address"), 2, optionValues, choice);

        addFormNote(F("ADDR Low=0x68, High=0x69"));



        choice = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String options[10];

        options[0] = F("Movement detection");

        options[1] = F("Range acceleration X");

        options[2] = F("Range acceleration Y");

        options[3] = F("Range acceleration Z");

        options[4] = F("Acceleration X");

        options[5] = F("Acceleration Y");

        options[6] = F("Acceleration Z");

        options[7] = F("G-force X");

        options[8] = F("G-force Y");

        options[9] = F("G-force Z");

        addFormSelector(F("Function"), F("plugin_045_function"), 10, options, NULL, choice);



        if (choice == 0) {





          addHtml(F("<TR><TD><TD>The thresholdvalues (0-65535) can be used to set a threshold for one or more<br>"));

          addHtml(F("axis. The axis will trigger when the range for that axis exceeds the threshold<br>"));

          addHtml(F("value. A value of 0 disables movement detection for that axis."));



         addFormNumericBox(F("Detection threshold X"), F("plugin_045_threshold_x"), Settings.TaskDevicePluginConfig[event->TaskIndex][2], 0, 65535);

         addFormNumericBox(F("Detection threshold Y"), F("plugin_045_threshold_y"), Settings.TaskDevicePluginConfig[event->TaskIndex][3], 0, 65535);

         addFormNumericBox(F("Detection threshold Z"), F("plugin_045_threshold_z"), Settings.TaskDevicePluginConfig[event->TaskIndex][4], 0, 65535);



          addHtml(F("<TR><TD><TD>Each 30 seconds a counter for the detection window is increased plus all axis<br>"));

          addHtml(F("are checked and if they *all* exceeded the threshold values, a counter is increased.<br>"));

          addHtml(F("Each period, defined by the [detection window], the counter is checked against<br>"));

          addHtml(F("the [min. detection count] and if found equal or larger, movement is detected.<br>"));

          addHtml(F("If in the next window the [min. detection count] value is not met, movement has stopped."));

          addHtml(F("The [detection window] cannot be smaller than the [min. detection count]."));



         addFormNumericBox(F("Min. detection count"), F("plugin_045_threshold_counter"), Settings.TaskDevicePluginConfig[event->TaskIndex][5], 0, 999999);

         addFormNumericBox(F("Detection window"), F("plugin_045_threshold_window"), Settings.TaskDevicePluginConfig[event->TaskIndex][6], 0, 999999);



        }

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {



        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_045_address"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_045_function"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_045_threshold_x"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("plugin_045_threshold_y"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][4] = getFormItemInt(F("plugin_045_threshold_z"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][5] = getFormItemInt(F("plugin_045_threshold_counter"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][6] = getFormItemInt(F("plugin_045_threshold_window"));

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][6] < Settings.TaskDevicePluginConfig[event->TaskIndex][5]) {

          Settings.TaskDevicePluginConfig[event->TaskIndex][6] = Settings.TaskDevicePluginConfig[event->TaskIndex][5];

        }

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {





        uint8_t devAddr = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        if ((devAddr < 0x68) || (devAddr > 0x69)) {

          devAddr = 0x68;

          Settings.TaskDevicePluginConfig[event->TaskIndex][0] = devAddr;

        }



        _P045_writeBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, MPU6050_CLOCK_PLL_XGYRO);

        _P045_writeBits(devAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, MPU6050_GYRO_FS_250);

        _P045_writeBits(devAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, MPU6050_ACCEL_FS_2);

        _P045_writeBits(devAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, 1, 0);





        int16_t ax, ay, az, gx, gy, gz;

        _P045_getMotion6(devAddr, &ax, &ay, &az, &gx, &gy, &gz);





        Settings.TaskDevicePluginConfig[event->TaskIndex][7] = 0;

        UserVar[event->BaseVarIndex] = 0;

        Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = 0;

        Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = 0;

        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        uint8_t devAddr = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        byte dev = devAddr & 1;





        _P045_getMotion6(devAddr, &_P045_axis[0][3][dev], &_P045_axis[1][3][dev], &_P045_axis[2][3][dev], &_P045_axis[0][4][dev], &_P045_axis[1][4][dev], &_P045_axis[2][4][dev]);



        _P045_trackMinMax(_P045_axis[0][3][dev], &_P045_axis[0][0][dev], &_P045_axis[0][1][dev]);

        _P045_trackMinMax(_P045_axis[1][3][dev], &_P045_axis[1][0][dev], &_P045_axis[1][1][dev]);

        _P045_trackMinMax(_P045_axis[2][3][dev], &_P045_axis[2][0][dev], &_P045_axis[2][1][dev]);
# 483 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P045_MPU6050.ino"
        if (timeOutReached(_P045_time[dev] + 5000))

        {

          _P045_time[dev] = millis();





          for (uint8_t i=0; i<3; i++) {

            _P045_axis[i][2][dev] = abs(_P045_axis[i][1][dev] - _P045_axis[i][0][dev]);

            _P045_axis[i][0][dev] = _P045_axis[i][3][dev];

            _P045_axis[i][1][dev] = _P045_axis[i][3][dev];

          }

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        int devAddr = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        byte dev = devAddr & 1;

        int _P045_Function = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        switch (_P045_Function)

        {



          case 0:

          {



            boolean thresexceed = true;

            byte count = 0;

            for (byte i=0; i<3; i++)

            {



              if (Settings.TaskDevicePluginConfig[event->TaskIndex][i + 2] != 0) {

                if (_P045_axis[i][2][dev] < Settings.TaskDevicePluginConfig[event->TaskIndex][i + 2]) { thresexceed = false; }

              } else { count++; }

            }

            if (count == 3) { thresexceed = false; }





            if (thresexceed) { Settings.TaskDevicePluginConfigLong[event->TaskIndex][0]++; }



            Settings.TaskDevicePluginConfigLong[event->TaskIndex][1]++;



            if (Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] >= Settings.TaskDevicePluginConfig[event->TaskIndex][6]) {



              Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = 0;





              if (Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] >= Settings.TaskDevicePluginConfig[event->TaskIndex][5]) {

                UserVar[event->BaseVarIndex] = 1;

              } else {

                UserVar[event->BaseVarIndex] = 0;

              }





              if (Settings.TaskDevicePluginConfig[event->TaskIndex][7] != UserVar[event->BaseVarIndex]) {

                Settings.TaskDevicePluginConfig[event->TaskIndex][7] = UserVar[event->BaseVarIndex];

                success = true;

              } else {

                success = false;

              }

              Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = 0;

            }





            event->sensorType = SENSOR_TYPE_SWITCH;

            break;

          }



          default:

          {

            uint8_t reqaxis = (_P045_Function - 1) % 3;

            uint8_t reqvar = ((_P045_Function - 1) / 3) + 2;

            UserVar[event->BaseVarIndex] = float(_P045_axis[reqaxis][reqvar][dev]);

            success = true;

            break;

          }

        }

        break;

      }

  }

  return success;

}



void _P045_trackMinMax(int16_t current, int16_t *min, int16_t *max)



{

  if (current > *max)

  {

    *max = current;

  }

  else if (current < *min)

  {

    *min = current;

  }

}
# 697 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P045_MPU6050.ino"
void _P045_getMotion6(uint8_t devAddr, int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {



    uint8_t buffer[14];

    uint8_t count = 0;

    I2C_write8(devAddr, MPU6050_RA_ACCEL_XOUT_H);

    Wire.requestFrom(devAddr, (uint8_t)14);

    for (; Wire.available(); count++) {

        buffer[count] = Wire.read();

    }

    *ax = (((int16_t)buffer[0]) << 8) | buffer[1];

    *ay = (((int16_t)buffer[2]) << 8) | buffer[3];

    *az = (((int16_t)buffer[4]) << 8) | buffer[5];

    *gx = (((int16_t)buffer[8]) << 8) | buffer[9];

    *gy = (((int16_t)buffer[10]) << 8) | buffer[11];

    *gz = (((int16_t)buffer[12]) << 8) | buffer[13];

}
# 745 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P045_MPU6050.ino"
void _P045_writeBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {
# 763 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P045_MPU6050.ino"
    bool is_ok = true;

    uint8_t b = I2C_read8_reg(devAddr, regAddr, &is_ok);

    if (is_ok) {

      uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);

      data <<= (bitStart - length + 1);

      data &= mask;

      b &= ~(mask);

      b |= data;

      I2C_write8_reg(devAddr, regAddr, b);

    }

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P046_VentusW266.ino"
#ifdef USES_P046
# 159 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P046_VentusW266.ino"
#ifdef PLUGIN_BUILD_DISABLED



#define PLUGIN_046_DEBUG true



#define PLUGIN_046 

#define PLUGIN_ID_046 46

#define PLUGIN_NAME_046 "Hardware - Ventus W266 [TESTING]"

#define PLUGIN_VALUENAME1_046 ""

#define PLUGIN_VALUENAME2_046 ""

#define PLUGIN_VALUENAME3_046 ""



#define Plugin_046_MagicByte 0x7F

#define Plugin_046_RAW_BUFFER_SIZE 24

#define Plugin_046_Payload 23



int8_t Plugin_046_MOSIpin = -1;

int8_t Plugin_046_SCLKpin = -1;

int8_t Plugin_046_nSELpin = -1;

int8_t Plugin_046_MISOpin = -1;



byte Plugin_046_ISR_Buffer[Plugin_046_RAW_BUFFER_SIZE];



byte Plugin_046_databuffer[Plugin_046_RAW_BUFFER_SIZE];

boolean Plugin_046_ReceiveActive = false;

boolean Plugin_046_MasterSlave = false;

boolean Plugin_046_newData = false;

byte Plugin_046_bitpointer;

byte Plugin_046_bytepointer;

byte Plugin_046_receivedData;





volatile unsigned long Plugin_046_lastrainctr;

volatile int Plugin_046_lastraincount;

volatile float Plugin_046_rainmmph = 0;

volatile unsigned long Plugin_046_laststrikectr;

volatile unsigned int Plugin_046_laststrikecount;

volatile int Plugin_046_strikesph = 0;



void Plugin_046_ISR_nSEL() ICACHE_RAM_ATTR;

void Plugin_046_ISR_SCLK() ICACHE_RAM_ATTR;



boolean Plugin_046(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_046;

        Device[deviceCount].Type = DEVICE_TYPE_DUMMY;

        Device[deviceCount].VType = SENSOR_TYPE_DUAL;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].ValueCount = 3;

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        byte nrchoices = 9;

        String options[nrchoices];

        options[0] = F("Main + Temp/Hygro");

        options[1] = F("Wind");

        options[2] = F("Rain");

        options[3] = F("UV");

        options[4] = F("Lightning strikes");

        options[5] = F("Lightning distance");



        options[6] = F("Unknown 1, byte 6");

        options[7] = F("Unknown 2, byte 16");

        options[8] = F("Unknown 3, byte 19");



        addFormSelector(F("Plugin function"), F("plugin_046"), nrchoices, options, NULL, choice);



        if (choice==0) {

          addHtml(F("<TR><TD>1st GPIO (5-MOSI):<TD>"));

          addPinSelect(false, "taskdevicepin1", Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

          addHtml(F("<TR><TD>2nd GPIO (6-SCLK):<TD>"));

          addPinSelect(false, "taskdevicepin2", Settings.TaskDevicePluginConfig[event->TaskIndex][2]);

          addHtml(F("<TR><TD>3rd GPIO (7-nSEL):<TD>"));

          addPinSelect(false, "taskdevicepin3", Settings.TaskDevicePluginConfig[event->TaskIndex][3]);

          addHtml(F("<TR><TD>4th GPIO (8-MISO):<TD>"));

          addPinSelect(false, "taskdeviceport", Settings.TaskDevicePluginConfig[event->TaskIndex][4]);

        }



        switch (choice)

        {

          case (0):

          {

            addHtml(F("<TR><TD><B>Be sure you only have 1 main plugin!</B></TD>"));

            addHtml(F("<TR><TD>Value 1: Temperature, 1 decimal<BR>Value 2: Humidity, 0 decimals"));

            addHtml(F("<BR>Value 3: not used</TD>"));

            break;

          }

          case (1):

          {

            addHtml(F("<TR><TD>Value 1: Direction, 0 decimals<BR>"));

            addHtml(F("Value 2: Average, 1 decimal<Br>Value 3: Gust, 1 decimal</TD>"));

            break;

          }

          case (2):

          {

            addHtml(F("<TR><TD>Value 1: Rain in mm per hour<BR>Value 2: Total rain in mm"));

            addHtml(F("<BR>Value 3: not used</TD>"));

            break;

          }

          case (3):

          {

            addHtml(F("<TR><TD>Value 1: UV, 1 decimal"));

            addHtml(F("<BR>Values 2, 3</TD>"));

            break;

          }

          case (4):

          {

            addHtml(F("<TR><TD>Value 1: Strikes this hour, 0 decimals"));

            addHtml(F("<BR>Values 2, 3: not used</TD>"));

            break;

          }

          case (5):

          {

            addHtml(F("<TR><TD>Value 1: Distance in km, 0 decimals"));

            addHtml(F("<BR>Values 2, 3: not used</TD>"));

            break;

          }

          case (6):

          {

            addHtml(F("<TR><TD>Value 1: Batterybyte, 0 decimals"));

            addHtml(F("<BR>Values 2, 3: not used</TD>"));

            break;

          }

          case (7):

          {

            addHtml(F("<TR><TD>Value 1: Last rainbyte, 0 decimals"));

            addHtml(F("<BR>Values 2, 3: not used</TD>"));

            break;

          }

          case (8):

          {

            addHtml(F("<TR><TD>Value 1: Last lightningbyte, 0 decimals"));

            addHtml(F("<BR>Values 2, 3: not used</TD>"));

            break;

          }

        }



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_046"));

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 0) {

          Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("taskdevicepin1"));

          Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("taskdevicepin2"));

          Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("taskdevicepin3"));

          Settings.TaskDevicePluginConfig[event->TaskIndex][4] = getFormItemInt(F("taskdeviceport"));

        }

        success = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_046);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_046));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_046));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_046));

        break;

      }



    case PLUGIN_INIT:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        switch (choice)

        {

          case (0):

          {

            Plugin_046_MOSIpin = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

            Plugin_046_SCLKpin = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

            Plugin_046_nSELpin = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

            Plugin_046_MISOpin = Settings.TaskDevicePluginConfig[event->TaskIndex][4];

            int8_t total = Plugin_046_MOSIpin + Plugin_046_SCLKpin + Plugin_046_nSELpin + Plugin_046_MISOpin;

            if (total > 6) {

              pinMode(Plugin_046_MOSIpin, INPUT);

              pinMode(Plugin_046_SCLKpin, INPUT);

              pinMode(Plugin_046_nSELpin, INPUT);

              pinMode(Plugin_046_MISOpin, INPUT);

              Plugin_046_databuffer[0] = 0;

              Plugin_046_lastrainctr = 0;

              Plugin_046_lastraincount = -1;

              Plugin_046_laststrikectr = 0;

              Plugin_046_laststrikecount = -1;

              attachInterrupt(Plugin_046_SCLKpin, Plugin_046_ISR_SCLK, RISING);

              attachInterrupt(Plugin_046_nSELpin, Plugin_046_ISR_nSEL, CHANGE);

            }

            break;

          }

        }

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 0) {

          if (Plugin_046_newData) {

            uint8_t crc = 0xff;

            char data;



            Plugin_046_databuffer[0] = Plugin_046_ISR_Buffer[0];

            for (int i = 1; i < Plugin_046_bytepointer; i++) {

              data = Plugin_046_ISR_Buffer[i];

              Plugin_046_databuffer[i] = data;

              for (int j = 0; j < 8; j++)

              {

                uint8_t mix = (crc ^ data) & 0x01;

                crc >>= 1;

                if (mix) crc ^= 0x8C;

                  data >>= 1;

              }

            }

            Plugin_046_MasterSlave = false;

            Plugin_046_newData = false;

            if (PLUGIN_046_DEBUG) {

              String log = F("Ventus W266 Rcvd(");

              log += getTimeString(':');

              log += F(") ");

              for (int i = 0; i < Plugin_046_Payload; i++) {

                if ((i==2)||(i==3)||(i==4)||(i==9)||(i==10)||(i==14)||(i==17)||(i==18)||(i==20)) {

                  log += F(":");

                }

                char myHex = (Plugin_046_databuffer[i] >> 4) + 0x30;

                if (myHex > 0x39) { myHex += 7; }

                log += myHex;

                myHex = (Plugin_046_databuffer[i] & 0x0f) + 0x30;

                if (myHex > 0x39) { myHex += 7; }

                log += myHex;

              }

              log += F(" > ");

              char myHex = (crc >> 4) + 0x30;

              if (myHex > 0x39) { myHex += 7; }

              log += myHex;

              myHex = (crc & 0x0f) + 0x30;

              if (myHex > 0x39) { myHex += 7; }

              log += myHex;

              addLog(LOG_LEVEL_INFO, log);

            }

            if (crc != 00)

            {

              Plugin_046_databuffer[0] = 0;

            }

          }

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (Plugin_046_databuffer[0] == Plugin_046_MagicByte)

        {

          UserVar[event->BaseVarIndex + 1] = 0;

          byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

          switch (choice)

          {

            case (0):

            {

              int myTemp = int((Plugin_046_databuffer[5] * 256) + Plugin_046_databuffer[4]);

              if (myTemp > 0x8000) { myTemp |= 0xffff0000; }

              float temperature = float(myTemp) / 10.0;

              byte myHum = (Plugin_046_databuffer[2] >> 4) * 10 + (Plugin_046_databuffer[2] & 0x0f);

              float humidity = float(myHum);

              UserVar[event->BaseVarIndex] = temperature;

              UserVar[event->BaseVarIndex + 1] = humidity;

              event->sensorType = SENSOR_TYPE_TEMP_HUM;

              break;

            }

            case (1):

            {

              float average = float((Plugin_046_databuffer[11] << 8) + Plugin_046_databuffer[10]) / 10;

              float gust = float((Plugin_046_databuffer[13] << 8) + Plugin_046_databuffer[12]) / 10;

              float bearing = float(Plugin_046_databuffer[9] & 0x0f) * 22.5;

              UserVar[event->BaseVarIndex] = bearing;

              UserVar[event->BaseVarIndex + 1] = average;

              UserVar[event->BaseVarIndex + 2] = gust;

              event->sensorType = SENSOR_TYPE_WIND;

              break;

            }

            case (2):

            {

              float raincnt = float(((Plugin_046_databuffer[15]) * 256 + Plugin_046_databuffer[14]) / 4);

              int rainnow = int(raincnt);

              if (wdcounter < Plugin_046_lastrainctr) { Plugin_046_lastrainctr = wdcounter; }

              if (Plugin_046_lastrainctr > (wdcounter + 10))

              {

                Plugin_046_lastrainctr = wdcounter;

                if (rainnow > Plugin_046_lastraincount)

                {

                  Plugin_046_rainmmph = float(rainnow - Plugin_046_lastraincount) * 12;

                  Plugin_046_lastraincount = rainnow;

                } else {

                  Plugin_046_rainmmph = 0;

                }

              }

              UserVar[event->BaseVarIndex] = Plugin_046_rainmmph;

              UserVar[event->BaseVarIndex + 1] = raincnt;

              break;

            }

            case (3):

            {

              float uvindex = float((Plugin_046_databuffer[17]) / 10);

              UserVar[event->BaseVarIndex] = uvindex;

              break;

            }

            case (4):

            {



              unsigned int strikesnow = int((Plugin_046_databuffer[21]) * 256 + Plugin_046_databuffer[20]);

              if (wdcounter < Plugin_046_laststrikectr) { Plugin_046_laststrikectr = wdcounter; }

              if (Plugin_046_laststrikectr > (wdcounter + 10))

              {

                Plugin_046_laststrikectr = wdcounter;

                if (strikesnow > Plugin_046_laststrikecount)

                {

                  Plugin_046_strikesph = strikesnow - Plugin_046_laststrikecount;

                  Plugin_046_laststrikecount = strikesnow;

                } else {

                  Plugin_046_strikesph = 0;

                }

              }

              UserVar[event->BaseVarIndex] = float(Plugin_046_strikesph);

              break;

            }

            case (5):

            {

              float distance = float(-1);

              if (Plugin_046_databuffer[18] != 0x3F )

              {

                distance = float(Plugin_046_databuffer[18]);

              }

              UserVar[event->BaseVarIndex] = distance;

              break;

            }

            case (6):

            {

              UserVar[event->BaseVarIndex] = float(Plugin_046_databuffer[6]);

              break;

            }

            case (7):

            {

              UserVar[event->BaseVarIndex] = float(Plugin_046_databuffer[16]);

              break;

            }

            case (8):

            {

              UserVar[event->BaseVarIndex] = float(Plugin_046_databuffer[19]);

              break;

            }

          }

          success = true;

        } else {

          success = false;

        }

        break;

      }

    }

    return success;

}



void Plugin_046_ISR_nSEL()

  {

    if (digitalRead(Plugin_046_nSELpin)) {

      Plugin_046_ReceiveActive = false;

      if (Plugin_046_MasterSlave) {

        if (Plugin_046_bytepointer == Plugin_046_Payload) {

          Plugin_046_newData = true;

        }

      }

    } else {

      if (!Plugin_046_newData) {

        Plugin_046_bitpointer = 7;

        Plugin_046_bytepointer = 0;

        Plugin_046_MasterSlave = false;

        Plugin_046_ReceiveActive = true;

      }

    }

  }



void Plugin_046_ISR_SCLK()

  {

    if (Plugin_046_ReceiveActive) {

      if (Plugin_046_MasterSlave) {

        bitWrite(Plugin_046_receivedData, Plugin_046_bitpointer, digitalRead(Plugin_046_MISOpin));

      } else {

        bitWrite(Plugin_046_receivedData, Plugin_046_bitpointer, digitalRead(Plugin_046_MOSIpin));

      }

      if (Plugin_046_bitpointer == 0) {

        Plugin_046_bitpointer = 7;

        if (Plugin_046_receivedData==Plugin_046_MagicByte) {

          Plugin_046_MasterSlave = true;

        }

        Plugin_046_ISR_Buffer[Plugin_046_bytepointer] = Plugin_046_receivedData;

        Plugin_046_bytepointer++;

        if (Plugin_046_bytepointer > Plugin_046_RAW_BUFFER_SIZE) {

          Plugin_046_ReceiveActive = false;

          Plugin_046_MasterSlave = false;

        }

      } else {

        Plugin_046_bitpointer--;

      }

    }

  }

#endif

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P047_i2c-soil-moisture-sensor.ino"
#ifdef USES_P047
# 25 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P047_i2c-soil-moisture-sensor.ino"
#define PLUGIN_047 

#define PLUGIN_ID_047 47

#define PLUGIN_NAME_047 "Environment - Soil moisture sensor [TESTING]"

#define PLUGIN_VALUENAME1_047 "Temperature"

#define PLUGIN_VALUENAME2_047 "Moisture"

#define PLUGIN_VALUENAME3_047 "Light"







#define SOILMOISTURESENSOR_DEFAULT_ADDR 0x20





#define SOILMOISTURESENSOR_GET_CAPACITANCE 0x00

#define SOILMOISTURESENSOR_SET_ADDRESS 0x01

#define SOILMOISTURESENSOR_GET_ADDRESS 0x02

#define SOILMOISTURESENSOR_MEASURE_LIGHT 0x03

#define SOILMOISTURESENSOR_GET_LIGHT 0x04

#define SOILMOISTURESENSOR_GET_TEMPERATURE 0x05

#define SOILMOISTURESENSOR_RESET 0x06

#define SOILMOISTURESENSOR_GET_VERSION 0x07

#define SOILMOISTURESENSOR_SLEEP 0x08

#define SOILMOISTURESENSOR_GET_BUSY 0x09







uint8_t _i2caddrP47;



boolean Plugin_047(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_047;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_047);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_047));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_047));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_047));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

       addFormTextBox(F("I2C Address (Hex)"), F("plugin_047_i2cSoilMoisture_i2cAddress"),

            formatToHex_decimal(Settings.TaskDevicePluginConfig[event->TaskIndex][0]), 4);



        addFormCheckBox(F("Send sensor to sleep"), F("plugin_047_sleep"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);



        addFormCheckBox(F("Check sensor version") ,F("plugin_047_version"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



        addFormSeparator(2);



        addFormCheckBox(F("Change Sensor address"),F("plugin_047_changeAddr"), false);

       addFormTextBox(F("Change I2C Addr. to (Hex)"), F("plugin_047_i2cSoilMoisture_changeAddr"),

            formatToHex_decimal(Settings.TaskDevicePluginConfig[event->TaskIndex][0]), 4);



        addFormSeparator(2);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        String plugin1 = WebServer.arg(F("plugin_047_i2cSoilMoisture_i2cAddress"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = (int) strtol(plugin1.c_str(), 0, 16);



        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = isFormItemChecked(F("plugin_047_sleep"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = isFormItemChecked(F("plugin_047_version"));



        String plugin4 = WebServer.arg(F("plugin_047_i2cSoilMoisture_changeAddr"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = (int) strtol(plugin4.c_str(), 0, 16);



        Settings.TaskDevicePluginConfig[event->TaskIndex][4] = isFormItemChecked(F("plugin_047_changeAddr"));

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        _i2caddrP47 = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]) {



         Plugin_047_getVersion();

          delayBackground(20);

          addLog(LOG_LEVEL_DEBUG, F("SoilMoisture->wake"));

        }



        uint8_t sensorVersion = 0;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][2]) {



          sensorVersion = Plugin_047_getVersion();

          if (sensorVersion==0x22 || sensorVersion==0x23) {



          }

          else {

            addLog(LOG_LEVEL_INFO, F("SoilMoisture: Bad Version, no Sensor?"));

            I2C_write8(_i2caddrP47, SOILMOISTURESENSOR_RESET);

            break;

          }

        }





        if (Settings.TaskDevicePluginConfig[event->TaskIndex][4]) {

         addLog(LOG_LEVEL_INFO, String(F("SoilMoisture: Change Address: 0x")) + String(_i2caddrP47,HEX) + String(F("->0x")) +

           String(Settings.TaskDevicePluginConfig[event->TaskIndex][3],HEX));

         if (Plugin_047_setAddress(Settings.TaskDevicePluginConfig[event->TaskIndex][3])) {

           Settings.TaskDevicePluginConfig[event->TaskIndex][0] = Settings.TaskDevicePluginConfig[event->TaskIndex][3];

         }

         Settings.TaskDevicePluginConfig[event->TaskIndex][4] = false;

        }





        I2C_write8(_i2caddrP47, SOILMOISTURESENSOR_MEASURE_LIGHT);





        delayBackground(2000);



        float temperature = ((float)Plugin_047_readTemperature()) / 10;

        float moisture = ((float)Plugin_047_readMoisture());

        float light = ((float)Plugin_047_readLight());



        if (temperature>100 || temperature < -40 || moisture > 800 || moisture < 1 || light > 65535 || light < 0) {

            addLog(LOG_LEVEL_INFO, F("SoilMoisture: Bad Reading, resetting Sensor..."));

            I2C_write8(_i2caddrP47, SOILMOISTURESENSOR_RESET);

            success = false;

            break;

        }

        else {

         UserVar[event->BaseVarIndex] = temperature;

         UserVar[event->BaseVarIndex + 1] = moisture;

         UserVar[event->BaseVarIndex + 2] = light;



         String log = F("SoilMoisture: Address: 0x");

         log += String(_i2caddrP47,HEX);

         if (Settings.TaskDevicePluginConfig[event->TaskIndex][2]) {

          log += F(" Version: 0x");

          log += String(sensorVersion,HEX);

         }

         addLog(LOG_LEVEL_INFO, log);

         log = F("SoilMoisture: Temperature: ");

         log += temperature;

         addLog(LOG_LEVEL_INFO, log);

         log = F("SoilMoisture: Moisture: ");

         log += moisture;

         addLog(LOG_LEVEL_INFO, log);

         log = F("SoilMoisture: Light: ");

         log += light;

         addLog(LOG_LEVEL_INFO, log);



         if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]) {



          I2C_write8(_i2caddrP47, SOILMOISTURESENSOR_SLEEP);

          addLog(LOG_LEVEL_DEBUG, F("SoilMoisture->sleep"));

         }

         success = true;

         break;

        }

      }

  }

  return success;

}
# 413 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P047_i2c-soil-moisture-sensor.ino"
float Plugin_047_readTemperature()

{

  return I2C_readS16_reg(_i2caddrP47, SOILMOISTURESENSOR_GET_TEMPERATURE);

}
# 429 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P047_i2c-soil-moisture-sensor.ino"
float Plugin_047_readLight() {

  return I2C_read16_reg(_i2caddrP47, SOILMOISTURESENSOR_GET_LIGHT);

}
# 443 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P047_i2c-soil-moisture-sensor.ino"
unsigned int Plugin_047_readMoisture() {

  return I2C_read16_reg(_i2caddrP47, SOILMOISTURESENSOR_GET_CAPACITANCE);

}





uint8_t Plugin_047_getVersion() {

  return I2C_read8_reg(_i2caddrP47, SOILMOISTURESENSOR_GET_VERSION);

}
# 475 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P047_i2c-soil-moisture-sensor.ino"
bool Plugin_047_setAddress(int addr) {

 I2C_write8_reg(_i2caddrP47, SOILMOISTURESENSOR_SET_ADDRESS, addr);

 I2C_write8_reg(_i2caddrP47, SOILMOISTURESENSOR_SET_ADDRESS, addr);

 I2C_write8(_i2caddrP47, SOILMOISTURESENSOR_RESET);

 delayBackground(1000);

  _i2caddrP47=addr;

  return (I2C_read8_reg(_i2caddrP47, SOILMOISTURESENSOR_GET_ADDRESS) == addr);

}





#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P048_Motorshield_v2.ino"
#ifdef USES_P048
# 25 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P048_Motorshield_v2.ino"
#include <Adafruit_MotorShield.h>



#define PLUGIN_048 

#define PLUGIN_ID_048 48

#define PLUGIN_NAME_048 "Motor - Adafruit Motorshield v2 [TESTING]"

#define PLUGIN_VALUENAME1_048 "MotorShield v2"



uint8_t Plugin_048_MotorShield_address = 0x60;



int Plugin_048_MotorStepsPerRevolution = 200;

int Plugin_048_StepperSpeed = 10;



boolean Plugin_048(byte function, struct EventStruct *event, String& string) {

 boolean success = false;



 Adafruit_MotorShield AFMS;







 switch (function) {



  case PLUGIN_DEVICE_ADD: {

   Device[++deviceCount].Number = PLUGIN_ID_048;

   Device[deviceCount].Type = DEVICE_TYPE_I2C;

   Device[deviceCount].VType = SENSOR_TYPE_NONE;

   Device[deviceCount].Ports = 0;

   Device[deviceCount].PullUpOption = false;

   Device[deviceCount].InverseLogicOption = false;

   Device[deviceCount].FormulaOption = false;

   Device[deviceCount].ValueCount = 0;

   Device[deviceCount].SendDataOption = false;

   Device[deviceCount].TimerOption = false;

   break;

  }



  case PLUGIN_GET_DEVICENAME: {

   string = F(PLUGIN_NAME_048);

   break;

  }



  case PLUGIN_GET_DEVICEVALUENAMES: {

   strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0],

     PSTR(PLUGIN_VALUENAME1_048));

   break;

  }



  case PLUGIN_WEBFORM_LOAD: {



     addFormTextBox(F("I2C Address (Hex)"), F("plugin_048_adr"),

                 formatToHex_decimal(Settings.TaskDevicePluginConfig[event->TaskIndex][0]), 4);



     addFormNumericBox(F("Stepper: steps per revolution"), F("plugin_048_MotorStepsPerRevolution")

       , Settings.TaskDevicePluginConfig[event->TaskIndex][1]);



     addFormNumericBox(F("Stepper speed (rpm)"), F("plugin_048_StepperSpeed")

       , Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



   success = true;

   break;

  }



  case PLUGIN_WEBFORM_SAVE: {

   String plugin1 = WebServer.arg(F("plugin_048_adr"));

   Settings.TaskDevicePluginConfig[event->TaskIndex][0] = (int) strtol(plugin1.c_str(), 0, 16);



   Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_048_MotorStepsPerRevolution"));



   Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_048_StepperSpeed"));

   success = true;

   break;

  }



  case PLUGIN_INIT: {

   Plugin_048_MotorShield_address = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

   Plugin_048_MotorStepsPerRevolution = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

   Plugin_048_StepperSpeed = Settings.TaskDevicePluginConfig[event->TaskIndex][2];



   success = true;

   break;

  }



  case PLUGIN_READ: {



   success = false;

   break;

  }



  case PLUGIN_WRITE: {

   String cmd = parseString(string, 1);
# 211 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P048_Motorshield_v2.ino"
   if (cmd.equalsIgnoreCase(F("MotorShieldCMD")))

   {

        String param1 = parseString(string, 2);

        String param2 = parseString(string, 3);

        String param3 = parseString(string, 4);

        String param4 = parseString(string, 5);

        String param5 = parseString(string, 6);



    int p2_int;

    int p4_int;

    const bool param2_is_int = validIntFromString(param2, p2_int);

    const bool param4_is_int = validIntFromString(param4, p4_int);





    AFMS = Adafruit_MotorShield(Plugin_048_MotorShield_address);

    String log = F("MotorShield: Address: 0x");

    log += String(Plugin_048_MotorShield_address,HEX);

    addLog(LOG_LEVEL_DEBUG, log);



    if (param1.equalsIgnoreCase(F("DCMotor"))) {

     if (param2_is_int && p2_int > 0 && p2_int < 5)

     {

      Adafruit_DCMotor *myMotor;

      myMotor = AFMS.getMotor(p2_int);

      if (param3.equalsIgnoreCase(F("Forward")))

      {

       byte speed = 255;

       if (param4_is_int && p4_int >= 0 && p4_int <= 255)

        speed = p4_int;

       AFMS.begin();

       addLog(LOG_LEVEL_INFO, String(F("DCMotor")) + param2 + String(F("->Forward Speed: ")) + String(speed));

       myMotor->setSpeed(speed);

       myMotor->run(FORWARD);

       success = true;

      }

      if (param3.equalsIgnoreCase(F("Backward")))

      {

       byte speed = 255;

       if (param4_is_int && p4_int >= 0 && p4_int <= 255)

        speed = p4_int;

       AFMS.begin();

       addLog(LOG_LEVEL_INFO, String(F("DCMotor")) + param2 + String(F("->Backward Speed: ")) + String(speed));

       myMotor->setSpeed(speed);

       myMotor->run(BACKWARD);

       success = true;

      }

      if (param3.equalsIgnoreCase(F("Release")))

      {

       AFMS.begin();

       addLog(LOG_LEVEL_INFO, String(F("DCMotor")) + param2 + String(F("->Release")));

       myMotor->run(RELEASE);

       success = true;

      }

     }

    }





    if (param1.equalsIgnoreCase(F("Stepper")))

    {





     if (param2_is_int && p2_int > 0 && p2_int < 3)

     {

      Adafruit_StepperMotor *myStepper;

      myStepper = AFMS.getStepper(Plugin_048_MotorStepsPerRevolution, p2_int);

      myStepper->setSpeed(Plugin_048_StepperSpeed);

      if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE)) {

       String log = F("MotorShield: StepsPerRevolution: ");

       log += String(Plugin_048_MotorStepsPerRevolution);

       log += F(" Stepperspeed: ");

       log += String(Plugin_048_StepperSpeed);

       addLog(LOG_LEVEL_DEBUG_MORE, log);

      }



      if (param3.equalsIgnoreCase(F("Forward")))

      {

       if (param4_is_int && p4_int != 0)

       {

        int steps = p4_int;

        if (param5.equalsIgnoreCase(F("SINGLE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Forward Steps: ")) +

           steps + String(F(" SINGLE")));

         myStepper->step(steps, FORWARD, SINGLE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("DOUBLE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Forward Steps: ")) +

           steps + String(F(" DOUBLE")));

         myStepper->step(steps, FORWARD, DOUBLE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("INTERLEAVE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Forward Steps: ")) +

           steps + String(F(" INTERLEAVE")));

         myStepper->step(steps, FORWARD, INTERLEAVE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("MICROSTEP")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Forward Steps: ")) +

           steps + String(F(" MICROSTEP")));

         myStepper->step(steps, FORWARD, MICROSTEP);

         success = true;

        }

       }

      }



      if (param3.equalsIgnoreCase(F("Backward")))

      {

       if (param4_is_int && p4_int != 0)

       {

        int steps = p4_int;

        if (param5.equalsIgnoreCase(F("SINGLE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Backward Steps: ")) +

           steps + String(F(" SINGLE")));

         myStepper->step(steps, BACKWARD, SINGLE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("DOUBLE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Backward Steps: ")) +

           steps + String(F(" DOUBLE")));

         myStepper->step(steps, BACKWARD, DOUBLE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("INTERLEAVE")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Backward Steps: ")) +

           steps + String(F(" INTERLEAVE")));

         myStepper->step(steps, BACKWARD, INTERLEAVE);

         success = true;

        }

        if (param5.equalsIgnoreCase(F("MICROSTEP")))

        {

         AFMS.begin();

         addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Backward Steps: ")) +

           steps + String(F(" MICROSTEP")));

         myStepper->step(steps, BACKWARD, MICROSTEP);

         success = true;

        }



       }

      }



      if (param3.equalsIgnoreCase(F("Release")))

      {

       AFMS.begin();

       addLog(LOG_LEVEL_INFO, String(F("Stepper")) + param2 + String(F("->Release.")));

       myStepper->release();

       success = true;

      }



     }

    }



   }



   break;

  }



 }

 return success;

}





#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P049_MHZ19.ino"
#ifdef USES_P049
# 55 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P049_MHZ19.ino"
#define PLUGIN_049 

#define PLUGIN_ID_049 49

#define PLUGIN_NAME_049 "Gases - CO2 MH-Z19"

#define PLUGIN_VALUENAME1_049 "PPM"

#define PLUGIN_VALUENAME2_049 "Temperature"

#define PLUGIN_VALUENAME3_049 "U"

#define PLUGIN_READ_TIMEOUT 3000



#define PLUGIN_049_FILTER_OFF 1

#define PLUGIN_049_FILTER_OFF_ALLSAMPLES 2

#define PLUGIN_049_FILTER_FAST 3

#define PLUGIN_049_FILTER_MEDIUM 4

#define PLUGIN_049_FILTER_SLOW 5



boolean Plugin_049_init = false;



boolean Plugin_049_ABC_Disable = false;

boolean Plugin_049_ABC_MustApply = false;



#include <ESPeasySoftwareSerial.h>

ESPeasySoftwareSerial *Plugin_049_SoftSerial;



enum mhzCommands : byte { mhzCmdReadPPM,

                          mhzCmdCalibrateZero,

                          mhzCmdABCEnable,

                          mhzCmdABCDisable,

                          mhzCmdReset,

#ifdef ENABLE_DETECTION_RANGE_COMMANDS

                          mhzCmdMeasurementRange1000,

                          mhzCmdMeasurementRange2000,

                          mhzCmdMeasurementRange3000,

                          mhzCmdMeasurementRange5000

#endif

                        };
# 183 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P049_MHZ19.ino"
const PROGMEM byte mhzCmdData[][3] = {

  {0x86,0x00,0x00},

  {0x87,0x00,0x00},

  {0x79,0xA0,0x00},

  {0x79,0x00,0x00},

  {0x8d,0x00,0x00},

#ifdef ENABLE_DETECTION_RANGE_COMMANDS

  {0x99,0x03,0xE8},

  {0x99,0x07,0xD0},

  {0x99,0x0B,0xB8},

  {0x99,0x13,0x88}

#endif

  };



byte mhzResp[9];



enum

{

  ABC_enabled = 0x01,

  ABC_disabled = 0x02

};



boolean Plugin_049_Check_and_ApplyFilter(unsigned int prevVal, unsigned int &newVal, uint32_t s, const int filterValue, String& log) {

  if (s == 1) {



    return false;

  }

  if (prevVal < 400 || prevVal > 5000) {





    return true;

  }

  boolean filterApplied = filterValue > PLUGIN_049_FILTER_OFF_ALLSAMPLES;

  int32_t difference = newVal - prevVal;

  if (s > 0 && s < 64 && filterValue != PLUGIN_049_FILTER_OFF) {
# 269 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P049_MHZ19.ino"
    difference = difference * s;

    difference /= 64;

    log += F("Compensate Unstable ");

    filterApplied = true;

  }

  switch (filterValue) {

    case PLUGIN_049_FILTER_OFF: {

      if (s != 0 && s != 64) {

        log += F("Skip Unstable ");

        return false;

      }

      filterApplied = false;

      break;

    }



    case PLUGIN_049_FILTER_OFF_ALLSAMPLES: filterApplied = false; break;

    case PLUGIN_049_FILTER_FAST: difference /= 2; break;

    case PLUGIN_049_FILTER_MEDIUM: difference /= 4; break;

    case PLUGIN_049_FILTER_SLOW: difference /= 8; break;

  }

  if (filterApplied) {

    log += F("Raw PPM: ");

    log += newVal;

    log += F(" Filtered ");

  }

  newVal = static_cast<unsigned int>(prevVal + difference);

  return true;

}



boolean Plugin_049(byte function, struct EventStruct *event, String& string)

{

  bool success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_049;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_049);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_049));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_049));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_049));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String options[2] = { F("Normal"), F("ABC disabled") };

        int optionValues[2] = { ABC_enabled, ABC_disabled };

        addFormSelector(F("Auto Base Calibration"), F("plugin_049_abcdisable"), 2, options, optionValues, choice);

        byte choiceFilter = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String filteroptions[5] = { F("Skip Unstable"), F("Use Unstable"), F("Fast Response"), F("Medium Response"), F("Slow Response") };

        int filteroptionValues[5] = {

          PLUGIN_049_FILTER_OFF,

          PLUGIN_049_FILTER_OFF_ALLSAMPLES,

          PLUGIN_049_FILTER_FAST,

          PLUGIN_049_FILTER_MEDIUM,

          PLUGIN_049_FILTER_SLOW };

        addFormSelector(F("Filter"), F("plugin_049_filter"), 5, filteroptions, filteroptionValues, choiceFilter);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        const int formValue = getFormItemInt(F("plugin_049_abcdisable"));

        boolean new_ABC_disable = (formValue == ABC_disabled);

        if (Plugin_049_ABC_Disable != new_ABC_disable) {



          Plugin_049_ABC_MustApply = true;

          Plugin_049_ABC_Disable = new_ABC_disable;

        }

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = formValue;

        const int filterValue = getFormItemInt(F("plugin_049_filter"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = filterValue;

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_049_ABC_Disable = Settings.TaskDevicePluginConfig[event->TaskIndex][0] == ABC_disabled;

        if (Plugin_049_ABC_Disable) {



          Plugin_049_ABC_MustApply = true;

        }

        Plugin_049_SoftSerial = new ESPeasySoftwareSerial(Settings.TaskDevicePin1[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex]);

        Plugin_049_SoftSerial->begin(9600);

        addLog(LOG_LEVEL_INFO, F("MHZ19: Init OK "));







        schedule_task_device_timer(event->TaskIndex, millis() + 15000);



        Plugin_049_init = true;

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String command = parseString(string, 1);



        if (command == F("mhzcalibratezero"))

        {

          _P049_send_mhzCmd(mhzCmdCalibrateZero);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Calibrated zero point!"));

          success = true;

        }



        if (command == F("mhzreset"))

        {

          _P049_send_mhzCmd(mhzCmdReset);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent sensor reset!"));

          success = true;

        }



        if (command == F("mhzabcenable"))

        {

          _P049_send_mhzCmd(mhzCmdABCEnable);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent sensor ABC Enable!"));

          success = true;

        }



        if (command == F("mhzabcdisable"))

        {

          _P049_send_mhzCmd(mhzCmdABCDisable);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent sensor ABC Disable!"));

          success = true;

        }



#ifdef ENABLE_DETECTION_RANGE_COMMANDS

        if (command == F("mhzmeasurementrange1000"))

        {

          _P049_send_mhzCmd(mhzCmdMeasurementRange1000);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent measurement range 0-1000PPM!"));

          success = true;

        }



        if (command == F("mhzmeasurementrange2000"))

        {

          _P049_send_mhzCmd(mhzCmdMeasurementRange2000);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent measurement range 0-2000PPM!"));

          success = true;

        }



        if (command == F("mhzmeasurementrange3000"))

        {

          _P049_send_mhzCmd(mhzCmdMeasurementRange3000);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent measurement range 0-3000PPM!"));

          success = true;

        }



        if (command == F("mhzmeasurementrange5000"))

        {

          _P049_send_mhzCmd(mhzCmdMeasurementRange5000);

          addLog(LOG_LEVEL_INFO, F("MHZ19: Sent measurement range 0-5000PPM!"));

          success = true;

        }

#endif

        break;



      }



    case PLUGIN_READ:

      {



        if (Plugin_049_init)

        {



          byte nbBytesSent = _P049_send_mhzCmd(mhzCmdReadPPM);

          if (nbBytesSent != 9) {

            String log = F("MHZ19: Error, nb bytes sent != 9 : ");

              log += nbBytesSent;

              addLog(LOG_LEVEL_INFO, log);

          }





          memset(mhzResp, 0, sizeof(mhzResp));



          long timer = millis() + PLUGIN_READ_TIMEOUT;

          int counter = 0;

          while (!timeOutReached(timer) && (counter < 9)) {

            if (Plugin_049_SoftSerial->available() > 0) {

              mhzResp[counter++] = Plugin_049_SoftSerial->read();

            } else {

              delay(10);

            }

          }

          if (counter < 9){

              addLog(LOG_LEVEL_INFO, F("MHZ19: Error, timeout while trying to read"));

          }



          unsigned int ppm = 0;

          signed int temp = 0;

          unsigned int s = 0;

          float u = 0;

          byte checksum = _P049_calculateChecksum(mhzResp);



          if ( !(mhzResp[8] == checksum) ) {

             String log = F("MHZ19: Read error: checksum = ");

             log += String(checksum); log += " / "; log += String(mhzResp[8]);

             log += " bytes read  => ";for (byte i = 0; i < 9; i++) {log += mhzResp[i];log += "/" ;}

             addLog(LOG_LEVEL_ERROR, log);
# 735 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P049_MHZ19.ino"
             byte checksum_shift;

             for (byte i = 1; i < 8; i++) {

                checksum_shift = Plugin_049_SoftSerial->peek();

                if (checksum_shift == 0xFF) {

                  String log = F("MHZ19: Shifted ");

                  log += i;

                  log += F(" bytes to attempt to fix buffer alignment");

                  addLog(LOG_LEVEL_ERROR, log);

                  break;

                } else {

                 checksum_shift = Plugin_049_SoftSerial->read();

                }

             }

             success = false;

             break;





          } else if (mhzResp[0] == 0xFF && mhzResp[1] == 0x86 && mhzResp[8] == checksum) {





              unsigned int mhzRespHigh = (unsigned int) mhzResp[2];

              unsigned int mhzRespLow = (unsigned int) mhzResp[3];

              ppm = (256*mhzRespHigh) + mhzRespLow;





              unsigned int mhzRespTemp = (unsigned int) mhzResp[4];

              temp = mhzRespTemp - 40;





              unsigned int mhzRespS = (unsigned int) mhzResp[5];

              s = mhzRespS;





              unsigned int mhzRespUHigh = (unsigned int) mhzResp[6];

              unsigned int mhzRespULow = (unsigned int) mhzResp[7];

              u = (256*mhzRespUHigh) + mhzRespULow;



              String log = F("MHZ19: ");







              if (u == 15000) {



                log += F("Bootup detected! ");

                if (Plugin_049_ABC_Disable) {





                  Plugin_049_ABC_MustApply = true;

                  log += F("Will disable ABC when bootup complete. ");

                }

                success = false;



              } else {

                const int filterValue = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

                if (Plugin_049_Check_and_ApplyFilter(UserVar[event->BaseVarIndex], ppm, s, filterValue, log)) {

                  UserVar[event->BaseVarIndex] = (float)ppm;

                  UserVar[event->BaseVarIndex + 1] = (float)temp;

                  UserVar[event->BaseVarIndex + 2] = (float)u;

                  if (s==0 || s==64) {



                    if (Plugin_049_ABC_MustApply) {



                      if (Plugin_049_ABC_Disable) {

                        _P049_send_mhzCmd(mhzCmdABCDisable);

                        addLog(LOG_LEVEL_INFO, F("MHZ19: Sent sensor ABC Disable!"));

                      } else {

                        _P049_send_mhzCmd(mhzCmdABCEnable);

                        addLog(LOG_LEVEL_INFO, F("MHZ19: Sent sensor ABC Enable!"));

                      }

                      Plugin_049_ABC_MustApply = false;

                    }

                  }

                  success = true;

                } else {

                  success = false;

                }

              }





              log += F("PPM value: ");

              log += ppm;

              log += F(" Temp/S/U values: ");

              log += temp;

              log += F("/");

              log += s;

              log += F("/");

              log += u;

              addLog(LOG_LEVEL_INFO, log);

              break;







          } else if (mhzResp[0] == 0xFF && mhzResp[1] == 0x99 && mhzResp[8] == checksum) {



            addLog(LOG_LEVEL_INFO, F("MHZ19: Received measurement range acknowledgment! "));

            addLog(LOG_LEVEL_INFO, F("Expecting sensor reset..."));

            success = false;

            break;







          } else {



              String log = F("MHZ19: Unknown response:");

              for (int i = 0; i < 9; ++i) {

                log += F(" ");

                log += String(mhzResp[i], HEX);

              }

              addLog(LOG_LEVEL_INFO, log);

              success = false;

              break;



          }



        }

        break;

      }

  }

  return success;

}



byte _P049_calculateChecksum(byte *array)

{

  byte checksum = 0;

  for (byte i = 1; i < 8; i++)

    checksum+=array[i];

  checksum = 0xFF - checksum;

  return (checksum+1);

}



size_t _P049_send_mhzCmd(byte CommandId)

{



  mhzResp[0] = 0xFF;

  mhzResp[1] = 0x01;

  memcpy_P(&mhzResp[2], mhzCmdData[CommandId], sizeof(mhzCmdData[0]));

  mhzResp[6] = mhzResp[3]; mhzResp[7] = mhzResp[4];

  mhzResp[3] = mhzResp[4] = mhzResp[5] = 0x00;

  mhzResp[8] = _P049_calculateChecksum(mhzResp);



  return Plugin_049_SoftSerial->write(mhzResp, sizeof(mhzResp));

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P050_TCS34725.ino"
#ifdef USES_P050
# 25 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P050_TCS34725.ino"
#include "Adafruit_TCS34725.h"



#define PLUGIN_050 

#define PLUGIN_ID_050 50

#define PLUGIN_NAME_050 "Color - TCS34725  [DEVELOPMENT]"

#define PLUGIN_VALUENAME1_050 "Red"

#define PLUGIN_VALUENAME2_050 "Green"

#define PLUGIN_VALUENAME3_050 "Blue"

#define PLUGIN_VALUENAME4_050 "Color Temperature"
# 51 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P050_TCS34725.ino"
boolean Plugin_050(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_050;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_QUAD;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_050);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_050));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_050));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_050));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_050));

        break;

      }





    case PLUGIN_WEBFORM_LOAD:

      {

        byte choiceMode = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        String optionsMode[6];

        optionsMode[0] = F("TCS34725_INTEGRATIONTIME_2_4MS");

        optionsMode[1] = F("TCS34725_INTEGRATIONTIME_24MS");

        optionsMode[2] = F("TCS34725_INTEGRATIONTIME_50MS");

        optionsMode[3] = F("TCS34725_INTEGRATIONTIME_101MS");

        optionsMode[4] = F("TCS34725_INTEGRATIONTIME_154MS");

        optionsMode[5] = F("TCS34725_INTEGRATIONTIME_700MS");

        int optionValuesMode[6];

        optionValuesMode[0] = TCS34725_INTEGRATIONTIME_2_4MS;

        optionValuesMode[1] = TCS34725_INTEGRATIONTIME_24MS;

        optionValuesMode[2] = TCS34725_INTEGRATIONTIME_50MS;

        optionValuesMode[3] = TCS34725_INTEGRATIONTIME_101MS;

        optionValuesMode[4] = TCS34725_INTEGRATIONTIME_154MS;

        optionValuesMode[5] = TCS34725_INTEGRATIONTIME_700MS;

        addFormSelector(F("Integration Time"), F("plugin_050_integrationTime"), 6, optionsMode, optionValuesMode, choiceMode);



        byte choiceMode2 = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        String optionsMode2[4];

        optionsMode2[0] = F("TCS34725_GAIN_1X");

        optionsMode2[1] = F("TCS34725_GAIN_4X");

        optionsMode2[2] = F("TCS34725_GAIN_16X");

        optionsMode2[3] = F("TCS34725_GAIN_60X");

        int optionValuesMode2[4];

        optionValuesMode2[0] = TCS34725_GAIN_1X;

        optionValuesMode2[1] = TCS34725_GAIN_4X;

        optionValuesMode2[2] = TCS34725_GAIN_16X;

        optionValuesMode2[3] = TCS34725_GAIN_60X;

        addFormSelector(F("Gain"), F("plugin_050_gain"), 4, optionsMode2, optionValuesMode2, choiceMode2);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        String plugin1 = WebServer.arg(F("plugin_050_integrationTime"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = plugin1.toInt();

        String plugin2 = WebServer.arg(F("plugin_050_gain"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = plugin2.toInt();



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

       tcs34725IntegrationTime_t integrationTime;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_2_4MS)

         integrationTime = TCS34725_INTEGRATIONTIME_2_4MS;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_24MS)

         integrationTime = TCS34725_INTEGRATIONTIME_24MS;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_50MS)

         integrationTime = TCS34725_INTEGRATIONTIME_50MS;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_101MS)

         integrationTime = TCS34725_INTEGRATIONTIME_101MS;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_154MS)

         integrationTime = TCS34725_INTEGRATIONTIME_154MS;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0]==TCS34725_INTEGRATIONTIME_700MS)

         integrationTime = TCS34725_INTEGRATIONTIME_700MS;



        tcs34725Gain_t gain;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]==TCS34725_GAIN_1X)

         gain = TCS34725_GAIN_1X;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]==TCS34725_GAIN_4X)

         gain = TCS34725_GAIN_4X;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]==TCS34725_GAIN_16X)

         gain = TCS34725_GAIN_16X;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1]==TCS34725_GAIN_60X)

         gain = TCS34725_GAIN_60X;





       Adafruit_TCS34725 tcs = Adafruit_TCS34725(integrationTime, gain);

        if (tcs.begin()) {



         addLog(LOG_LEVEL_DEBUG, F("Found TCS34725 sensor"));



          uint16_t r, g, b, c;



          tcs.getRawData(&r, &g, &b, &c);

          tcs.calculateColorTemperature(r, g, b);

          tcs.calculateLux(r, g, b);



          UserVar[event->BaseVarIndex] = r;

          UserVar[event->BaseVarIndex + 1] = g;

          UserVar[event->BaseVarIndex + 2] = b;

          UserVar[event->BaseVarIndex + 3] = tcs.calculateColorTemperature(r, g, b);



          String log = F("TCS34725: Color Temp (K): ");

          log += String(UserVar[event->BaseVarIndex + 3], DEC);

          log += F(" R: ");

          log += String(UserVar[event->BaseVarIndex], DEC);

          log += F(" G: ");

          log += String(UserVar[event->BaseVarIndex + 1], DEC);

          log += F(" B: ");

          log += String(UserVar[event->BaseVarIndex + 2], DEC);

          addLog(LOG_LEVEL_INFO, log);

          success = true;



        } else {

         addLog(LOG_LEVEL_DEBUG, F("No TCS34725 found"));

         success = false;

        }



        break;

      }



  }

  return success;

}





#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P051_AM2320.ino"
#ifdef USES_P051
# 27 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P051_AM2320.ino"
#include <AM2320.h>



#define PLUGIN_051 

#define PLUGIN_ID_051 51

#define PLUGIN_NAME_051 "Environment - AM2320 [TESTING]"

#define PLUGIN_VALUENAME1_051 "Temperature"

#define PLUGIN_VALUENAME2_051 "Humidity"
# 49 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P051_AM2320.ino"
boolean Plugin_051(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_051;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_051);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_051));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_051));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

       AM2320 th;



        switch(th.Read()) {

          case 2:

           addLog(LOG_LEVEL_ERROR, F("AM2320: CRC failed"));

            break;

          case 1:

           addLog(LOG_LEVEL_ERROR, F("AM2320: Sensor offline"));

            break;

          case 0:

          {

           UserVar[event->BaseVarIndex] = th.t;

           UserVar[event->BaseVarIndex + 1] = th.h;



           String log = F("AM2320: Temperature: ");

           log += UserVar[event->BaseVarIndex];

           addLog(LOG_LEVEL_INFO, log);

           log = F("AM2320: Humidity: ");

           log += UserVar[event->BaseVarIndex + 1];

           addLog(LOG_LEVEL_INFO, log);

            success = true;

            break;

          }

        }





      }

  }

  return success;

}





#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P052_SenseAir.ino"
#ifdef USES_P052
# 21 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P052_SenseAir.ino"
#define PLUGIN_052 
#define PLUGIN_ID_052 52
#define PLUGIN_NAME_052 "Gases - CO2 Senseair"
#define PLUGIN_VALUENAME1_052 ""

boolean Plugin_052_init = false;

#include <ESPeasySoftwareSerial.h>
ESPeasySoftwareSerial *Plugin_052_SoftSerial;

boolean Plugin_052(byte function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {

    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_052;
        Device[deviceCount].Type = DEVICE_TYPE_DUAL;
        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;
        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = true;
        Device[deviceCount].ValueCount = 1;
        Device[deviceCount].SendDataOption = true;
        Device[deviceCount].TimerOption = true;
        Device[deviceCount].GlobalSyncOption = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_052);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_052));
        break;
      }

      case PLUGIN_WRITE:
          {
         String cmd = parseString(string, 1);
         String param1 = parseString(string, 2);

            if (cmd.equalsIgnoreCase(F("senseair_setrelay")))
            {
              int par1;
              if (validIntFromString(param1, par1)) {
                if (par1 == 0 || par1 == 1 || par1 == -1) {
                  Plugin_052_setRelayStatus(par1);
                  addLog(LOG_LEVEL_INFO, String(F("Senseair command: relay=")) + param1);
                }
              }
              success = true;
            }
# 96 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P052_SenseAir.ino"
            break;
          }

    case PLUGIN_WEBFORM_LOAD:
      {
          byte choiceSensor = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

          String optionsSensor[7] = { F("Error Status"), F("Carbon Dioxide"), F("Temperature"), F("Humidity"), F("Relay Status"), F("Temperature Adjustment"), F("ABC period") };
          addFormSelector(F("Sensor"), F("plugin_052_sensor"), 7, optionsSensor, NULL, choiceSensor);
# 114 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P052_SenseAir.ino"
          success = true;
          break;
      }

    case PLUGIN_WEBFORM_SAVE:
      {
        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_052_sensor"));






        success = true;
        break;
      }

    case PLUGIN_INIT:
      {
        Plugin_052_init = true;
        Plugin_052_SoftSerial = new ESPeasySoftwareSerial(Settings.TaskDevicePin1[event->TaskIndex],
                                                   Settings.TaskDevicePin2[event->TaskIndex]);
# 146 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P052_SenseAir.ino"
        success = true;
        break;
      }

    case PLUGIN_READ:
      {

        if (Plugin_052_init)
        {

          String log = F("Senseair: ");
          switch(Settings.TaskDevicePluginConfig[event->TaskIndex][0])
          {
              case 0:
              {
                  int errorWord = Plugin_052_readErrorStatus();
                  for (size_t i = 0; i < 9; i++) {
                    if (bitRead(errorWord,i)) {
                      UserVar[event->BaseVarIndex] = i;
                      log += F("error code = ");
                      log += i;
                      break;
                    }
                  }

                  UserVar[event->BaseVarIndex] = -1;
                  log += F("error code = ");
                  log += -1;
                  break;
              }
              case 1:
              {
                  int co2 = Plugin_052_readCo2();
                  UserVar[event->BaseVarIndex] = co2;
                  log += F("co2 = ");
                  log += co2;
                  break;
              }
              case 2:
              {
                  float temperature = Plugin_052_readTemperature();
                  UserVar[event->BaseVarIndex] = (float)temperature;
                  log += F("temperature = ");
                  log += (float)temperature;
                  break;
              }
              case 3:
              {
                  float relativeHumidity = Plugin_052_readRelativeHumidity();
                  UserVar[event->BaseVarIndex] = (float)relativeHumidity;
                  log += F("humidity = ");
                  log += (float)relativeHumidity;
                  break;
              }
              case 4:
              {
                  int relayStatus = Plugin_052_readRelayStatus();
                  UserVar[event->BaseVarIndex] = relayStatus;
                  log += F("relay status = ");
                  log += relayStatus;
                  break;
              }
              case 5:
              {
                  int temperatureAdjustment = Plugin_052_readTemperatureAdjustment();
                  UserVar[event->BaseVarIndex] = temperatureAdjustment;
                  log += F("temperature adjustment = ");
                  log += temperatureAdjustment;
                  break;
              }
              case 6:
              {
                  int period = Plugin_052_readABCperiod();
                  UserVar[event->BaseVarIndex] = period;
                  log += F("ABC period = ");
                  log += period;
                  break;
              }
          }
          addLog(LOG_LEVEL_INFO, log);

          success = true;
          break;
        }
        break;
      }
  }
  return success;
}

void Plugin_052_buildFrame(byte slaveAddress,
              byte functionCode,
              short startAddress,
              short numberOfRegisters,
              byte frame[8])
{
  frame[0] = slaveAddress;
  frame[1] = functionCode;
  frame[2] = (byte)(startAddress >> 8);
  frame[3] = (byte)(startAddress);
  frame[4] = (byte)(numberOfRegisters >> 8);
  frame[5] = (byte)(numberOfRegisters);

  byte checkSum[2] = {0};
  Plugin_052_ModRTU_CRC(frame, 6, checkSum);
  frame[6] = checkSum[0];
  frame[7] = checkSum[1];
}

int Plugin_052_sendCommand(byte command[])
{
  byte recv_buf[7] = {0xff};
  byte data_buf[2] = {0xff};
  long value = -1;

  Plugin_052_SoftSerial->write(command, 8);
  delay(50);


  int ByteCounter = 0;
  while(Plugin_052_SoftSerial->available()) {
    recv_buf[ByteCounter] = Plugin_052_SoftSerial->read();
    ByteCounter++;
  }

  data_buf[0] = recv_buf[3];
  data_buf[1] = recv_buf[4];
  value = (data_buf[0] << 8) | (data_buf[1]);

  return value;
}

int Plugin_052_readErrorStatus(void)
{
  int errorBits = 0;
  int error_Status = -1;
  byte frame[8] = {0};
  Plugin_052_buildFrame(0xFE, 0x04, 0x00, 1, frame);
  errorBits = Plugin_052_sendCommand(frame);
  for (size_t i = 0; i < 15; i++) {
    if (getBitOfInt(errorBits, i) == 1) {
      error_Status = i;
    }
  }
  return error_Status;
}

int Plugin_052_readCo2(void)
{
  int co2 = 0;
  byte frame[8] = {0};
  Plugin_052_buildFrame(0xFE, 0x04, 0x03, 1, frame);
  co2 = Plugin_052_sendCommand(frame);
  return co2;
}

float Plugin_052_readTemperature(void)
{
  int temperatureX100 = 0;
  float temperature = 0.0;
  byte frame[8] = {0};
  Plugin_052_buildFrame(0xFE, 0x04, 0x04, 1, frame);
  temperatureX100 = Plugin_052_sendCommand(frame);
  temperature = (float)temperatureX100/100;
  return temperature;
}

float Plugin_052_readRelativeHumidity(void)
{
  int rhX100 = 0;
  float rh = 0.0;
  byte frame[8] = {0};
  Plugin_052_buildFrame(0xFE, 0x04, 0x05, 1, frame);
  rhX100 = Plugin_052_sendCommand(frame);
  rh = (float)rhX100/100;
  return rh;
}

int Plugin_052_readRelayStatus(void)
{
  int status = 0;
  bool result;
  byte frame[8] = {0};

  Plugin_052_buildFrame(0xFE, 0x04, 0x1C, 1, frame);
  status = Plugin_052_sendCommand(frame);
  result = status >> 8 & 0x1;

  return result;
}

int Plugin_052_readTemperatureAdjustment(void)
{
  int value = 0;
  byte frame[8] = {0};

  Plugin_052_buildFrame(0xFE, 0x04, 0x0A, 1, frame);
  value = Plugin_052_sendCommand(frame);

  return value;
}

void Plugin_052_setRelayStatus(int status) {

  byte frame[8] = {0};
  if (status == 0) {
    Plugin_052_buildFrame(0xFE, 0x06, 0x18, 0x0000, frame);
  } else if (status == 1){
    Plugin_052_buildFrame(0xFE, 0x06, 0x18, 0x3FFF, frame);
  } else {
    Plugin_052_buildFrame(0xFE, 0x06, 0x18, 0x7FFF, frame);
  }
  Plugin_052_sendCommand(frame);
}

int Plugin_052_readABCperiod(void)
{
  int period = 0;
  byte frame[8] = {0};

  Plugin_052_buildFrame(0xFE, 0x03, 0x001F, 0x0001, frame);
  period = Plugin_052_sendCommand(frame);

  return period;
}
# 385 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P052_SenseAir.ino"
unsigned int Plugin_052_ModRTU_CRC(byte buf[], int len, byte checkSum[2])
{
  unsigned int crc = 0xFFFF;

  for (int pos = 0; pos < len; pos++) {
    crc ^= (unsigned int)buf[pos];

    for (int i = 8; i != 0; i--) {
      if ((crc & 0x0001) != 0) {
        crc >>= 1;
        crc ^= 0xA001;
      }
      else
        crc >>= 1;
    }
  }

  checkSum[1] = (byte)((crc >> 8) & 0xFF);
  checkSum[0] = (byte)(crc & 0xFF);
  return crc;
}

int getBitOfInt(int reg, int pos)
{

  int mask = 0x01 << pos;


  int masked_register = mask & reg;


  int result = masked_register >> pos;

  return result;
}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P053_PMSx003.ino"
#ifdef USES_P053
# 25 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P053_PMSx003.ino"
#include <ESPeasySoftwareSerial.h>



#define PLUGIN_053 

#define PLUGIN_ID_053 53

#define PLUGIN_NAME_053 "Dust - PMSx003"

#define PLUGIN_VALUENAME1_053 "pm1.0"

#define PLUGIN_VALUENAME2_053 "pm2.5"

#define PLUGIN_VALUENAME3_053 "pm10"

#define PMSx003_SIG1 0X42

#define PMSx003_SIG2 0X4d

#define PMSx003_SIZE 32



ESPeasySoftwareSerial *swSerial = NULL;

boolean Plugin_053_init = false;

boolean values_received = false;
# 63 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P053_PMSx003.ino"
void SerialRead16(uint16_t* value, uint16_t* checksum)

{

  uint8_t data_high, data_low;





  if (swSerial != NULL)

  {

    data_high = swSerial->read();

    data_low = swSerial->read();

  }

  else

  {

    data_high = Serial.read();

    data_low = Serial.read();

  }



  *value = data_low;

  *value |= (data_high << 8);



  if (checksum != NULL)

  {

    *checksum += data_high;

    *checksum += data_low;

  }



#if 0



  String log = F("PMSx003 : byte high=0x");

  log += String(data_high,HEX);

  log += F(" byte low=0x");

  log += String(data_low,HEX);

  log += F(" result=0x");

  log += String(*value,HEX);

  addLog(LOG_LEVEL_INFO, log);

#endif

}



void SerialFlush() {

  if (swSerial != NULL) {

    swSerial->flush();

  } else {

    Serial.flush();

  }

}



boolean PacketAvailable(void)

{

  if (swSerial != NULL)

  {





    if (!swSerial->available()) return false;

    while ((swSerial->peek() != PMSx003_SIG1) && swSerial->available()) {

      swSerial->read();

    }

    if (swSerial->available() < PMSx003_SIZE) return false;

  }

  else

  {





    if (!Serial.available()) return false;

    while ((Serial.peek() != PMSx003_SIG1) && Serial.available()) {

      Serial.read();

    }

    if (Serial.available() < PMSx003_SIZE) return false;

  }

  return true;

}



boolean Plugin_053_process_data(struct EventStruct *event) {

  uint16_t checksum = 0, checksum2 = 0;

  uint16_t framelength = 0;

  uint16 packet_header = 0;

  SerialRead16(&packet_header, &checksum);

  if (packet_header != ((PMSx003_SIG1 << 8) | PMSx003_SIG2)) {



    return false;

  }



  SerialRead16(&framelength, &checksum);

  if (framelength != (PMSx003_SIZE - 4))

  {

    if (loglevelActiveFor(LOG_LEVEL_ERROR)) {

      String log = F("PMSx003 : invalid framelength - ");

      log += framelength;

      addLog(LOG_LEVEL_ERROR, log);

    }

    return false;

  }



  uint16_t data[13];

  for (int i = 0; i < 13; i++)

    SerialRead16(&data[i], &checksum);



  if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {

    String log = F("PMSx003 : pm1.0=");

    log += data[0];

    log += F(", pm2.5=");

    log += data[1];

    log += F(", pm10=");

    log += data[2];

    log += F(", pm1.0a=");

    log += data[3];

    log += F(", pm2.5a=");

    log += data[4];

    log += F(", pm10a=");

    log += data[5];

    addLog(LOG_LEVEL_DEBUG, log);

  }



  if (loglevelActiveFor(LOG_LEVEL_DEBUG_MORE)) {

    String log = F("PMSx003 : count/0.1L : 0.3um=");

    log += data[6];

    log += F(", 0.5um=");

    log += data[7];

    log += F(", 1.0um=");

    log += data[8];

    log += F(", 2.5um=");

    log += data[9];

    log += F(", 5.0um=");

    log += data[10];

    log += F(", 10um=");

    log += data[11];

    addLog(LOG_LEVEL_DEBUG_MORE, log);

  }





  SerialRead16(&checksum2, NULL);

  SerialFlush();

  if (checksum == checksum2)

  {



    UserVar[event->BaseVarIndex] = data[3];

    UserVar[event->BaseVarIndex + 1] = data[4];

    UserVar[event->BaseVarIndex + 2] = data[5];

    values_received = true;

    return true;

  }

  return false;

}



boolean Plugin_053(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_053;

        Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        success = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_053);

        success = true;

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_053));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_053));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_053));

        success = true;

        break;

      }



      case PLUGIN_GET_DEVICEGPIONAMES:

        {

          event->String1 = F("GPIO &larr; TX");

          event->String2 = F("GPIO &rarr; RX");

          event->String3 = F("GPIO &rarr; Reset");

          break;

        }



    case PLUGIN_INIT:

      {

        int rxPin = Settings.TaskDevicePin1[event->TaskIndex];

        int txPin = Settings.TaskDevicePin2[event->TaskIndex];

        int resetPin = Settings.TaskDevicePin3[event->TaskIndex];



        String log = F("PMSx003 : config ");

        log += rxPin;

        log += txPin;

        log += resetPin;

        addLog(LOG_LEVEL_DEBUG, log);



        if (swSerial != NULL) {



          delete swSerial;

          swSerial = NULL;

        }





        if (rxPin == 3 && txPin == 1)

        {

          log = F("PMSx003 : using hardware serial");

          addLog(LOG_LEVEL_INFO, log);

          Serial.begin(9600);

          Serial.flush();

        }

        else

        {

          log = F("PMSx003: using software serial");

          addLog(LOG_LEVEL_INFO, log);

          swSerial = new ESPeasySoftwareSerial(rxPin, txPin, false, 96);

          swSerial->begin(9600);

          swSerial->flush();

        }



        if (resetPin >= 0)

        {



          log = F("PMSx003: resetting module");

          addLog(LOG_LEVEL_INFO, log);

          pinMode(resetPin, OUTPUT);

          digitalWrite(resetPin, LOW);

          delay(250);

          digitalWrite(resetPin, HIGH);

          pinMode(resetPin, INPUT_PULLUP);

        }



        Plugin_053_init = true;

        success = true;

        break;

      }



    case PLUGIN_EXIT:

      {

          if (swSerial)

          {

            delete swSerial;

            swSerial=NULL;

          }

          break;

      }
# 571 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P053_PMSx003.ino"
    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_053_init)

        {



          if (PacketAvailable())

          {

            addLog(LOG_LEVEL_DEBUG_MORE, F("PMSx003 : Packet available"));

            success = Plugin_053_process_data(event);

          }

        }

        break;

      }

    case PLUGIN_READ:

      {



        success = values_received;

        values_received = false;

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P054_DMX512.ino"
#ifdef USES_P054
# 106 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P054_DMX512.ino"
#define PLUGIN_054 

#define PLUGIN_ID_054 54

#define PLUGIN_NAME_054 "Communication - DMX512 TX [TESTING]"



byte* Plugin_054_DMXBuffer = 0;

int16_t Plugin_054_DMXSize = 32;



static inline void PLUGIN_054_Limit(int16_t& value, int16_t min, int16_t max)

{

  if (value < min)

    value = min;

  if (value > max)

    value = max;

}





boolean Plugin_054(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_054;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_054);

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        Settings.TaskDevicePin1[event->TaskIndex] = 2;

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = Plugin_054_DMXSize;

        addFormNote(F("Only GPIO-2 (D4) can be used as TX1!"));

        addFormNumericBox(F("Channels"), F("channels"), Plugin_054_DMXSize, 1, 512);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePin1[event->TaskIndex] = 2;

        if (Settings.Pin_status_led == 2)

          Settings.Pin_status_led = -1;

        Plugin_054_DMXSize = getFormItemInt(F("channels"));

        PLUGIN_054_Limit (Plugin_054_DMXSize, 1, 512);

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = Plugin_054_DMXSize;

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Settings.TaskDevicePin1[event->TaskIndex] = 2;

        Plugin_054_DMXSize = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



        if (Plugin_054_DMXBuffer)

          delete [] Plugin_054_DMXBuffer;

        Plugin_054_DMXBuffer = new byte[Plugin_054_DMXSize];

        memset(Plugin_054_DMXBuffer, 0, Plugin_054_DMXSize);



        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String lowerString=string;

        lowerString.toLowerCase();

        String command = parseString(lowerString, 1);



        if (command == F("dmx"))

        {

          String param;

          String paramKey;

          String paramVal;

          byte paramIdx = 2;

          int16_t channel = 1;

          int16_t value = 0;



          lowerString.replace(F("  "), " ");

          lowerString.replace(F(" ="), "=");

          lowerString.replace(F("= "), "=");



          param = parseString(lowerString, paramIdx++);

          if (param.length())

          {

            while (param.length())

            {

              addLog(LOG_LEVEL_DEBUG_MORE, param);



              if (param == F("log"))

              {

                if (loglevelActiveFor(LOG_LEVEL_INFO)) {

                  String log = F("DMX  : ");

                  for (int16_t i = 0; i < Plugin_054_DMXSize; i++)

                  {

                    log += Plugin_054_DMXBuffer[i];

                    log += F(", ");

                  }

                  addLog(LOG_LEVEL_INFO, log);

                }

                success = true;

              }



              else if (param == F("test"))

              {

                for (int16_t i = 0; i < Plugin_054_DMXSize; i++)



                  Plugin_054_DMXBuffer[i] = rand()&255;

                success = true;

              }



              else if (param == F("on"))

              {

                memset(Plugin_054_DMXBuffer, 255, Plugin_054_DMXSize);

                success = true;

              }



              else if (param == F("off"))

              {

                memset(Plugin_054_DMXBuffer, 0, Plugin_054_DMXSize);

                success = true;

              }



              else

              {

                int16_t index = param.indexOf('=');

                if (index > 0)

                {

                  paramKey = param.substring(0, index);

                  paramVal = param.substring(index+1);

                  channel = paramKey.toInt();

                }

                else

                {

                  paramVal = param;

                }



                value = paramVal.toInt();

                PLUGIN_054_Limit (value, 0, 255);



                if (channel > 0 && channel <= Plugin_054_DMXSize)

                  Plugin_054_DMXBuffer[channel-1] = value;

                channel++;

              }



              param = parseString(lowerString, paramIdx++);

            }

          }

          else

          {



          }



          success = true;

        }



        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_054_DMXBuffer)

        {

          int16_t sendPin = 2;





          Serial1.flush();





          Serial1.end();

          pinMode(sendPin, OUTPUT);

          digitalWrite(sendPin, LOW);

          delayMicroseconds(120);

          digitalWrite(sendPin, HIGH);

          delayMicroseconds(12);





          Serial1.begin(250000, SERIAL_8N2);

          Serial1.write(0);

          Serial1.write(Plugin_054_DMXBuffer, Plugin_054_DMXSize);

        }

        break;

      }



  }

  return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P055_Chiming.ino"
#ifdef USES_P055
# 103 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P055_Chiming.ino"
#define PLUGIN_055 

#define PLUGIN_ID_055 55

#define PLUGIN_NAME_055 "Notify - Chiming [TESTING]"



#define PLUGIN_055_FIFO_SIZE 64

#define PLUGIN_055_FIFO_MASK (PLUGIN_055_FIFO_SIZE-1)



class CPlugin_055_Data

{

public:

  long millisStateEnd;

  long millisChimeTime;

  long millisPauseTime;



  int pin[4];

  byte lowActive;

  byte chimeClock;



  char FIFO[PLUGIN_055_FIFO_SIZE];

  byte FIFO_IndexR;

  byte FIFO_IndexW;



  void Plugin_055_Data()

  {

    millisStateEnd = 0;

    millisChimeTime = 60;

    millisPauseTime = 400;



    for (byte i=0; i<4; i++)

      pin[i] = -1;

    lowActive = false;

    chimeClock = true;



    FIFO_IndexR = 0;

    FIFO_IndexW = 0;

  }

};



static CPlugin_055_Data* Plugin_055_Data = NULL;





boolean Plugin_055(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_055;

        Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = true;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_055);

        break;

      }



    case PLUGIN_GET_DEVICEGPIONAMES:

      {

        event->String1 = F("GPIO &rarr; Driver#1");

        event->String2 = F("GPIO &rarr; Driver#2");

        event->String3 = F("GPIO &rarr; Driver#4");

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] <= 0)

          Settings.TaskDevicePluginConfig[event->TaskIndex][0] = 60;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] <= 0)

          Settings.TaskDevicePluginConfig[event->TaskIndex][1] = 400;



        addFormPinSelect(F("GPIO &rarr; Driver#8"), F("TDP4"), (int)(Settings.TaskDevicePin[3][event->TaskIndex]));





        addFormSubHeader(F("Timing"));



        addFormNumericBox(F("Chiming/Strike Time (ct)"), F("chimetime"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        addUnit(F("ms"));



        addFormNumericBox(F("Normal Pause Time (t)"), F("pausetime"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        addUnit(F("ms"));



        addFormNote(F("'1=1'&rArr;3t, '1-1' or '11'&rArr;1t, '1.1'&rArr;&#8531;t, '1|1'&rArr;&frac12;ct"));





        addFormSubHeader(F("Chiming Clock"));



        addFormCheckBox(F("Hourly Chiming Clock Strike"), F("chimeclock"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



        addButton(F("'control?cmd=chimeplay,hours'"), F("Test 1&hellip;12"));



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][2] && !Settings.UseNTP)

          addFormNote(F("Enable and configure NTP!"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePin[3][event->TaskIndex] = (int8_t)getFormItemInt(F("TDP4"));



        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("chimetime"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("pausetime"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = isFormItemChecked(F("chimeclock"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_055_Data)

          Plugin_055_Data = new CPlugin_055_Data();



        Plugin_055_Data->lowActive = Settings.TaskDevicePin1Inversed[event->TaskIndex];

        Plugin_055_Data->millisChimeTime = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

        Plugin_055_Data->millisPauseTime = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        Plugin_055_Data->chimeClock = Settings.TaskDevicePluginConfig[event->TaskIndex][2];



        String log = F("Chime: GPIO: ");

        for (byte i=0; i<4; i++)

        {

          int pin = Settings.TaskDevicePin[i][event->TaskIndex];

          Plugin_055_Data->pin[i] = pin;

          if (pin >= 0)

          {

            pinMode(pin, OUTPUT);

            digitalWrite(pin, Plugin_055_Data->lowActive);

          }

          log += pin;

          log += F(" ");

        }

        if (Plugin_055_Data->lowActive)

          log += F("!");

        addLog(LOG_LEVEL_INFO, log);



        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (!Plugin_055_Data)

          break;



        String command = parseString(string, 1);



        if (command == F("chime"))

        {

          String param = parseStringToEndKeepCase(string, 2);

          if (param.length() > 0) {

            Plugin_055_AddStringFIFO(param);

          }

          success = true;

        }

        if (command == F("chimeplay"))

        {

          String name = parseString(string, 2);

          if (name.length() > 0) {

            String param;

            Plugin_055_ReadChime(name, param);

            Plugin_055_AddStringFIFO(param);

          }

          success = true;

        }

        if (command == F("chimesave"))

        {

          String name = parseString(string, 2);

          String param = parseStringToEndKeepCase(string, 3);

          if (name.length() > 0 && param.length() > 0) {

            Plugin_055_WriteChime(name, param);

            Plugin_055_AddStringFIFO(F("1"));

          }

          success = true;

        }



        break;

      }



      case PLUGIN_CLOCK_IN:

        {

          if (!Plugin_055_Data)

            break;



          String tokens = "";

          byte hours = hour();

          byte minutes = minute();



          if (Plugin_055_Data->chimeClock)

          {

            char tmpString[8];



            sprintf_P(tmpString, PSTR("%02d%02d"), hours, minutes);

            if (Plugin_055_ReadChime(tmpString, tokens))

              Plugin_055_AddStringFIFO(tokens);



            if (minutes == 0)

            {

              if (Plugin_055_ReadChime("hours", tokens) == 0)

                tokens = F("1111!,111!1,111!1!,11!11,11!11!,11!1!1,11!1!1!,1!111,1!111!,1!11!1,1!11!1!,1!1!11");





              hours = hours % 12;

              if (hours == 0)

                hours = 12;



              byte index = hours;



              tokens = parseString(tokens, index);

              Plugin_055_AddStringFIFO(tokens);

            }

          }



          success = true;

          break;

        }





    case PLUGIN_FIFTY_PER_SECOND:



      {

        if (!Plugin_055_Data)

          break;



        long millisAct = millis();



        if (Plugin_055_Data->millisStateEnd > 0)

        {

          if (timeDiff(millisAct, Plugin_055_Data->millisStateEnd) <= 0)

          {

            for (byte i=0; i<4; i++)

            {

              if (Plugin_055_Data->pin[i] >= 0)

                digitalWrite(Plugin_055_Data->pin[i], Plugin_055_Data->lowActive);

            }

            Plugin_055_Data->millisStateEnd = 0;

          }

        }



        if (Plugin_055_Data->millisStateEnd == 0)

        {

          if (! Plugin_055_IsEmptyFIFO())

          {

            char c = Plugin_055_ReadFIFO();



            String log = F("Chime: Process '");

            log += c;

            log += "'";

            addLog(LOG_LEVEL_DEBUG, log);



            switch (c)

            {

              case 'a':

              case 'b':

              case 'c':

              case 'd':

              case 'e':

              case 'f':

              case 'A':

              case 'B':

              case 'C':

              case 'D':

              case 'E':

              case 'F':

                c -= 'A' - '0' - 10;





              case '0':

              case '1':

              case '2':

              case '3':

              case '4':

              case '5':

              case '6':

              case '7':

              case '8':

              case '9':

              {

                byte mask = 1;

                for (byte i=0; i<4; i++)

                {

                  if (Plugin_055_Data->pin[i] >= 0)

                    if (c & mask)

                      digitalWrite(Plugin_055_Data->pin[i], !Plugin_055_Data->lowActive);

                  mask <<= 1;

                }

                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisChimeTime;

                break;

              }

              case '=':

              case ' ':

              case ',':

                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisPauseTime*3;

                break;

              case '-':

                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisPauseTime;

                break;

              case '.':

                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisPauseTime/3;

                break;

              case '|':

                Plugin_055_Data->millisStateEnd = millisAct + Plugin_055_Data->millisChimeTime/2;

                break;

              case '#':

                while (Plugin_055_ReadFIFO());

                break;

              default:

                break;

            }

          }



        }

        success = true;

        break;

      }



  }

  return success;

}







void Plugin_055_WriteFIFO(char c)

{

  if (Plugin_055_Data->FIFO_IndexR == ((Plugin_055_Data->FIFO_IndexW+1) & PLUGIN_055_FIFO_MASK))

    return;



  Plugin_055_Data->FIFO[Plugin_055_Data->FIFO_IndexW] = c;

  Plugin_055_Data->FIFO_IndexW++;

  Plugin_055_Data->FIFO_IndexW &= PLUGIN_055_FIFO_MASK;

}



char Plugin_055_ReadFIFO()

{

  if (Plugin_055_IsEmptyFIFO())

    return '\0';



  char c = Plugin_055_Data->FIFO[Plugin_055_Data->FIFO_IndexR];

  Plugin_055_Data->FIFO_IndexR++;

  Plugin_055_Data->FIFO_IndexR &= PLUGIN_055_FIFO_MASK;



  return c;

}



char Plugin_055_PeekFIFO()

{

  if (Plugin_055_IsEmptyFIFO())

    return '\0';



  return Plugin_055_Data->FIFO[Plugin_055_Data->FIFO_IndexR];

}



boolean Plugin_055_IsEmptyFIFO()

{

  return (Plugin_055_Data->FIFO_IndexR == Plugin_055_Data->FIFO_IndexW);

}



void Plugin_055_AddStringFIFO(const String& param)

{

  if (param.length() == 0)

    return;



  byte i = 0;

  char c = param[i];

  char c_last = '\0';



  while (c != 0)

  {

    if (isDigit(c) && isDigit(c_last))

      Plugin_055_WriteFIFO('-');

    if (c == '!')

    {

      Plugin_055_WriteFIFO('|');

      c = c_last;

    }

    Plugin_055_WriteFIFO(c);

    c_last = c;



    c = param[++i];

  }



  Plugin_055_WriteFIFO('=');

}







void Plugin_055_WriteChime(const String& name, const String& tokens)

{

  String fileName = F("chime_");

  fileName += name;

  fileName += F(".txt");



  String log = F("Chime: write ");

  log += fileName;

  log += F(" ");



  fs::File f = SPIFFS.open(fileName, "w");

  if (f)

  {

    f.print(tokens);

    f.close();



    log += tokens;

  }



  addLog(LOG_LEVEL_INFO, log);

}



byte Plugin_055_ReadChime(const String& name, String& tokens)

{

  String fileName = F("chime_");

  fileName += name;

  fileName += F(".txt");



  String log = F("Chime: read ");

  log += fileName;

  log += F(" ");



  tokens = "";

  fs::File f = SPIFFS.open(fileName, "r+");

  if (f)

  {

    char c;

    while (f.available())

    {

      c = f.read();

      tokens += c;

    }

    f.close();



    log += tokens;

  }



  addLog(LOG_LEVEL_INFO, log);



  return tokens.length();

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P056_SDS011-Dust.ino"
#ifdef USES_P056
# 22 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P056_SDS011-Dust.ino"
#ifdef ESP8266



#define PLUGIN_056 

#define PLUGIN_ID_056 56

#define PLUGIN_NAME_056 "Dust - SDS011/018/198"

#define PLUGIN_VALUENAME1_056 "PM2.5"

#define PLUGIN_VALUENAME2_056 "PM10"



#include <jkSDS011.h>





CjkSDS011 *Plugin_056_SDS = NULL;





boolean Plugin_056(byte function, struct EventStruct *event, String& string)

{

  bool success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_056;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_DUAL;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_056);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_056));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_056));

        break;

      }

    case PLUGIN_WEBFORM_LOAD:

      {

        if (Plugin_056_hasTxPin(event)) {

          addFormNumericBox(F("Sleep time"), F("plugin_056_sleeptime"),

                            Settings.TaskDevicePluginConfig[event->TaskIndex][0],

                            0, 30);

          addUnit(F("Minutes"));

          addFormNote(F("0 = continous, 1..30 = Work 30 seconds and sleep n*60-30 seconds"));

        }

        break;

      }

      case PLUGIN_WEBFORM_SAVE:

        {

          if (Plugin_056_hasTxPin(event)) {



            const int newsleeptime = getFormItemInt(F("plugin_056_sleeptime"));

            if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] != newsleeptime) {

              Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_056_sleeptime"));

              Plugin_056_setWorkingPeriod(newsleeptime);

            }

          }

          success = true;

          break;

        }

    case PLUGIN_GET_DEVICEGPIONAMES:

      {

        event->String1 = F("GPIO &larr; TX");

        event->String2 = F("GPIO &#8674; RX (optional)");

        break;

      }



    case PLUGIN_INIT:

      {

        if (Plugin_056_SDS)

          delete Plugin_056_SDS;

        const int16_t serial_rx = Settings.TaskDevicePin1[event->TaskIndex];

        const int16_t serial_tx = Settings.TaskDevicePin2[event->TaskIndex];

        Plugin_056_SDS = new CjkSDS011(serial_rx, serial_tx);

        String log = F("SDS  : Init OK  ESP GPIO-pin RX:");

        log += serial_rx;

        log += F(" TX:");

        log += serial_tx;

        addLog(LOG_LEVEL_INFO, log);



        success = true;

        break;

      }



    case PLUGIN_EXIT:

      {
# 232 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P056_SDS011-Dust.ino"
        shouldReboot=true;

        break;

      }



    case PLUGIN_FIFTY_PER_SECOND:

      {

        if (!Plugin_056_SDS)

          break;



        Plugin_056_SDS->Process();



        if (Plugin_056_SDS->available())

        {

          const float pm2_5 = Plugin_056_SDS->GetPM2_5();

          const float pm10 = Plugin_056_SDS->GetPM10_();

          String log = F("SDS  : act ");

          log += pm2_5;

          log += F(" ");

          log += pm10;

          addLog(LOG_LEVEL_DEBUG, log);



          if (Settings.TaskDeviceTimer[event->TaskIndex] == 0)

          {

            UserVar[event->BaseVarIndex + 0] = pm2_5;

            UserVar[event->BaseVarIndex + 1] = pm10;

            event->sensorType = SENSOR_TYPE_DUAL;

            sendData(event);

          }

        }



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (!Plugin_056_SDS)

          break;



        float pm25, pm10;

        if (Plugin_056_SDS->ReadAverage(pm25, pm10)) {

          UserVar[event->BaseVarIndex + 0] = pm25;

          UserVar[event->BaseVarIndex + 1] = pm10;

          success = true;

        }

        break;

      }

  }



  return success;

}



boolean Plugin_056_hasTxPin(struct EventStruct *event) {

  const int16_t serial_tx = Settings.TaskDevicePin2[event->TaskIndex];

  return serial_tx >= 0;

}



String Plugin_056_ErrorToString(int error) {

  String log;

  if (error < 0) {

    log = F("comm error: ");

    log += error;

  }

  return log;

}



String Plugin_056_WorkingPeriodToString(int workingPeriod) {

  if (workingPeriod < 0) {

    return Plugin_056_ErrorToString(workingPeriod);

  }

  String log;

  if (workingPeriod > 0) {

    log += workingPeriod;

    log += F(" minutes");

  } else {

    log += F(" continuous");

  }

  return log;

}



void Plugin_056_setWorkingPeriod(int minutes) {

  if (!Plugin_056_SDS)

    return;

  Plugin_056_SDS->SetWorkingPeriod(minutes);

  String log = F("SDS  : Working Period set to: ");

  log += Plugin_056_WorkingPeriodToString(minutes);

  addLog(LOG_LEVEL_INFO, log);

}



#endif
#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P057_HT16K33_LED.ino"
#ifdef USES_P057
# 97 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P057_HT16K33_LED.ino"
#define PLUGIN_057 

#define PLUGIN_ID_057 57

#define PLUGIN_NAME_057 "Display - HT16K33 [TESTING]"



#include <HT16K33.h>



CHT16K33* Plugin_057_M = NULL;



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





boolean Plugin_057(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_057;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_057);

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = CONFIG(0);



        int optionValues[8] = { 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77 };

        addFormSelectorI2C(F("i2c_addr"), 8, optionValues, addr);





        addFormSubHeader(F("7-Seg. Clock"));



        int16_t choice = CONFIG(1);

        String options[2] = { F("none"), F("7-Seg. HH:MM") };

        addFormSelector(F("Clock Type"), F("clocktype"), 2, options, NULL, choice);



        addFormNumericBox(F("Seg. for <b>X</b>x:xx"), F("clocksegh10"), CONFIG(2), 0, 7);

        addFormNumericBox(F("Seg. for x<b>X</b>:xx"), F("clocksegh1"), CONFIG(3), 0, 7);

        addFormNumericBox(F("Seg. for xx:<b>X</b>x"), F("clocksegm10"), CONFIG(4), 0, 7);

        addFormNumericBox(F("Seg. for xx:x<b>X</b>"), F("clocksegm1"), CONFIG(5), 0, 7);



        addFormNumericBox(F("Seg. for Colon"), F("clocksegcol"), CONFIG(6), -1, 7);

        addHtml(F(" Value "));

        addNumericBox(F("clocksegcolval"), CONFIG(7), 0, 255);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("i2c_addr"));



        CONFIG(1) = getFormItemInt(F("clocktype"));



        CONFIG(2) = getFormItemInt(F("clocksegh10"));

        CONFIG(3) = getFormItemInt(F("clocksegh1"));

        CONFIG(4) = getFormItemInt(F("clocksegm10"));

        CONFIG(5) = getFormItemInt(F("clocksegm1"));

        CONFIG(6) = getFormItemInt(F("clocksegcol"));

        CONFIG(7) = getFormItemInt(F("clocksegcolval"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        byte addr = CONFIG(0);



        if (!Plugin_057_M)

          Plugin_057_M = new CHT16K33;



        Plugin_057_M->Init(addr);



        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (!Plugin_057_M)

          return false;



        String command = parseString(string, 1);



        if (command == F("mprint"))

        {

          String text = parseStringToEnd(string, 2);

          if (text.length() > 0) {

            byte seg = 0;



            Plugin_057_M->ClearRowBuffer();

            while (text[seg] && seg < 8)

            {



              char c = text[seg];

              Plugin_057_M->SetDigit(seg, c);

              seg++;

            }

            Plugin_057_M->TransmitRowBuffer();

            success = true;

          }

        }

        else if (command == F("mbr")) {

          String param = parseString(string, 2);

          int brightness;

          if (validIntFromString(param, brightness)) {

            if (brightness >= 0 && brightness <= 255)

              Plugin_057_M->SetBrightness(brightness);

          }

          success = true;

        }

        else if (command == F("m") || command == F("mx") || command == F("mnum"))

        {

          String param;

          String paramKey;

          String paramVal;

          byte paramIdx = 2;

          uint8_t seg = 0;

          uint16_t value = 0;



          String lowerString=string;

          lowerString.toLowerCase();

          lowerString.replace(F("  "), " ");

          lowerString.replace(F(" ="), "=");

          lowerString.replace(F("= "), "=");



          param = parseString(lowerString, paramIdx++);

          if (param.length())

          {

            while (param.length())

            {

              addLog(LOG_LEVEL_DEBUG_MORE, param);



              if (param == F("log"))

              {

                if (loglevelActiveFor(LOG_LEVEL_INFO)) {

                  String log = F("MX   : ");

                  for (byte i = 0; i < 8; i++)

                  {

                    log += String(Plugin_057_M->GetRow(i), 16);

                    log += F("h, ");

                  }

                  addLog(LOG_LEVEL_INFO, log);

                }

                success = true;

              }



              else if (param == F("test"))

              {

                for (byte i = 0; i < 8; i++)

                  Plugin_057_M->SetRow(i, 1 << i);

                success = true;

              }



              else if (param == F("clear"))

              {

                Plugin_057_M->ClearRowBuffer();

                success = true;

              }



              else

              {

                int index = param.indexOf('=');

                if (index > 0)

                {

                  paramKey = param.substring(0, index);

                  paramVal = param.substring(index+1);

                  seg = paramKey.toInt();

                }

                else

                {

                  paramVal = param;

                }



                if (command == F("mnum"))

                {

                  value = paramVal.toInt();

                  if (value < 16)

                    Plugin_057_M->SetDigit(seg, value);

                  else

                    Plugin_057_M->SetRow(seg, value);

                }

                else if (command == F("mx"))

                {

                  char* ep;

                  value = strtol(paramVal.c_str(), &ep, 16);

                  Plugin_057_M->SetRow(seg, value);

                }

                else

                {

                  value = paramVal.toInt();

                  Plugin_057_M->SetRow(seg, value);

                }



                success = true;

                seg++;

              }



              param = parseString(lowerString, paramIdx++);

            }

          }

          else

          {



          }



          if (success)

            Plugin_057_M->TransmitRowBuffer();

          success = true;

        }



        break;

      }



    case PLUGIN_CLOCK_IN:

      {

        if (!Plugin_057_M || CONFIG(1) == 0)

          break;



        byte hours = hour();

        byte minutes = minute();





        if (hours >= 10)

          Plugin_057_M->SetDigit(CONFIG(2), hours/10);

        else

          Plugin_057_M->SetRow(CONFIG(2), 0);

        Plugin_057_M->SetDigit(CONFIG(3), hours%10);

        Plugin_057_M->SetDigit(CONFIG(4), minutes/10);

        Plugin_057_M->SetDigit(CONFIG(5), minutes%10);





        Plugin_057_M->TransmitRowBuffer();



        success = true;



        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (!Plugin_057_M || CONFIG(1) == 0)

          break;



        if (CONFIG(6) >= 0)

        {

          uint8_t act = ((uint16_t)millis() >> 9) & 1;

          static uint8_t last = 0;

          if (act != last)

          {

            last = act;

            Plugin_057_M->SetRow(CONFIG(6), (act) ? CONFIG(7) : 0);

            Plugin_057_M->TransmitRowBuffer();

          }

        }

      }



  }

  return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P058_HT16K33_KeyPad.ino"
#ifdef USES_P058
# 60 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P058_HT16K33_KeyPad.ino"
#define PLUGIN_058 

#define PLUGIN_ID_058 58

#define PLUGIN_NAME_058 "Keypad - HT16K33 [TESTING]"

#define PLUGIN_VALUENAME1_058 "ScanCode"



#include <HT16K33.h>



CHT16K33* Plugin_058_K = NULL;



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





boolean Plugin_058(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_058;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_058);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_058));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = CONFIG(0);



        int optionValues[8] = { 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77 };

        addFormSelectorI2C(F("i2c_addr"), 8, optionValues, addr);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("i2c_addr"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        byte addr = CONFIG(0);



        if (!Plugin_058_K)

          Plugin_058_K = new CHT16K33;



        Plugin_058_K->Init(addr);



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_058_K)

        {

          static uint8_t keyLast = 0;



          uint8_t key = Plugin_058_K->ReadKeys();



          if (keyLast != key)

          {

            keyLast = key;

            UserVar[event->BaseVarIndex] = (float)key;

            event->sensorType = SENSOR_TYPE_SWITCH;



            String log = F("Mkey : key=0x");

            log += String(key, 16);

            addLog(LOG_LEVEL_INFO, log);



            sendData(event);

          }



        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (Plugin_058_K)

        {

        }

        success = true;

        break;

      }



  }

  return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P059_Encoder.ino"
#ifdef USES_P059
# 34 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P059_Encoder.ino"
#define PLUGIN_059 

#define PLUGIN_ID_059 59

#define PLUGIN_NAME_059 "Switch Input - Rotary Encoder"

#define PLUGIN_VALUENAME1_059 "Counter"



#include <QEIx4.h>



QEIx4* Plugin_059_QE = NULL;



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif

#ifndef CONFIG_L

#define CONFIG_L(n) (Settings.TaskDevicePluginConfigLong[event->TaskIndex][n])

#endif

#ifndef PIN

#define PIN(n) (Settings.TaskDevicePin[n][event->TaskIndex])

#endif





boolean Plugin_059(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_059;

        Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_059);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_059));

        break;

      }



    case PLUGIN_GET_DEVICEGPIONAMES:

      {

        event->String1 = F("GPIO &larr; A");

        event->String2 = F("GPIO &larr; B");

        event->String3 = F("GPIO &#8672; I (optional)");

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {



        if (CONFIG_L(0) == 0 && CONFIG_L(1) == 0)

          CONFIG_L(1) = 100;



        String options[3] = { F("1 pulse per cycle"), F("2 pulses per cycle"), F("4 pulses per cycle") };

        int optionValues[3] = { 1, 2, 4 };

        addFormSelector(F("Mode"), F("qei_mode"), 3, options, optionValues, CONFIG(0));



        addFormNumericBox(F("Limit min."), F("qei_limitmin"), CONFIG_L(0));

        addFormNumericBox(F("Limit max."), F("qei_limitmax"), CONFIG_L(1));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("qei_mode"));



        CONFIG_L(0) = getFormItemInt(F("qei_limitmin"));

        CONFIG_L(1) = getFormItemInt(F("qei_limitmax"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_059_QE)

          Plugin_059_QE = new QEIx4;



        Plugin_059_QE->begin(PIN(0),PIN(1),PIN(2),CONFIG(0));

        Plugin_059_QE->setLimit(CONFIG_L(0), CONFIG_L(1));

        Plugin_059_QE->setIndexTrigger(true);



        ExtraTaskSettings.TaskDeviceValueDecimals[event->BaseVarIndex] = 0;



        String log = F("QEI  : GPIO: ");

        for (byte i=0; i<3; i++)

        {

          int pin = PIN(i);

          if (pin >= 0)

          {



            setPinState(PLUGIN_ID_059, pin, PIN_MODE_INPUT, 0);

          }

          log += pin;

          log += F(" ");

        }

        addLog(LOG_LEVEL_INFO, log);



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_059_QE)

        {

          if (Plugin_059_QE->hasChanged())

          {

            long c = Plugin_059_QE->read();

            UserVar[event->BaseVarIndex] = (float)c;

            event->sensorType = SENSOR_TYPE_SWITCH;



            String log = F("QEI  : ");

            log += c;

            addLog(LOG_LEVEL_INFO, log);



            sendData(event);

          }



        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (Plugin_059_QE)

        {

          UserVar[event->BaseVarIndex] = (float)Plugin_059_QE->read();

        }

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (Plugin_059_QE)

        {

            String log = "";

            String command = parseString(string, 1);

            if (command == F("encwrite"))

            {

              if (event->Par1 >= 0)

              {

                log = String(F("QEI  : ")) + string;

                addLog(LOG_LEVEL_INFO, log);

                Plugin_059_QE->write(event->Par1);

              }

              success = true;

            }

        }

        break;

      }

  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P060_MCP3221.ino"
#ifdef USES_P060
# 19 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P060_MCP3221.ino"
#define PLUGIN_060 

#define PLUGIN_ID_060 60

#define PLUGIN_NAME_060 "Analog input - MCP3221 [TESTING]"

#define PLUGIN_VALUENAME1_060 "Analog"



uint32_t Plugin_060_OversamplingValue = 0;

uint16_t Plugin_060_OversamplingCount = 0;



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





uint16_t readMCP3221(byte addr)

{

  uint16_t value;

  Wire.requestFrom(addr, (uint8_t)2);

  if (Wire.available() == 2)

  {

    value = (Wire.read() << 8) | Wire.read();

  }

  else

    value = 9999;



  return value;

}



boolean Plugin_060(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_060;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_060);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_060));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = CONFIG(0);



        int optionValues[8] = { 0x4D, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4E, 0x4F };

        addFormSelectorI2C(F("i2c_addr"), 8, optionValues, addr);



        addFormCheckBox(F("Oversampling"), F("plugin_060_oversampling"), CONFIG(1));



        addFormSubHeader(F("Two Point Calibration"));



        addFormCheckBox(F("Calibration Enabled"), F("plugin_060_cal"), CONFIG(3));



        addFormNumericBox(F("Point 1"), F("plugin_060_adc1"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][0], 0, 4095);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_060_out1"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0], 3), 10);



        addFormNumericBox(F("Point 2"), F("plugin_060_adc2"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][1], 0, 4095);

        addHtml(F(" &#8793; "));

        addTextBox(F("plugin_060_out2"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1], 3), 10);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("i2c_addr"));



        CONFIG(1) = isFormItemChecked(F("plugin_060_oversampling"));



        CONFIG(3) = isFormItemChecked(F("plugin_060_cal"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = getFormItemInt(F("plugin_060_adc1"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = getFormItemFloat(F("plugin_060_out1"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = getFormItemInt(F("plugin_060_adc2"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] = getFormItemFloat(F("plugin_060_out2"));



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (CONFIG(1))

        {

          Plugin_060_OversamplingValue += readMCP3221(CONFIG(0));

          Plugin_060_OversamplingCount ++;

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        String log = F("ADMCP: Analog value: ");



        if (Plugin_060_OversamplingCount > 0)

        {

          UserVar[event->BaseVarIndex] = (float)Plugin_060_OversamplingValue / Plugin_060_OversamplingCount;

          Plugin_060_OversamplingValue = 0;

          Plugin_060_OversamplingCount = 0;



          log += String(UserVar[event->BaseVarIndex], 3);

        }

        else

        {

          int16_t value = readMCP3221(CONFIG(0));

          UserVar[event->BaseVarIndex] = (float)value;



          log += value;

        }



        if (Settings.TaskDevicePluginConfig[event->TaskIndex][3])

        {

          int adc1 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][0];

          int adc2 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][1];

          float out1 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0];

          float out2 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1];

          if (adc1 != adc2)

          {

            float normalized = (float)(UserVar[event->BaseVarIndex] - adc1) / (float)(adc2 - adc1);

            UserVar[event->BaseVarIndex] = normalized * (out2 - out1) + out1;



            log += F(" = ");

            log += String(UserVar[event->BaseVarIndex], 3);

          }

        }



        addLog(LOG_LEVEL_INFO,log);

        success = true;

        break;

      }

  }

  return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P061_KeyPad.ino"
#ifdef USES_P061
# 110 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P061_KeyPad.ino"
#define PLUGIN_061 

#define PLUGIN_ID_061 61

#define PLUGIN_NAME_061 "Keypad - PCF8574 / MCP23017 [TESTING]"

#define PLUGIN_VALUENAME1_061 "ScanCode"







#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





boolean Plugin_061(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_061;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_061);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_061));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = CONFIG(0);



        int optionValues[16] = { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F };

        addFormSelectorI2C(F("i2c_addr"), (CONFIG(1) == 0) ? 8 : 16, optionValues, addr);

        if (CONFIG(1) != 0)

          addFormNote(F("PCF8574 uses address 0x20+; PCF8574<b>A</b> uses address 0x38+"));



        String options[3] = { F("MCP23017 (Matrix 9x8)"), F("PCF8574 (Matrix 5x4)"), F("PCF8574 (Direct 8)") };

        addFormSelector(F("Chip (Mode)"), F("chip"), 3, options, NULL, CONFIG(1));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("i2c_addr"));



        CONFIG(1) = getFormItemInt(F("chip"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        switch (CONFIG(1))

        {

          case 0: MCP23017_KeyPadMatrixInit(CONFIG(0)); break;

          case 1: PCF8574_KeyPadMatrixInit(CONFIG(0)); break;

          case 2: PCF8574_KeyPadDirectInit(CONFIG(0)); break;

        }



        success = true;

        break;

      }



    case PLUGIN_FIFTY_PER_SECOND:

      {

        static byte lastScanCode = 0xFF;

       static byte sentScanCode = 0xFF;

        byte actScanCode = 0;



        switch (CONFIG(1))

        {

          case 0: actScanCode = MCP23017_KeyPadMatrixScan(CONFIG(0)); break;

          case 1: actScanCode = PCF8574_KeyPadMatrixScan(CONFIG(0)); break;

          case 2: actScanCode = PCF8574_KeyPadDirectScan(CONFIG(0)); break;

        }



       if (lastScanCode == actScanCode)

       {

        if (sentScanCode != actScanCode)

        {

            UserVar[event->BaseVarIndex] = (float)actScanCode;

            event->sensorType = SENSOR_TYPE_SWITCH;



            String log = F("KPad : ScanCode=0x");

            log += String(actScanCode, 16);

            addLog(LOG_LEVEL_INFO, log);



            sendData(event);



         sentScanCode = actScanCode;

        }

       }

       else

        lastScanCode = actScanCode;



        success = true;

        break;

      }



    case PLUGIN_READ:

      {



        success = true;

        break;

      }



  }

  return success;

}
# 382 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P061_KeyPad.ino"
#define MCP23017_IODIRA 0x00

#define MCP23017_IODIRB 0x01

#define MCP23017_IPOLA 0x02

#define MCP23017_IPOLB 0x03

#define MCP23017_GPINTENA 0x04

#define MCP23017_GPINTENB 0x05

#define MCP23017_DEFVALA 0x06

#define MCP23017_DEFVALB 0x07

#define MCP23017_INTCONA 0x08

#define MCP23017_INTCONB 0x09

#define MCP23017_IOCON 0x0A

#define MCP23017_GPPUA 0x0C

#define MCP23017_GPPUB 0x0D

#define MCP23017_INTFA 0x0E

#define MCP23017_INTFB 0x0F

#define MCP23017_INTCAPA 0x10

#define MCP23017_INTCAPB 0x11

#define MCP23017_GPIOA 0x12

#define MCP23017_GPIOB 0x13

#define MCP23017_OLATA 0x14

#define MCP23017_OLATB 0x15





void MCP23017_setReg(byte addr, byte reg, byte data)

{

 Wire.beginTransmission(addr);

 Wire.write(reg);

 Wire.write(data);

 Wire.endTransmission();

}



byte MCP23017_getReg(byte addr, byte reg)

{

 Wire.beginTransmission(addr);

 Wire.write(reg);

 Wire.endTransmission();

 Wire.requestFrom(addr, (uint8_t)0x1);

 if (Wire.available())

 {

  return Wire.read();

 }

 return 0xFF;

}



void MCP23017_KeyPadMatrixInit(byte addr)

{

 MCP23017_setReg(addr, MCP23017_IODIRA, 0x00);

 MCP23017_setReg(addr, MCP23017_GPIOA, 0x00);

 MCP23017_setReg(addr, MCP23017_IODIRB, 0xFF);

 MCP23017_setReg(addr, MCP23017_GPPUA, 0xFF);

 MCP23017_setReg(addr, MCP23017_GPPUB, 0xFF);

}



byte MCP23017_KeyPadMatrixScan(byte addr)

{

 byte rowMask = 1;

 byte colData;



 colData = MCP23017_getReg(addr, MCP23017_GPIOB);

 if (colData == 0xFF)

  return 0;



 for (byte row = 0; row <= 8; row++)

 {

    if (row == 0)

    MCP23017_setReg(addr, MCP23017_IODIRA, 0xFF);

    else

    {

      MCP23017_setReg(addr, MCP23017_IODIRA, ~rowMask);

      rowMask <<= 1;

    }



  colData = MCP23017_getReg(addr, MCP23017_GPIOB);

  if (colData != 0xFF)

  {

   byte colMask = 1;

   for (byte col = 1; col <= 8; col++)

   {

    if ((colData & colMask) == 0)

    {

     MCP23017_setReg(addr, MCP23017_IODIRA, 0x00);

     return ((row << 4) | col);

    }

    colMask <<= 1;

   }

  }

 }



 MCP23017_setReg(addr, MCP23017_IODIRA, 0x00);

 return 0;

}







void PCF8574_setReg(byte addr, byte data)

{

 Wire.beginTransmission(addr);

 Wire.write(data);

 Wire.endTransmission();

}



byte PCF8574_getReg(byte addr)

{

 Wire.requestFrom(addr, (uint8_t)0x1);

 if (Wire.available())

 {

  return Wire.read();

 }

 return 0xFF;

}



void PCF8574_KeyPadMatrixInit(byte addr)

{

 PCF8574_setReg(addr, 0xF0);

}



byte PCF8574_KeyPadMatrixScan(byte addr)

{

 byte rowMask = 1;

 byte colData;



 colData = PCF8574_getReg(addr) & 0xF0;

 if (colData == 0xF0)

  return 0;



 for (byte row = 0; row <= 4; row++)

 {

    if (row == 0)

      PCF8574_setReg(addr, 0xFF);

    else

    {

      PCF8574_setReg(addr, ~rowMask);

      rowMask <<= 1;

    }



    colData = PCF8574_getReg(addr) & 0xF0;

  if (colData != 0xF0)

  {

   byte colMask = 0x10;

   for (byte col = 1; col <= 4; col++)

   {

    if ((colData & colMask) == 0)

    {

     PCF8574_setReg(addr, 0xF0);

     return ((row << 4) | col);

    }

    colMask <<= 1;

   }

  }

 }



 PCF8574_setReg(addr, 0xF0);

 return 0;

}







void PCF8574_KeyPadDirectInit(byte addr)

{

 PCF8574_setReg(addr, 0xFF);

}



byte PCF8574_KeyPadDirectScan(byte addr)

{

 byte colData;



 colData = PCF8574_getReg(addr);

 if (colData == 0xFF)

  return 0;



 byte colMask = 0x01;

 for (byte col = 1; col <= 8; col++)

 {

  if ((colData & colMask) == 0)

  {

   return (col);

  }

  colMask <<= 1;

 }



 return 0;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P062_MPR121_KeyPad.ino"
#ifdef USES_P062
# 36 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P062_MPR121_KeyPad.ino"
#define PLUGIN_062 

#define PLUGIN_ID_062 62

#define PLUGIN_NAME_062 "Keypad - MPR121 Touch [TESTING]"

#define PLUGIN_VALUENAME1_062 "ScanCode"



#include <Adafruit_MPR121.h>



Adafruit_MPR121* Plugin_062_K = NULL;



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





boolean Plugin_062(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_062;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_062);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_062));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = CONFIG(0);



        int optionValues[4] = { 0x5A, 0x5B, 0x5C, 0x5D };

        addFormSelectorI2C(F("i2c_addr"), 4, optionValues, addr);



        addFormCheckBox(F("ScanCode"), F("scancode"), CONFIG(1));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("i2c_addr"));



        CONFIG(1) = isFormItemChecked(F("scancode"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        byte addr = CONFIG(0);



        if (!Plugin_062_K)

          Plugin_062_K = new Adafruit_MPR121;



        Plugin_062_K->begin(addr);



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        if (Plugin_062_K)

        {

          static uint16_t keyLast = 0;



          uint16_t key = Plugin_062_K->touched();



          if (key && CONFIG(1))

          {

            uint16_t colMask = 0x01;

            for (byte col = 1; col <= 12; col++)

            {

              if (key & colMask)

              {

                key = col;

                break;

              }

              colMask <<= 1;

            }

          }



          if (keyLast != key)

          {

            keyLast = key;

            UserVar[event->BaseVarIndex] = (float)key;

            event->sensorType = SENSOR_TYPE_SWITCH;



            String log = F("Tkey : ");

            if (CONFIG(1))

              log = F("ScanCode=0x");

            else

              log = F("KeyMap=0x");

            log += String(key, 16);

            addLog(LOG_LEVEL_INFO, log);



            sendData(event);

          }



        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (Plugin_062_K)

        {

        }

        success = true;

        break;

      }



  }

  return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P063_TTP229_KeyPad.ino"
#ifdef USES_P063
# 50 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P063_TTP229_KeyPad.ino"
#define PLUGIN_063 

#define PLUGIN_ID_063 63

#define PLUGIN_NAME_063 "Keypad - TTP229 Touch"

#define PLUGIN_VALUENAME1_063 "ScanCode"
# 66 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P063_TTP229_KeyPad.ino"
#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif

#ifndef PIN

#define PIN(n) (Settings.TaskDevicePin[n][event->TaskIndex])

#endif



uint16_t readTTP229(int16_t pinSCL, int16_t pinSDO)

{

  uint16_t value = 0;

  uint16_t mask = 1;



  pinMode(pinSDO, OUTPUT);

  digitalWrite(pinSDO, HIGH);

  delayMicroseconds(100);



  digitalWrite(pinSDO, LOW);

  delayMicroseconds(10);



  pinMode(pinSDO, INPUT);

  for (byte i = 0; i < 16; i++)

  {

    digitalWrite(pinSCL, HIGH);

    delayMicroseconds(1);

    digitalWrite(pinSCL, LOW);

    if (!digitalRead(pinSDO))

      value |= mask;

    delayMicroseconds(1);

    mask <<= 1;

  }



  return value;

}





boolean Plugin_063(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_063;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_063);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_063));

        break;

      }



    case PLUGIN_GET_DEVICEGPIONAMES:

      {

        event->String1 = F("GPIO &rarr; SCL");

        event->String2 = F("GPIO &#8644; SDO");

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormCheckBox(F("ScanCode"), F("scancode"), CONFIG(1));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(1) = isFormItemChecked(F("scancode"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        int16_t pinSCL = PIN(0);

        int16_t pinSDO = PIN(1);



        String log = F("Tkey : GPIO: ");

        log += pinSCL;

        log += F(" ");

        log += pinSDO;

        addLog(LOG_LEVEL_INFO, log);



        if (pinSCL >= 0 && pinSDO >= 0)

        {

          pinMode(pinSCL, OUTPUT);

          digitalWrite(pinSCL, LOW);

          setPinState(PLUGIN_ID_063, pinSCL, PIN_MODE_OUTPUT, 0);

          pinMode(pinSDO, OUTPUT);

          digitalWrite(pinSDO, LOW);

          setPinState(PLUGIN_ID_063, pinSDO, PIN_MODE_INPUT, 0);

        }



        success = true;

        break;

      }



    case PLUGIN_TEN_PER_SECOND:

      {

        static uint16_t keyLast = 0;

        int16_t pinSCL = PIN(0);

        int16_t pinSDO = PIN(1);



        if (pinSCL >= 0 && pinSDO >= 0)

        {

          uint16_t key = readTTP229(pinSCL, pinSDO);



          if (key && CONFIG(1))

          {

            uint16_t colMask = 0x01;

            for (byte col = 1; col <= 16; col++)

            {

              if (key & colMask)

              {

                key = col;

                break;

              }

              colMask <<= 1;

            }

          }



          if (keyLast != key)

          {

            keyLast = key;

            UserVar[event->BaseVarIndex] = (float)key;

            event->sensorType = SENSOR_TYPE_SWITCH;



            String log = F("Tkey : ");

            if (CONFIG(1))

              log = F("ScanCode=0x");

            else

              log = F("KeyMap=0x");

            log += String(key, 16);

            addLog(LOG_LEVEL_INFO, log);



            sendData(event);

          }

        }



        success = true;

        break;

      }



    case PLUGIN_READ:

      {



        success = true;

        break;

      }



  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P064_APDS9960.ino"
#ifdef USES_P064
# 36 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P064_APDS9960.ino"
#define PLUGIN_064 

#define PLUGIN_ID_064 64

#define PLUGIN_NAME_064 "Gesture - APDS9960 [DEVELOPMENT]"

#define PLUGIN_VALUENAME1_064 "Gesture"

#define PLUGIN_VALUENAME2_064 "Proximity"

#define PLUGIN_VALUENAME3_064 "Light"
# 60 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P064_APDS9960.ino"
#include <SparkFun_APDS9960.h>



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif



SparkFun_APDS9960* PLUGIN_064_pds = NULL;





boolean Plugin_064(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_064;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SWITCH;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_064);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_064));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_064));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_064));
# 156 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P064_APDS9960.ino"
        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte addr = 0x39;



        int optionValues[1] = { 0x39 };

        addFormSelectorI2C(F("i2c_addr"), 1, optionValues, addr);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {





        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (PLUGIN_064_pds)

          delete PLUGIN_064_pds;

        PLUGIN_064_pds = new SparkFun_APDS9960();



        String log = F("APDS : ");

        if ( PLUGIN_064_pds->init() )

        {

          log += F("Init");



          PLUGIN_064_pds->enablePower();



          if (! PLUGIN_064_pds->enableLightSensor(false))

            log += F(" - Error during light sensor init!");

          if (! PLUGIN_064_pds->enableProximitySensor(false))

            log += F(" - Error during proximity sensor init!");



          if (! PLUGIN_064_pds->enableGestureSensor(false))

            log += F(" - Error during gesture sensor init!");

        }

        else

        {

          log += F("Error during APDS-9960 init!");

        }



        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;

      }



    case PLUGIN_FIFTY_PER_SECOND:

      {

        if (!PLUGIN_064_pds)

          break;



        if ( !PLUGIN_064_pds->isGestureAvailable() )

          break;



        int gesture = PLUGIN_064_pds->readGesture();
# 296 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P064_APDS9960.ino"
        if (gesture >= 0)

        {

          String log = F("APDS : Gesture=");



          switch ( gesture )

          {

            case DIR_UP: log += F("UP"); break;

            case DIR_DOWN: log += F("DOWN"); break;

            case DIR_LEFT: log += F("LEFT"); break;

            case DIR_RIGHT: log += F("RIGHT"); break;

            case DIR_NEAR: log += F("NEAR"); break;

            case DIR_FAR: log += F("FAR"); break;

            default: log += F("NONE"); break;

          }

          log += F(" (");

          log += gesture;

          log += F(")");



          UserVar[event->BaseVarIndex] = (float)gesture;

          event->sensorType = SENSOR_TYPE_SWITCH;



          sendData(event);



          addLog(LOG_LEVEL_INFO, log);

        }



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        if (!PLUGIN_064_pds)

          break;







        if (1)

        {

          uint8_t proximity_data = 0;

          PLUGIN_064_pds->readProximity(proximity_data);

          UserVar[event->BaseVarIndex + 1] = (float)proximity_data;



          uint16_t ambient_light = 0;

          PLUGIN_064_pds->readAmbientLight(ambient_light);

          UserVar[event->BaseVarIndex + 2] = (float)ambient_light;
# 412 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P064_APDS9960.ino"
        }



        success = true;

        break;

      }



  }

  return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P065_DRF0299_MP3.ino"
#ifdef USES_P065
# 61 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P065_DRF0299_MP3.ino"
#define PLUGIN_065 

#define PLUGIN_ID_065 65

#define PLUGIN_NAME_065 "Notify - DFPlayer-Mini MP3 [TESTING]"

#define PLUGIN_VALUENAME1_065 ""



#include <ESPeasySoftwareSerial.h>



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif

#ifndef PIN

#define PIN(n) (Settings.TaskDevicePin[n][event->TaskIndex])

#endif



ESPeasySoftwareSerial* Plugin_065_SoftSerial = NULL;





boolean Plugin_065(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_065;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_065);

        break;

      }



      case PLUGIN_GET_DEVICEGPIONAMES:

        {

          event->String1 = F("GPIO &rarr; RX");

          break;

        }



    case PLUGIN_WEBFORM_LOAD:

      {

          addFormNumericBox(F("Volume"), F("volume"), CONFIG(0), 1, 30);



          success = true;

          break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = getFormItemInt(F("volume"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        #pragma GCC diagnostic push



        #pragma GCC diagnostic warning "-Wdelete-non-virtual-dtor"

        if (Plugin_065_SoftSerial)

          delete Plugin_065_SoftSerial;

        #pragma GCC diagnostic pop





        Plugin_065_SoftSerial = new ESPeasySoftwareSerial(-1, PIN(0));



        Plugin_065_SoftSerial->begin(9600);



        Plugin_065_SetVol(CONFIG(0));



        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (!Plugin_065_SoftSerial)

          break;



        String command = parseString(string, 1);

        String param = parseString(string, 2);



        if (command == F("play"))

        {

          int track;

          if (validIntFromString(param, track)) {

            Plugin_065_Play(track);

            if (loglevelActiveFor(LOG_LEVEL_INFO)) {

              String log = F("MP3  : play=");

              log += track;

              addLog(LOG_LEVEL_INFO, log);

            }

          }

          success = true;

        }



        if (command == F("stop"))

        {

          String log = F("MP3  : stop");



          Plugin_065_SendCmd(0x0E, 0);



          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }



        if (command == F("vol"))

        {

          String log = F("MP3  : vol=");



          int8_t vol = param.toInt();

          if (vol == 0) vol = 30;

          CONFIG(0) = vol;

          Plugin_065_SetVol(vol);

          log += vol;



          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }



        if (command == F("eq"))

        {

          String log = F("MP3  : eq=");



          int8_t eq = param.toInt();

          Plugin_065_SetEQ(eq);

          log += eq;



          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }



        break;

      }

  }

  return success;

}





void Plugin_065_Play(uint16_t track)

{

  Plugin_065_SendCmd(0x03, track);

}



void Plugin_065_SetVol(int8_t vol)

{

  if (vol < 1) vol = 1;

  if (vol > 30) vol = 30;

  Plugin_065_SendCmd(0x06, vol);

}



void Plugin_065_SetEQ(int8_t eq)

{

  if (eq < 0) eq = 0;

  if (eq > 5) eq = 5;

  Plugin_065_SendCmd(0x07, eq);

}



void Plugin_065_SendCmd(byte cmd, int16_t data)

{

  if (!Plugin_065_SoftSerial)

    return;



  byte buffer[10] = { 0x7E, 0xFF, 0x06, 0, 0x00, 0, 0, 0, 0, 0xEF };



  buffer[3] = cmd;

  buffer[5] = data >> 8;

  buffer[6] = data & 0xFF;



  int16_t checksum = -(buffer[1] + buffer[2] + buffer[3] + buffer[4] + buffer[5] + buffer[6]);

  buffer[7] = checksum >> 8;

  buffer[8] = checksum & 0xFF;



  Plugin_065_SoftSerial->write(buffer, 10);



  String log = F("MP3  : Send Cmd ");

  for (byte i=0; i<10; i++)

  {

    log += String(buffer[i], 16);

    log += F(" ");

  }

  addLog(LOG_LEVEL_DEBUG, log);

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P066_VEML6040.ino"
#ifdef USES_P066
# 26 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P066_VEML6040.ino"
#define PLUGIN_066 

#define PLUGIN_ID_066 66

#define PLUGIN_NAME_066 "Color - VEML6040 [TESTING]"

#define PLUGIN_VALUENAME1_066 "R"

#define PLUGIN_VALUENAME2_066 "G"

#define PLUGIN_VALUENAME3_066 "B"

#define PLUGIN_VALUENAME4_066 "W"



#define VEML6040_ADDR 0x10





#include <math.h>



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif





boolean Plugin_066(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_066;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_QUAD;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_066);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_066));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_066));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_066));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_066));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        int optionValues[1] = { VEML6040_ADDR };

        addFormSelectorI2C(F("i2c_addr"), 1, optionValues, VEML6040_ADDR);



        String optionsMode[6] = { F("40ms (16496)"), F("80ms (8248)"), F("160ms (4124)"), F("320ms (2062)"), F("640ms (1031)"), F("1280ms (515)") };

        addFormSelector(F("Integration Time (Max Lux)"), F("itime"), 6, optionsMode, NULL, CONFIG(1));



        String optionsVarMap[6] = {

          F("R, G, B, W"),

          F("r, g, b, W - relative rgb [&#37;]"),

          F("r, g, b, W - relative rgb^Gamma [&#37;]"),

          F("R, G, B, Color Temperature [K]"),

          F("R, G, B, Ambient Light [Lux]"),

          F("Color Temperature [K], Ambient Light [Lux], Y, W") };

        addFormSelector(F("Value Mapping"), F("map"), 6, optionsVarMap, NULL, CONFIG(2));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {



        CONFIG(1) = getFormItemInt(F("itime"));

        CONFIG(2) = getFormItemInt(F("map"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        VEML6040_Init(CONFIG(1));



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        float R, G, B, W;



        R = VEML6040_GetValue(0x08);

        G = VEML6040_GetValue(0x09);

        B = VEML6040_GetValue(0x0A);

        W = VEML6040_GetValue(0x0B);



        switch (CONFIG(2))

        {

          default:

          case 0:

          {

            UserVar[event->BaseVarIndex + 0] = R;

            UserVar[event->BaseVarIndex + 1] = G;

            UserVar[event->BaseVarIndex + 2] = B;

            UserVar[event->BaseVarIndex + 3] = W;

            break;

          }

          case 1:

          {

            UserVar[event->BaseVarIndex + 0] = Plugin_066_CalcRelW(R, W) * 100.0;

            UserVar[event->BaseVarIndex + 1] = Plugin_066_CalcRelW(G, W) * 100.0;

            UserVar[event->BaseVarIndex + 2] = Plugin_066_CalcRelW(B, W) * 100.0;

            UserVar[event->BaseVarIndex + 3] = W;

            break;

          }

          case 2:

          {

            UserVar[event->BaseVarIndex + 0] = pow(Plugin_066_CalcRelW(R, W), 0.4545) * 100.0;

            UserVar[event->BaseVarIndex + 1] = pow(Plugin_066_CalcRelW(G, W), 0.4545) * 100.0;

            UserVar[event->BaseVarIndex + 2] = pow(Plugin_066_CalcRelW(B, W), 0.4545) * 100.0;

            UserVar[event->BaseVarIndex + 3] = W;

            break;

          }

          case 3:

          {

            UserVar[event->BaseVarIndex + 0] = R;

            UserVar[event->BaseVarIndex + 1] = G;

            UserVar[event->BaseVarIndex + 2] = B;

            UserVar[event->BaseVarIndex + 3] = Plugin_066_CalcCCT(R, G, B);

            break;

          }

          case 4:

          {

            UserVar[event->BaseVarIndex + 0] = R;

            UserVar[event->BaseVarIndex + 1] = G;

            UserVar[event->BaseVarIndex + 2] = B;

            UserVar[event->BaseVarIndex + 3] = Plugin_066_CalcAmbientLight(G, CONFIG(1));

            break;

          }

          case 5:

          {

            UserVar[event->BaseVarIndex + 0] = Plugin_066_CalcCCT(R, G, B);

            UserVar[event->BaseVarIndex + 1] = Plugin_066_CalcAmbientLight(G, CONFIG(1));

            UserVar[event->BaseVarIndex + 2] = (R + G + B) / 3.0;

            UserVar[event->BaseVarIndex + 3] = W;

            break;

          }

        }

        success = true;

        break;

      }



  }

  return success;

}
# 360 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P066_VEML6040.ino"
void VEML6040_setControlReg(byte data)

{

 Wire.beginTransmission(VEML6040_ADDR);

  Wire.write(0);

 Wire.write(data);

  Wire.write(0);

 Wire.endTransmission();

}



float VEML6040_GetValue(byte reg)

{

 Wire.beginTransmission(VEML6040_ADDR);

 Wire.write(reg);

 Wire.endTransmission(false);

 Wire.requestFrom((uint8_t)VEML6040_ADDR, (uint8_t)0x2);

 if (Wire.available() == 2)

 {

    uint16_t lsb = Wire.read();

    uint16_t msb = Wire.read();

  return (float)((msb << 8) | lsb);

 }

 return -1.0;

}



void VEML6040_Init(byte it)

{

  VEML6040_setControlReg(it << 4);

}





float Plugin_066_CalcCCT(float R, float G, float B)

{

  if (G == 0)

    return 0;



  float CCTi = (R - B) / G + 0.5;

  float CCT = 4278.6 * pow(CCTi, -1.2455);

  return CCT;

}



float Plugin_066_CalcAmbientLight(float G, byte it)

{

  float Sensitivity[6] = { 0.25168, 0.12584, 0.06292, 0.03146, 0.01573, 0.007865 };



  return G * Sensitivity[it];

}



float Plugin_066_CalcRelW(float X, float W)

{

  if (W == 0)

    return 0;



  return X / W;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P067_HX711_Load_Cell.ino"
#ifdef USES_P067
# 30 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P067_HX711_Load_Cell.ino"
#define PLUGIN_067 

#define PLUGIN_ID_067 67

#define PLUGIN_NAME_067 "Weight - HX711 Load Cell [TESTING]"

#define PLUGIN_VALUENAME1_067 "Weight"
# 46 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P067_HX711_Load_Cell.ino"
#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif

#ifndef PIN

#define PIN(n) (Settings.TaskDevicePin[n][event->TaskIndex])

#endif



int32_t Plugin_067_OversamplingValue = 0;

int16_t Plugin_067_OversamplingCount = 0;





void initHX711(int16_t pinSCL, int16_t pinDOUT)

{

  digitalWrite(pinSCL, LOW);

  pinMode(pinSCL, OUTPUT);



  pinMode(pinDOUT, INPUT_PULLUP);

}





boolean isReadyHX711(int16_t pinSCL, int16_t pinDOUT)

{

  return (!digitalRead(pinDOUT));

}



int32_t readHX711(int16_t pinSCL, int16_t pinDOUT, uint8_t mode)

{

  int32_t value = 0;

  int32_t mask = 0x00800000;



  for (byte i = 0; i < 24; i++)

  {

    digitalWrite(pinSCL, HIGH);

    delayMicroseconds(1);

    digitalWrite(pinSCL, LOW);

    if (digitalRead(pinDOUT))

      value |= mask;

    delayMicroseconds(1);

    mask >>= 1;

  }



  for (byte i = 0; i < (mode+1); i++)

  {

    digitalWrite(pinSCL, HIGH);

    delayMicroseconds(1);

    digitalWrite(pinSCL, LOW);

    delayMicroseconds(1);

  }



  if (value & 0x00800000)

    value |= 0xFF000000;



  return value;

}





boolean Plugin_067(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_067;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_067);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_067));

        break;

      }



    case PLUGIN_GET_DEVICEGPIONAMES:

      {

        event->String1 = F("GPIO &rarr; SCL");

        event->String2 = F("GPIO &larr; DOUT");

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormSubHeader(F("Measurement"));



        addFormCheckBox(F("Oversampling"), F("oversampling"), CONFIG(0));



        String optionsMode[3] = { F("Channel A, Gain 128"), F("Channel B, Gain 32"), F("Channel A, Gain 64") };

        addFormSelector(F("Mode"), F("mode"), 3, optionsMode, NULL, CONFIG(1));



        addFormTextBox(F("Offset"), F("Plugin_067_offset"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][3], 3), 25);

        addHtml(F(" &nbsp; &nbsp; &#8617; Tare: "));

        addCheckBox(F("tare"), 0);



        addFormSubHeader(F("Two Point Calibration"));



        addFormCheckBox(F("Calibration Enabled"), F("Plugin_067_cal"), Settings.TaskDevicePluginConfig[event->TaskIndex][3]);



        addFormNumericBox(F("Point 1"), F("Plugin_067_adc1"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][0]);

        addHtml(F(" &#8793; "));

        addTextBox(F("Plugin_067_out1"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0], 3), 10);



        addFormNumericBox(F("Point 2"), F("Plugin_067_adc2"), Settings.TaskDevicePluginConfigLong[event->TaskIndex][1]);

        addHtml(F(" &#8793; "));

        addTextBox(F("Plugin_067_out2"), String(Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1], 3), 10);



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = isFormItemChecked(F("oversampling"));



        CONFIG(1) = getFormItemInt(F("mode"));



        if (isFormItemChecked(F("tare")))

        {

          Settings.TaskDevicePluginConfigFloat[event->TaskIndex][3] = -UserVar[event->BaseVarIndex + 1];

          Plugin_067_OversamplingValue = 0;

          Plugin_067_OversamplingCount = 0;

        }

        else

        {

          Settings.TaskDevicePluginConfigFloat[event->TaskIndex][3] = getFormItemFloat(F("Plugin_067_offset"));

        }



        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = isFormItemChecked(F("Plugin_067_cal"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][0] = getFormItemInt(F("Plugin_067_adc1"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0] = getFormItemFloat(F("Plugin_067_out1"));



        Settings.TaskDevicePluginConfigLong[event->TaskIndex][1] = getFormItemInt(F("Plugin_067_adc2"));

        Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1] = getFormItemFloat(F("Plugin_067_out2"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        int16_t pinSCL = PIN(0);

        int16_t pinDOUT = PIN(1);



        String log = F("HX711: GPIO: SCL=");

        log += pinSCL;

        log += F(" DOUT=");

        log += pinDOUT;

        addLog(LOG_LEVEL_INFO, log);



        if (pinSCL >= 0 && pinDOUT >= 0)

        {

          initHX711(pinSCL, pinDOUT);

        }



        success = true;

        break;

      }



    case PLUGIN_FIFTY_PER_SECOND:

      {

        int16_t pinSCL = PIN(0);

        int16_t pinDOUT = PIN(1);



        if (Plugin_067_OversamplingCount < 250)

        if (pinSCL >= 0 && pinDOUT >= 0)

        if (isReadyHX711(pinSCL, pinDOUT))

        {

          int32_t value = readHX711(pinSCL, pinDOUT, CONFIG(1));



          if (CONFIG(0))

          {

            Plugin_067_OversamplingValue += value;

            Plugin_067_OversamplingCount ++;

          }

          else

          {

            Plugin_067_OversamplingValue = value;

            Plugin_067_OversamplingCount = 1;

          }

        }



        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        String log = F("HX711: Value: ");



        if (Plugin_067_OversamplingCount > 0)

        {

          UserVar[event->BaseVarIndex + 1] = (float)Plugin_067_OversamplingValue / Plugin_067_OversamplingCount;

          Plugin_067_OversamplingValue = 0;

          Plugin_067_OversamplingCount = 0;



          UserVar[event->BaseVarIndex] = UserVar[event->BaseVarIndex + 1] + Settings.TaskDevicePluginConfigFloat[event->TaskIndex][3];



          log += String(UserVar[event->BaseVarIndex], 3);



          if (Settings.TaskDevicePluginConfig[event->TaskIndex][3])

          {

            int adc1 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][0];

            int adc2 = Settings.TaskDevicePluginConfigLong[event->TaskIndex][1];

            float out1 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][0];

            float out2 = Settings.TaskDevicePluginConfigFloat[event->TaskIndex][1];

            if (adc1 != adc2)

            {

              float normalized = (float)(UserVar[event->BaseVarIndex] - adc1) / (float)(adc2 - adc1);

              UserVar[event->BaseVarIndex] = normalized * (out2 - out1) + out1;



              log += F(" = ");

              log += String(UserVar[event->BaseVarIndex], 3);

            }

          }

        }

        else

        {

          log += F("NO NEW VALUE");

        }



        addLog(LOG_LEVEL_INFO,log);

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String command = parseString(string, 1);

        if (command == F("tare"))

        {

          String log = F("HX711: tare");



          Settings.TaskDevicePluginConfigFloat[event->TaskIndex][3] = -UserVar[event->BaseVarIndex + 1];

          Plugin_067_OversamplingValue = 0;

          Plugin_067_OversamplingCount = 0;



          addLog(LOG_LEVEL_INFO, log);

          success = true;

        }

        break;

      }



  }

  return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P068_SHT3x.ino"
#ifdef USES_P068
# 27 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P068_SHT3x.ino"
#define PLUGIN_068 

#define PLUGIN_ID_068 68

#define PLUGIN_NAME_068 "Environment - SHT30/31/35 [TESTING]"

#define PLUGIN_VALUENAME1_068 "Temperature"

#define PLUGIN_VALUENAME2_068 "Humidity"
# 45 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P068_SHT3x.ino"
# ifndef SHT3X_H

#define SHT3X_H 



class SHT3X

{

public:

 SHT3X(uint8_t addr);

 void get(void);

 float tmp=0;

 float hum=0;



private:

 uint8_t _i2c_device_address;

};



#endif
# 85 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P068_SHT3x.ino"
SHT3X::SHT3X(uint8_t addr)

{

 _i2c_device_address = addr;







 Wire.beginTransmission(_i2c_device_address);

 Wire.write(0x20);

 Wire.write(0x32);

 Wire.endTransmission();

}



void SHT3X::get()

{

 uint16_t data[6];



 Wire.beginTransmission(_i2c_device_address);

 Wire.write(0xE0);

 Wire.write(0x00);

 Wire.endTransmission();



 Wire.requestFrom(_i2c_device_address, (uint8_t)6);

 if (Wire.available() == 6)

 {

  data[0] = Wire.read();

  data[1] = Wire.read();

  data[2] = Wire.read();

  data[3] = Wire.read();

  data[4] = Wire.read();

  data[5] = Wire.read();







  tmp = ((((data[0] << 8) | data[1]) * 175.0) / 65535.0) - 45.0;

  hum = ((((data[3] << 8) | data[4]) * 100.0) / 65535.0);

 }

 else

 {

  tmp = NAN;

  hum = NAN;

 }

}



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif



SHT3X* Plugin_068_SHT3x[TASKS_MAX] = { NULL, };
# 193 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P068_SHT3x.ino"
boolean Plugin_068(byte function, struct EventStruct *event, String& string)

{

 boolean success = false;



 switch (function)

 {

  case PLUGIN_DEVICE_ADD:

  {

   Device[++deviceCount].Number = PLUGIN_ID_068;

   Device[deviceCount].Type = DEVICE_TYPE_I2C;

   Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

   Device[deviceCount].Ports = 0;

   Device[deviceCount].PullUpOption = false;

   Device[deviceCount].InverseLogicOption = false;

   Device[deviceCount].FormulaOption = true;

   Device[deviceCount].ValueCount = 2;

   Device[deviceCount].SendDataOption = true;

   Device[deviceCount].TimerOption = true;

   Device[deviceCount].GlobalSyncOption = true;

   break;

  }



  case PLUGIN_GET_DEVICENAME:

  {

   string = F(PLUGIN_NAME_068);

   break;

  }



  case PLUGIN_GET_DEVICEVALUENAMES:

  {

   strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_068));

   strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_068));

   break;

  }



  case PLUGIN_WEBFORM_LOAD:

  {

   int optionValues[2] = { 0x44, 0x45 };

   addFormSelectorI2C(F("i2c_addr"), 2, optionValues, CONFIG(0));



   success = true;

   break;

  }



  case PLUGIN_WEBFORM_SAVE:

  {

   CONFIG(0) = getFormItemInt(F("i2c_addr"));



   success = true;

   break;

  }



  case PLUGIN_INIT:

  {

   if (Plugin_068_SHT3x[event->TaskIndex])

    delete Plugin_068_SHT3x[event->TaskIndex];

   Plugin_068_SHT3x[event->TaskIndex] = new SHT3X(CONFIG(0));



   success = true;

   break;

  }



  case PLUGIN_READ:

  {

   if (!Plugin_068_SHT3x[event->TaskIndex])

    return success;



   Plugin_068_SHT3x[event->TaskIndex]->get();

   UserVar[event->BaseVarIndex + 0] = Plugin_068_SHT3x[event->TaskIndex]->tmp;

   UserVar[event->BaseVarIndex + 1] = Plugin_068_SHT3x[event->TaskIndex]->hum;

   String log = F("SHT3x: Temperature: ");

   log += UserVar[event->BaseVarIndex + 0];

   addLog(LOG_LEVEL_INFO, log);

   log = F("SHT3x: Humidity: ");

   log += UserVar[event->BaseVarIndex + 1];

   addLog(LOG_LEVEL_INFO, log);

   success = true;

   break;

  }

 }

 return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P069_LM75A.ino"
#ifdef USES_P069
# 27 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P069_LM75A.ino"
#define PLUGIN_069 

#define PLUGIN_ID_069 69

#define PLUGIN_NAME_069 "Environment - LM75A"

#define PLUGIN_VALUENAME1_069 "Temperature"





#ifndef LM75A_h

#define LM75A_h 



#define INVALID_LM75A_TEMPERATURE 1000



namespace LM75AConstValues

{

  const int LM75A_BASE_ADDRESS = 0x48;

  const float LM75A_DEGREES_RESOLUTION = 0.125;

  const int LM75A_REG_ADDR_TEMP = 0;

}



using namespace LM75AConstValues;



class LM75A

{

public:

  LM75A(bool A0_value = false, bool A1_value = false, bool A2_value = false)

  {

    _i2c_device_address = LM75A_BASE_ADDRESS;



    if (A0_value) {

      _i2c_device_address += 1;

    }



    if (A1_value) {

      _i2c_device_address += 2;

    }



    if (A2_value) {

      _i2c_device_address += 4;

    }





  }



  LM75A(uint8_t addr)

  {

    _i2c_device_address = addr;



  }



  float getTemperatureInDegrees() const

  {

    float real_result = INVALID_LM75A_TEMPERATURE;

    int16_t value = 0;





    Wire.beginTransmission(_i2c_device_address);

    Wire.write(LM75A_REG_ADDR_TEMP);

    if (Wire.endTransmission())

    {



      return real_result;

    }





    Wire.requestFrom(_i2c_device_address, (uint8_t)2);

    if (Wire.available() == 2)

    {

      value = (Wire.read() << 8) | Wire.read();

    }

    else

    {



      return real_result;

    }





    value >>= 5;





    if (value & 0x0400)

    {

      value |= 0xFC00;

    }





    real_result = (float)value * LM75A_DEGREES_RESOLUTION;



    return real_result;

  }



private:

  uint8_t _i2c_device_address;

};



#endif



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif



LM75A* PLUGIN_069_LM75A = NULL;





boolean Plugin_069(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

    {

      Device[++deviceCount].Number = PLUGIN_ID_069;

      Device[deviceCount].Type = DEVICE_TYPE_I2C;

      Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

      Device[deviceCount].Ports = 0;

      Device[deviceCount].PullUpOption = false;

      Device[deviceCount].InverseLogicOption = false;

      Device[deviceCount].FormulaOption = true;

      Device[deviceCount].ValueCount = 1;

      Device[deviceCount].SendDataOption = true;

      Device[deviceCount].TimerOption = true;

      Device[deviceCount].GlobalSyncOption = true;

      break;

    }



    case PLUGIN_GET_DEVICENAME:

    {

      string = F(PLUGIN_NAME_069);

      break;

    }



    case PLUGIN_GET_DEVICEVALUENAMES:

    {

      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_069));

      break;

    }



    case PLUGIN_WEBFORM_LOAD:

    {

      int optionValues[8] = { 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F };

      addFormSelectorI2C(F("i2c_addr"), 8, optionValues, CONFIG(0));



      success = true;

      break;

    }



    case PLUGIN_WEBFORM_SAVE:

    {

      CONFIG(0) = getFormItemInt(F("i2c_addr"));



      success = true;

      break;

    }



    case PLUGIN_INIT:

    {

      if (PLUGIN_069_LM75A)

        delete PLUGIN_069_LM75A;

      PLUGIN_069_LM75A = new LM75A((uint8_t)CONFIG(0));



      success = true;

      break;

    }



    case PLUGIN_READ:

    {

      if (!PLUGIN_069_LM75A)

        return success;



      float tempC = PLUGIN_069_LM75A->getTemperatureInDegrees();



      if (tempC == INVALID_LM75A_TEMPERATURE)

      {

        String log = F("LM75A: No reading!");

        addLog(LOG_LEVEL_INFO, log);

        UserVar[event->BaseVarIndex] = NAN;

      }

      else

      {

        UserVar[event->BaseVarIndex] = tempC;

        String log = F("LM75A: Temperature: ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

      }

      break;

    }

  }

  return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P070_NeoPixel_Clock.ino"
#ifdef USES_P070
# 13 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P070_NeoPixel_Clock.ino"
#ifdef PLUGIN_BUILD_DISABLED
# 31 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P070_NeoPixel_Clock.ino"
#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif



#include <Adafruit_NeoPixel.h>



#define NUMBER_LEDS 60



boolean Plugin_070_enabled;

byte Plugin_070_brightness;

byte Plugin_070_marks;

byte Plugin_070_offset;

boolean thick_12_mark;

byte marks[14];



Adafruit_NeoPixel * Plugin_070_pixels;



#define PLUGIN_070 

#define PLUGIN_ID_070 70

#define PLUGIN_NAME_070 "Output - NeoPixel Ring Clock [TESTING]"

#define PLUGIN_VALUENAME1_070 "Enabled"

#define PLUGIN_VALUENAME2_070 "Brightness"

#define PLUGIN_VALUENAME3_070 "Marks"

boolean Plugin_070(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_070;

        Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

        Device[deviceCount].VType = SENSOR_TYPE_TRIPLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 3;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].GlobalSyncOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_070);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_070));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_070));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_070));

        break;

      }



 case PLUGIN_GET_DEVICEGPIONAMES:

   {

      event->String1 = F("GPIO &rarr; LED");

        break;

   }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormSubHeader(F("Clock configuration"));

        addFormNumericBox(F("12 o'clock LED position"), F("offset"), CONFIG(3), 0, 59);

        addFormNote(F("Position of the 12 o'clock LED in the strip"));

        addFormCheckBox(F("Thick 12 o'clock mark"), F("thick_12_mark"), CONFIG(4));

        addFormNote(F("Check to have 3 LEDs marking the 12 o'clock position"));

        addFormCheckBox(F("Clock display enabled"), F("enabled"), CONFIG(0));

        addFormNote(F("LED activation"));

        addFormNumericBox(F("LED brightness"), F("brightness"), CONFIG(1), 0, 255);

        addFormNote(F("Brightness level of the H/M/S hands (0-255)"));

        addFormNumericBox(F("Hour mark brightness"), F("marks"), CONFIG(2), 0, 255);

        addFormNote(F("Brightness level of the hour marks (0-255)"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        CONFIG(0) = isFormItemChecked(F("enabled"));

        CONFIG(1) = getFormItemInt(F("brightness"));

        CONFIG(2) = getFormItemInt(F("marks"));

        CONFIG(3) = getFormItemInt(F("offset"));

        CONFIG(4) = isFormItemChecked(F("thick_12_mark"));



        Plugin_070_enabled = CONFIG(0);

        Plugin_070_brightness = CONFIG(1);

        Plugin_070_marks = CONFIG(2);

        Plugin_070_offset = CONFIG(3);

        thick_12_mark = CONFIG(4);



        calculateMarks();



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_070_pixels)

        {

          Plugin_070_pixels = new Adafruit_NeoPixel(NUMBER_LEDS, Settings.TaskDevicePin1[event->TaskIndex], NEO_GRB + NEO_KHZ800);

          Plugin_070_pixels->begin();

        }

        Plugin_070_enabled = CONFIG(0);

        Plugin_070_brightness = CONFIG(1);

        Plugin_070_marks = CONFIG(2);

        Plugin_070_offset = CONFIG(3);

        thick_12_mark = CONFIG(4);



        calculateMarks();



        success = true;

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        Clock_update();

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        String lowerString=string;

        lowerString.toLowerCase();

        String command = parseString(lowerString, 1);

        String param1 = parseString(lowerString, 2);

        String param2 = parseString(lowerString, 3);

        String param3 = parseString(lowerString, 4);



        if (command == F("clock")) {

          int val_Mode;

          if (validIntFromString(param1, val_Mode)) {

            if (val_Mode > -1 && val_Mode < 2) {

              Plugin_070_enabled = val_Mode;

              CONFIG(0) = Plugin_070_enabled;

            }

          }

          int val_Bright;

          if (validIntFromString(param2, val_Bright)) {

            if (val_Bright > -1 && val_Bright < 256) {

              Plugin_070_brightness = val_Bright;

              CONFIG(1) = Plugin_070_brightness;

            }

          }

          int val_Marks;

          if (validIntFromString(param3, val_Marks)) {

            if (val_Marks > -1 && val_Marks < 256) {

              Plugin_070_marks = val_Marks;

              CONFIG(2) = Plugin_070_marks;

            }

          }
# 379 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P070_NeoPixel_Clock.ino"
          success = true;

        }

        break;

      }



    case PLUGIN_READ:

      {

        UserVar[event->BaseVarIndex] = Plugin_070_enabled;

        UserVar[event->BaseVarIndex + 1] = Plugin_070_brightness;

        UserVar[event->BaseVarIndex + 2] = Plugin_070_marks;



        success = true;

      }



  }

  return success;

}



void Clock_update()

{

  clearClock();

  if (Plugin_070_enabled > 0) {

    int Hours = hour();

    int Minutes = minute();

    int Seconds = second();

    timeToStrip(Hours, Minutes, Seconds);

  }

  Plugin_070_pixels->show();

}



void calculateMarks()

{

  for (int i = 0; i < 12; i++) {

    marks[i] = 5 * i + (Plugin_070_offset % 5);

  }

  if (thick_12_mark) {

    if (Plugin_070_offset == 0) {

      marks[12] = 1;

      marks[13] = 59;

    }

    else if (Plugin_070_offset == 59) {

      marks[12] = 0;

      marks[13] = 58;

    }

    else {

      marks[12] = Plugin_070_offset + 1;

      marks[13] = Plugin_070_offset - 1;

    }

  }

  else {

    marks[12] = 255;

    marks[13] = 255;

  }

}



void clearClock() {

  for (int i = 0; i < NUMBER_LEDS; i++) {

    Plugin_070_pixels->setPixelColor(i, Plugin_070_pixels->Color(0, 0, 0));

  }

}



void timeToStrip(int hours, int minutes, int seconds) {

  if (hours > 11) hours = hours - 12;

  hours = (hours * 5) + (minutes / 12) + Plugin_070_offset;

  if (hours > 59) hours = hours - 60;

  minutes = minutes + Plugin_070_offset;

  if (minutes > 59) minutes = minutes - 60;

  seconds = seconds + Plugin_070_offset;

  if (seconds > 59) seconds = seconds - 60;

  for (int i = 0 ; i < 14; i ++) {

    if ((marks[i] != hours) && (marks[i] != minutes) && (marks[i] != seconds) && (marks[i] != 255)) {

      Plugin_070_pixels->setPixelColor(marks[i], Plugin_070_pixels->Color(Plugin_070_marks, Plugin_070_marks, Plugin_070_marks));

    }

  }

  uint32_t currentColor;

  uint8_t r_val, g_val, b_val;

  for (int i = 0; i < NUMBER_LEDS; i++) {

    if (i == hours) {

      Plugin_070_pixels->setPixelColor(i, Plugin_070_pixels->Color(Plugin_070_brightness, 0, 0));

    }

    if (i == minutes) {

      currentColor = Plugin_070_pixels->getPixelColor(i);

      r_val = (uint8_t)(currentColor >> 16);

      Plugin_070_pixels->setPixelColor(i, Plugin_070_pixels->Color(r_val, Plugin_070_brightness, 0));

    }

    if (i == seconds) {

      currentColor = Plugin_070_pixels->getPixelColor(i);

      r_val = (uint8_t)(currentColor >> 16);

      g_val = (uint8_t)(currentColor >> 8);

      Plugin_070_pixels->setPixelColor(i, Plugin_070_pixels->Color(r_val, g_val, Plugin_070_brightness));

    }

  }

}



#endif

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P071_Kamstrup401.ino"
#ifdef USES_P071
# 27 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P071_Kamstrup401.ino"
#include <ESPeasySoftwareSerial.h>

#define PLUGIN_071 

#define PLUGIN_ID_071 71

#define PLUGIN_NAME_071 "Communication - Kamstrup Multical 401 [TESTING]"

#define PLUGIN_VALUENAME1_071 "Heat"

#define PLUGIN_VALUENAME2_071 "Volume"



boolean Plugin_071_init = false;

byte PIN_KAMSER_RX = 0;

byte PIN_KAMSER_TX = 0;



boolean Plugin_071(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_071;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_DUAL;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_071);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_071));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_071));

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_071_init = true;



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        success = true;

        break;

      }



    case PLUGIN_READ:

      {

        PIN_KAMSER_RX = Settings.TaskDevicePin1[event->TaskIndex];

        PIN_KAMSER_TX = Settings.TaskDevicePin2[event->TaskIndex];



        ESPeasySoftwareSerial kamSer(PIN_KAMSER_RX, PIN_KAMSER_TX, false);



        pinMode(PIN_KAMSER_RX,INPUT);

        pinMode(PIN_KAMSER_TX,OUTPUT);





        byte sendmsg1[] = { 175,163,177 };



        byte r = 0;

        byte to = 0;

        byte i;

        char message[255];

        int parityerrors;





        kamSer.begin(300);

        for (int x = 0; x < 3; x++) {

          kamSer.write(sendmsg1[x]);

        }



        kamSer.flush();



        kamSer.begin(1200);



        to = 0;

        r = 0;

        i = 0;

        parityerrors = 0;

        char *tmpstr;

        double m_energy, m_volume;

        float m_tempin, m_tempout, m_tempdiff, m_power;

        long m_hours, m_flow;



        while(r != 0x0A)

        {

          if (kamSer.available())

          {



            r = kamSer.read();



            if (parity_check(r))

            {

               parityerrors += 1;

            }

            r = r & 127;



            message[i++] = char(r);

          }

          else

          {

            to++;

            delay(25);

          }



          if (i>=79)

          {

            if ( parityerrors == 0 )

            {





              message[i] = 0;



              tmpstr = strtok(message, " ");

              if (tmpstr){

               m_energy = atol(tmpstr)/3.6*1000;

              }

              else

               m_energy = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_volume = atol(tmpstr);

              else

               m_volume = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_hours = atol(tmpstr);

              else

               m_hours = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_tempin = atol(tmpstr)/100.0;

              else

               m_tempin = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_tempout = atol(tmpstr)/100.0;

              else

               m_tempout = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_tempdiff = atol(tmpstr)/100.0;

              else

               m_tempdiff = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_power = atol(tmpstr)/10.0;

              else

               m_power = 0;



              tmpstr = strtok(NULL, " ");

              if (tmpstr)

               m_flow = atol(tmpstr);

              else

               m_flow = 0;



               String log = F("Kamstrup output: ");

               log += m_energy;

               log += F(" MJ;  ");

               log += m_volume;

               log += F(" L; ");

               log += m_hours;

               log += F(" h; ");

               log += m_tempin;

               log += F(" C; ");

               log += m_tempout;

               log += F(" C; ");

               log += m_tempdiff;

               log += F(" C; ");

               log += m_power;

               log += F(" ");

               log += m_flow;

               log += F(" L/H");





              UserVar[event->BaseVarIndex] = m_energy;

              UserVar[event->BaseVarIndex+1] = m_volume;



              log = F("Kamstrup  : Heat value: ");

              log += m_energy/1000;

              log += F(" kWh");

              addLog(LOG_LEVEL_INFO, log);

              log = F("Kamstrup  : Volume value: ");

              log += m_volume;

              log += F(" Liter");

              addLog(LOG_LEVEL_INFO, log);

            }

            else

            {

              message[i] = 0;

              String log = F("ERR(PARITY):" );

              Serial.print("par");

              log += message;

              addLog(LOG_LEVEL_INFO, log);





            }

            break;

          }

          if (to>100)

          {

            message[i] = 0;

            String log = F("ERR(TIMEOUT):" );

            log += message;

            addLog(LOG_LEVEL_INFO, log);







            break;

          }

        }
# 497 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P071_Kamstrup401.ino"
        success = true;

        break;

      }

  }

  return success;

}



bool parity_check(unsigned input) {

    bool inputparity = input & 128;

    int x = input & 127;



    int parity = 0;

    while(x != 0) {

        parity ^= x;

        x >>= 1;

    }



    if ( (parity & 0x1) != inputparity )

      return(1);

    else

      return(0);

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P072_HDC1080.ino"
#ifdef USES_P072
# 13 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P072_HDC1080.ino"
#define PLUGIN_072 

#define PLUGIN_ID_072 72

#define PLUGIN_NAME_072 "Environment - HDC1080 (I2C) [TESTING]"

#define PLUGIN_VALUENAME1_072 "Temperature"

#define PLUGIN_VALUENAME2_072 "Humidity"



boolean Plugin_072_init = false;



#define HDC1080_I2C_ADDRESS 0x40



boolean Plugin_072(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_072;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].VType = SENSOR_TYPE_TEMP_HUM;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 2;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_072);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_072));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_072));

        break;

      }



    case PLUGIN_READ:

      {

        byte hdc1080_msb, hdc1080_lsb;

        uint16_t hdc1080_rawtemp, hdc1080_rawhum;

        float hdc1080_temp, hdc1080_hum;



        Wire.beginTransmission(HDC1080_I2C_ADDRESS);

        Wire.write(0x02);

        Wire.write(0b00000000);

        Wire.write(0x00);

        Wire.endTransmission();

        delay(10);



        Wire.beginTransmission(HDC1080_I2C_ADDRESS);

        Wire.write(0x00);

        Wire.endTransmission();

        delay(9);

        Wire.requestFrom(HDC1080_I2C_ADDRESS, 2);

        hdc1080_msb = Wire.read();

        hdc1080_lsb = Wire.read();

        hdc1080_rawtemp = hdc1080_msb << 8 | hdc1080_lsb;

        hdc1080_temp = (hdc1080_rawtemp / pow(2,16)) * 165 -40;



        Wire.beginTransmission(HDC1080_I2C_ADDRESS);

        Wire.write(0x01);

        Wire.endTransmission();

        delay(9);

        Wire.requestFrom(HDC1080_I2C_ADDRESS, 2);

        hdc1080_msb = Wire.read();

        hdc1080_lsb = Wire.read();

        hdc1080_rawhum = hdc1080_msb << 8 | hdc1080_lsb;

        hdc1080_hum = (hdc1080_rawhum / pow(2,16)) * 100;



        UserVar[event->BaseVarIndex] = hdc1080_temp;

        UserVar[event->BaseVarIndex + 1] = hdc1080_hum;

        String log = F("HDC1080: Temperature: ");

        log += UserVar[event->BaseVarIndex];

        addLog(LOG_LEVEL_INFO, log);

        log = F("HDC1080: Humidity: ");

        log += UserVar[event->BaseVarIndex + 1];

        addLog(LOG_LEVEL_INFO, log);

        success = true;

        break;



      }

  }

  return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P073_7DGT.ino"
#ifdef USES_P073
# 53 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P073_7DGT.ino"
#define PLUGIN_073 

#define PLUGIN_ID_073 73

#define PLUGIN_NAME_073 "Display - 7-segment display [TESTING]"

#define PLUGIN_073_DEBUG false
# 69 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P073_7DGT.ino"
class p073_7dgt

{

  public:

    uint8_t pin1, pin2, pin3;

    byte type;

    byte output;

    byte brightness;

    boolean timesep;

};

p073_7dgt *Plugin_073_7dgt = NULL;





uint8_t p073_showbuffer[8];

byte p073_spidata[2];

byte p073_dotpos;

bool p073_shift;



#define TM1637_POWER_ON B10001000

#define TM1637_POWER_OFF B10000000

#define TM1637_CLOCKDELAY 40

#define TM1637_4DIGIT 4

#define TM1637_6DIGIT 2
# 125 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P073_7DGT.ino"
const PROGMEM byte CharTableTM1637 [13] = {B00111111,B00000110,B01011011,B01001111,B01100110,B01101101,B01111101,B00000111,B01111111,B01101111,B00000000,B01000000,B01100011};

const PROGMEM byte CharTableMAX7219 [13] = {B01111110,B00110000,B01101101,B01111001,B00110011,B01011011,B01011111,B01110000,B01111111,B01111011,B00000000,B00000001,B01100011};



boolean Plugin_073(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_073;

        Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;

        Device[deviceCount].VType = SENSOR_TYPE_NONE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = false;

        Device[deviceCount].ValueCount = 0;

        Device[deviceCount].SendDataOption = false;

        Device[deviceCount].TimerOption = false;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_073);

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormNote(F("TM1637:  1st=CLK-Pin, 2nd=DIO-Pin"));

        addFormNote(F("MAX7219: 1st=DIN-Pin, 2nd=CLK-Pin, 3rd=CS-Pin"));

        String displtype[5] = { F("TM1637 - 4 digit (colon)"), F("TM1637 - 4 digit (dots)"), F("TM1637 - 6 digit"), F("MAX7219 - 8 digit")};

        addFormSelector(F("Display Type"), F("plugin_073_displtype"), 4, displtype, NULL, Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        String displout[4] = { F("Manual"), F("Clock - Blink"), F("Clock - No Blink"), F("Date") };

        addFormSelector(F("Display Output"), F("plugin_073_displout"), 4, displout, NULL, Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        addFormNumericBox(F("Brightness"), F("plugin_073_brightness"), Settings.TaskDevicePluginConfig[event->TaskIndex][2], 0, 15);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_073_displtype"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_073_displout"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_073_brightness"));

        if (Plugin_073_7dgt) {



          Plugin_073_7dgt->pin1 = Settings.TaskDevicePin1[event->TaskIndex];



          Plugin_073_7dgt->pin2 = Settings.TaskDevicePin2[event->TaskIndex];



          Plugin_073_7dgt->pin3 = Settings.TaskDevicePin3[event->TaskIndex];

          Plugin_073_7dgt->type = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

          Plugin_073_7dgt->output = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

          Plugin_073_7dgt->brightness = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

          Plugin_073_7dgt->timesep = true;

          switch (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

          {

            case 0:

            case 1:

            case 2:

              {

                int tm1637_bright = Settings.TaskDevicePluginConfig[event->TaskIndex][2] / 2;

                tm1637_SetPowerBrightness(tm1637_bright, true);

                if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 0)

                  tm1637_ClearDisplay();

                break;

              }

            case 3:

              {

                max7219_SetPowerBrightness(Settings.TaskDevicePluginConfig[event->TaskIndex][2], true);

                if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 0)

                  max7219_ClearDisplay();

                break;

              }

          }

        }

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        if (!Plugin_073_7dgt) {

          Plugin_073_7dgt = new p073_7dgt;

            Plugin_073_7dgt->pin1 = Settings.TaskDevicePin1[event->TaskIndex];

            Plugin_073_7dgt->pin2 = Settings.TaskDevicePin2[event->TaskIndex];

            Plugin_073_7dgt->pin3 = Settings.TaskDevicePin3[event->TaskIndex];

            Plugin_073_7dgt->type = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

            Plugin_073_7dgt->output = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

            Plugin_073_7dgt->brightness = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

          switch (Settings.TaskDevicePluginConfig[event->TaskIndex][0])

          {

            case 0:

            case 1:

            case 2:

              {

                tm1637_InitDisplay();

                int tm1637_bright = Settings.TaskDevicePluginConfig[event->TaskIndex][2] / 2;

                tm1637_SetPowerBrightness(tm1637_bright, true);

                break;

              }

            case 3:

              {

                max7219_InitDisplay();

                max7219_SetPowerBrightness(Settings.TaskDevicePluginConfig[event->TaskIndex][2], true);

                break;

              }

          }

        }

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (!Plugin_073_7dgt)

          break;



        String tmpString = string;

        int argIndex = tmpString.indexOf(',');

        if (argIndex)

          tmpString = tmpString.substring(0, argIndex);



        String tmpStr = string;

        int comma1 = tmpStr.indexOf(',');



        if (tmpString.equalsIgnoreCase(F("7dn"))) {

          if (Plugin_073_7dgt->output != 0)

            break;

          String log = F("7DGT : Show Number=");

          log += event->Par1;

          addLog(LOG_LEVEL_INFO, log);

          switch (Plugin_073_7dgt->type)

          {

            case 0:

              if (event->Par1 > -1000 && event->Par1 < 10000)

                p073_FillBufferWithNumber(String(int(event->Par1)));

              else

                p073_FillBufferWithDash();

              tm1637_ShowBuffer(TM1637_4DIGIT);

              break;

            case 1:

            {

              if (event->Par1 > -1000 && event->Par1 < 10000)

                p073_FillBufferWithNumber(tmpStr.substring(comma1+1).c_str());

              else

                p073_FillBufferWithDash();

              tm1637_ShowBuffer(TM1637_4DIGIT);

              break;

            }

            case 2:

            {

              if (event->Par1 > -100000 && event->Par1 < 1000000)

                p073_FillBufferWithNumber(tmpStr.substring(comma1+1).c_str());

              else

                p073_FillBufferWithDash();

              tm1637_SwapDigitInBuffer();

              tm1637_ShowBuffer(TM1637_6DIGIT);

              break;

            }

            case 3:

            {

              if (comma1 > 0) {

                if (event->Par1 > -10000000 && event->Par1 < 100000000) {

                  p073_FillBufferWithNumber(tmpStr.substring(comma1+1).c_str());

                }

                else

                  p073_FillBufferWithDash();

                max7219_ShowBuffer();

              }

              break;

            }

          }

          success = true;

        } else if (tmpString.equalsIgnoreCase(F("7dt"))) {

          if (Plugin_073_7dgt->output != 0)

            break;

          double p073_temptemp = 0;

          bool p073_tempflagdot = false;

          if (comma1 > 0)

            p073_temptemp = atof(tmpStr.substring(comma1+1).c_str());

          String log = F("7DGT : Show Temperature=");

          log += p073_temptemp;

          addLog(LOG_LEVEL_INFO, log);

          switch (Plugin_073_7dgt->type)

          {

            case 0:

            case 1:

            {

              if (p073_temptemp > 999 || p073_temptemp < -99.9)

                p073_FillBufferWithDash();

              else {

                if (p073_temptemp < 100 && p073_temptemp > -10) {

                  p073_temptemp = int(p073_temptemp*10);

                  p073_tempflagdot = true;

                }

                p073_FillBufferWithTemp(p073_temptemp);

                if (p073_temptemp == 0 && p073_tempflagdot)

                  p073_showbuffer[5] = 0;

              }

              tm1637_ShowTimeTemp4(p073_tempflagdot, 4);

              break;

            }

            case 2:

            {

              if (p073_temptemp > 999 || p073_temptemp < -99.9)

                p073_FillBufferWithDash();

              else {

                if (p073_temptemp < 100 && p073_temptemp > -10) {

                  p073_temptemp = int(p073_temptemp*10);

                  p073_tempflagdot = true;

                }

                p073_FillBufferWithTemp(p073_temptemp);

                if (p073_temptemp == 0 && p073_tempflagdot)

                  p073_showbuffer[5] = 0;

              }

              tm1637_ShowTemp6(p073_tempflagdot);

              break;

            }

            case 3:

            {

              p073_temptemp = int(p073_temptemp*10);

              p073_FillBufferWithTemp(p073_temptemp);

              if (p073_temptemp == 0)

                p073_showbuffer[5] = 0;

              max7219_ShowTemp();

              break;

            }

          }

          success = true;

        } else {

          bool p073_validcmd = false;

          bool p073_displayon;

          if (tmpString.equalsIgnoreCase(F("7don"))) {

            String log = F("7DGT : Display ON");

            addLog(LOG_LEVEL_INFO, log);

            p073_displayon = true;

            p073_validcmd = true;

          }

          else if (tmpString.equalsIgnoreCase(F("7doff"))) {

            String log = F("7DGT : Display OFF");

            addLog(LOG_LEVEL_INFO, log);

            p073_displayon = false;

            p073_validcmd = true;

          }

          else if (tmpString.equalsIgnoreCase(F("7db"))) {

            if (event->Par1 >= 0 && event->Par1 < 16) {

              String log = F("7DGT : Brightness=");

              log += event->Par1;

              addLog(LOG_LEVEL_INFO, log);

              Plugin_073_7dgt->brightness = event->Par1;

              p073_displayon = true;

              p073_validcmd = true;

            }

          }

          if (p073_validcmd) {

            success = true;

            switch (Plugin_073_7dgt->type)

            {

              case 0:

              case 1:

              case 2:

              { int tm1637_bright = Plugin_073_7dgt->brightness / 2;

                tm1637_SetPowerBrightness(tm1637_bright, p073_displayon);

                break; }

              case 3:

              { max7219_SetPowerBrightness(Plugin_073_7dgt->brightness, p073_displayon);

                break; }

            }

          }

        }

        break;

      }



    case PLUGIN_ONCE_A_SECOND:

      {

        if (Plugin_073_7dgt->output == 0)

          break;



        if (Plugin_073_7dgt->output == 1)

          { Plugin_073_7dgt->timesep = !Plugin_073_7dgt->timesep; }

        else

          { Plugin_073_7dgt->timesep = true; }



        if (Plugin_073_7dgt->output == 3)

          p073_FillBufferWithDate();

        else

          p073_FillBufferWithTime();



        switch (Plugin_073_7dgt->type)

        {

          case 0:

          case 1:

          {

            tm1637_ShowTimeTemp4(Plugin_073_7dgt->timesep, 0);

            break;

          }

          case 2:

          {

            if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 3)

              tm1637_ShowDate6(Plugin_073_7dgt->timesep);

            else

              tm1637_ShowTime6(Plugin_073_7dgt->timesep);

            break;

          }

          case 3:

          {

            if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 3)

              max7219_ShowDate();

            else

              max7219_ShowTime(Plugin_073_7dgt->timesep);

            break;

          }

        }

      }



  }

  return success;

}



void p073_FillBufferWithTime(void)

{

  memset(p073_showbuffer,0,sizeof(p073_showbuffer));

  byte sevendgt_hours = hour();

  byte sevendgt_minutes = minute();

  byte sevendgt_seconds = second();

  uint8_t p073_digit1, p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_hours / 10);

  p073_digit2 = sevendgt_hours - p073_digit1*10;

  p073_showbuffer[0] = p073_digit1; p073_showbuffer[1] = p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_minutes / 10);

  p073_digit2 = sevendgt_minutes - p073_digit1*10;

  p073_showbuffer[2] = p073_digit1; p073_showbuffer[3] = p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_seconds / 10);

  p073_digit2 = sevendgt_seconds - p073_digit1*10;

  p073_showbuffer[4] = p073_digit1; p073_showbuffer[5] = p073_digit2;

}



void p073_FillBufferWithDate(void)

{

  memset(p073_showbuffer,0,sizeof(p073_showbuffer));

  byte sevendgt_day = day();

  byte sevendgt_month = month();

  byte sevendgt_year1 = uint8_t(year()/100);

  byte sevendgt_year2 = uint8_t(year()-(sevendgt_year1*100));

  uint8_t p073_digit1, p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_day / 10);

  p073_digit2 = sevendgt_day - p073_digit1*10;

  p073_showbuffer[0] = p073_digit1; p073_showbuffer[1] = p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_month / 10);

  p073_digit2 = sevendgt_month - p073_digit1*10;

  p073_showbuffer[2] = p073_digit1; p073_showbuffer[3] = p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_year1 / 10);

  p073_digit2 = sevendgt_year1 - p073_digit1*10;

  p073_showbuffer[4] = p073_digit1; p073_showbuffer[5] = p073_digit2;

  p073_digit1 = (uint8_t)(sevendgt_year2 / 10);

  p073_digit2 = sevendgt_year2 - p073_digit1*10;

  p073_showbuffer[6] = p073_digit1; p073_showbuffer[7] = p073_digit2;

}



void p073_FillBufferWithNumber(String number)

{

  memset(p073_showbuffer,10,sizeof(p073_showbuffer));

  byte p073_numlenght = number.length();

  byte p073_dispdigit;

  byte p073_index = 7;

  p073_dotpos = -1;

  for (int i=p073_numlenght;i>0;i--) {

    char p073_tmpchar = number.charAt(i-1);

    p073_dispdigit = 10;

    if (p073_tmpchar > 47 && p073_tmpchar < 58)

      p073_dispdigit = p073_tmpchar-48;

    else if (p073_tmpchar == 32)

      p073_dispdigit = 10;

    else if (p073_tmpchar == 45)

      p073_dispdigit = 11;

    if (p073_tmpchar == 46)

      p073_dotpos = p073_index;

    else {

      p073_showbuffer[p073_index] = p073_dispdigit;

      p073_index--; }

  }

}



void p073_FillBufferWithTemp(long temperature)

{

  memset(p073_showbuffer,10,sizeof(p073_showbuffer));

  char p073_digit[8];

  sprintf(p073_digit, "%7d", static_cast<int>(temperature));

  int p073_numlenght = strlen(p073_digit);

  byte p073_dispdigit;

  for (int i=0;i<p073_numlenght;i++) {

    if (p073_digit[i] > 47 && p073_digit[i] < 58)

      p073_dispdigit = p073_digit[i]-48;

    else if (p073_digit[i] == 32)

      p073_dispdigit = 10;

    else if (p073_digit[i] == 45)

      p073_dispdigit = 11;

    p073_showbuffer[i] = p073_dispdigit;

  }

  p073_showbuffer[7] = 12;

}



void p073_FillBufferWithDash(void)

{

  memset(p073_showbuffer,11,sizeof(p073_showbuffer));

}
# 961 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P073_7DGT.ino"
#define CLK_HIGH() digitalWrite(Plugin_073_7dgt->pin2, HIGH)

#define CLK_LOW() digitalWrite(Plugin_073_7dgt->pin2, LOW)

#define DIO_HIGH() pinMode(Plugin_073_7dgt->pin1, INPUT)

#define DIO_LOW() pinMode(Plugin_073_7dgt->pin1, OUTPUT)



void tm1637_i2cStart (void)

{

  if (PLUGIN_073_DEBUG) {

    String log = F("7DGT : Comm Start");

    addLog(LOG_LEVEL_INFO, log);

  }

  DIO_HIGH();

  CLK_HIGH();

  delayMicroseconds(TM1637_CLOCKDELAY);

  DIO_LOW();

}



void tm1637_i2cStop (void)

{

  if (PLUGIN_073_DEBUG) {

    String log = F("7DGT : Comm Stop");

    addLog(LOG_LEVEL_INFO, log);

  }

  CLK_LOW();

  delayMicroseconds(TM1637_CLOCKDELAY);

  DIO_LOW();

  delayMicroseconds(TM1637_CLOCKDELAY);

  CLK_HIGH();

  delayMicroseconds(TM1637_CLOCKDELAY);

  DIO_HIGH();

}



void tm1637_i2cAck (void)

{

  bool dummyAck = false;

  CLK_LOW();

  pinMode(Plugin_073_7dgt->pin1, INPUT_PULLUP);



  delayMicroseconds(TM1637_CLOCKDELAY);



  dummyAck = digitalRead(Plugin_073_7dgt->pin1);

  if (PLUGIN_073_DEBUG) {

    String log = F("7DGT : Comm ACK=");

    if (dummyAck == 0) { log += F("TRUE"); } else { log += F("FALSE"); }

    addLog(LOG_LEVEL_INFO, log);

  }

  CLK_HIGH();

  delayMicroseconds(TM1637_CLOCKDELAY);

  CLK_LOW();

  pinMode(Plugin_073_7dgt->pin1, OUTPUT);

}



void tm1637_i2cWrite (uint8_t bytetoprint)

{

  if (PLUGIN_073_DEBUG) {

    String log = F("7DGT : WriteByte");

    addLog(LOG_LEVEL_INFO, log);

  }

  uint8_t i;

  for(i=0; i<8; i++)

  {

    CLK_LOW();

    (bytetoprint & B00000001)? DIO_HIGH() : DIO_LOW();

    delayMicroseconds(TM1637_CLOCKDELAY);

    bytetoprint = bytetoprint >> 1;

    CLK_HIGH();

    delayMicroseconds(TM1637_CLOCKDELAY);

  }

}



void tm1637_ClearDisplay (void)

{

  tm1637_i2cStart();

  tm1637_i2cWrite(0xC0); tm1637_i2cAck();

  for (uint8_t i=0; i<6; i++)

    tm1637_i2cWrite(0); tm1637_i2cAck();

  tm1637_i2cStop();

}



void tm1637_SetPowerBrightness (uint8_t brightlvl, bool poweron)

{

  if (PLUGIN_073_DEBUG) {

    String log = F("7DGT : Set BRIGHT");

    addLog(LOG_LEVEL_INFO, log);

  }

  uint8_t brightvalue = (brightlvl & 0b111);

  if (poweron)

    brightvalue = TM1637_POWER_ON | brightvalue;

  else

    brightvalue = TM1637_POWER_OFF | brightvalue;

  tm1637_i2cStart();

  tm1637_i2cWrite(brightvalue);

  tm1637_i2cAck();

  tm1637_i2cStop();

}



void tm1637_InitDisplay(void)

{

  pinMode(Plugin_073_7dgt->pin2, OUTPUT);

  pinMode(Plugin_073_7dgt->pin1, OUTPUT);

  CLK_HIGH();

  DIO_HIGH();





  tm1637_i2cStart();

  tm1637_i2cWrite(0x40);

  tm1637_i2cAck();

  tm1637_i2cStop();

  tm1637_ClearDisplay();

}



void tm1637_ShowTime6(bool sep)

{

  byte p073_datashowpos1;

  tm1637_i2cStart();

  tm1637_i2cWrite(0xC0); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[2])); tm1637_i2cAck();



    p073_datashowpos1 = get_byte_CharTableTM1637(p073_showbuffer[1]);

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(p073_datashowpos1); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[0])); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[5])); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[4])); tm1637_i2cAck();



    p073_datashowpos1 = get_byte_CharTableTM1637(p073_showbuffer[3]);

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(p073_datashowpos1); tm1637_i2cAck();

  tm1637_i2cStop();

}



void tm1637_ShowDate6(bool sep)

{

  byte p073_datashowpos1;

  tm1637_i2cStart();

  tm1637_i2cWrite(0xC0); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[2])); tm1637_i2cAck();



    p073_datashowpos1 = get_byte_CharTableTM1637(p073_showbuffer[1]);

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(p073_datashowpos1); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[0])); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[7])); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[6])); tm1637_i2cAck();



    p073_datashowpos1 = get_byte_CharTableTM1637(p073_showbuffer[3]);

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(p073_datashowpos1); tm1637_i2cAck();

  tm1637_i2cStop();

}



void tm1637_ShowTemp6(bool sep)

{

  tm1637_i2cStart();

  tm1637_i2cWrite(0xC0); tm1637_i2cAck();



    byte p073_datashowpos1 = get_byte_CharTableTM1637(p073_showbuffer[5]);

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(p073_datashowpos1); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[4])); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(10)); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(10)); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[7])); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[6])); tm1637_i2cAck();

  tm1637_i2cStop();

}



void tm1637_ShowTimeTemp4(bool sep, byte bufoffset)

{

  tm1637_i2cStart();

  tm1637_i2cWrite(0xC0); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[0+bufoffset])); tm1637_i2cAck();



    byte p073_datashowpos1 = get_byte_CharTableTM1637(p073_showbuffer[1+bufoffset]);

    if (sep) p073_datashowpos1 |= 0b10000000;

  tm1637_i2cWrite(p073_datashowpos1); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[2+bufoffset])); tm1637_i2cAck();

  tm1637_i2cWrite(get_byte_CharTableTM1637(p073_showbuffer[3+bufoffset])); tm1637_i2cAck();

  tm1637_i2cStop();

}



void tm1637_SwapDigitInBuffer() {

  uint8_t p073_temp;

  p073_temp = p073_showbuffer[4]; p073_showbuffer[4] = p073_showbuffer[2]; p073_showbuffer[2] = p073_temp;

  p073_temp = p073_showbuffer[5]; p073_showbuffer[5] = p073_showbuffer[7]; p073_showbuffer[7] = p073_temp;

  switch (p073_dotpos)

  {

    case 2: { p073_dotpos = 4; break; }

    case 4: { p073_dotpos = 2; break; }

    case 5: { p073_dotpos = 7; break; }

    case 7: { p073_dotpos = 5; break; }

  }

}



void tm1637_ShowBuffer(byte digits)

{

  byte p073_datashowpos1;

  tm1637_i2cStart();

  tm1637_i2cWrite(0xC0); tm1637_i2cAck();

    for(int i=digits;i<8;i++) {

    p073_datashowpos1 = get_byte_CharTableTM1637(p073_showbuffer[i]);

    if (p073_dotpos == i) p073_datashowpos1 |= 0b10000000;

    tm1637_i2cWrite(p073_datashowpos1); tm1637_i2cAck();

  }

  tm1637_i2cStop();

}
# 1383 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P073_7DGT.ino"
#define OP_DECODEMODE 9

#define OP_INTENSITY 10

#define OP_SCANLIMIT 11

#define OP_SHUTDOWN 12

#define OP_DISPLAYTEST 15



void max7219_spiTransfer (byte opcode, byte data)

{

  p073_spidata[0]=(byte)0; p073_spidata[1]=(byte)0;

  p073_spidata[1]=opcode; p073_spidata[0]=data;

  digitalWrite(Plugin_073_7dgt->pin3,LOW);

  shiftOut(Plugin_073_7dgt->pin1,Plugin_073_7dgt->pin2,MSBFIRST,p073_spidata[1]);

  shiftOut(Plugin_073_7dgt->pin1,Plugin_073_7dgt->pin2,MSBFIRST,p073_spidata[0]);

  digitalWrite(Plugin_073_7dgt->pin3,HIGH);

}



void max7219_ClearDisplay (void)

{

  for(int i=0;i<8;i++) {

    max7219_spiTransfer(i+1, 0);

  }

}



void max7219_SetPowerBrightness (uint8_t brightlvl, bool poweron)

{

  max7219_spiTransfer(OP_INTENSITY, brightlvl);

  if (poweron)

    max7219_spiTransfer(OP_SHUTDOWN, 1);

  else

    max7219_spiTransfer(OP_SHUTDOWN, 0);

}



void max7219_SetDigit(int dgtpos, byte dgtvalue, boolean showdot)

{

  byte p073_tempvalue;

  p073_tempvalue = pgm_read_byte(&CharTableMAX7219[dgtvalue]);

  if(showdot)

    p073_tempvalue |= 0b10000000;

  max7219_spiTransfer(dgtpos+1, p073_tempvalue);

}



void max7219_InitDisplay(void)

{

  pinMode(Plugin_073_7dgt->pin1, OUTPUT);

  pinMode(Plugin_073_7dgt->pin2, OUTPUT);

  pinMode(Plugin_073_7dgt->pin3, OUTPUT);

  digitalWrite(Plugin_073_7dgt->pin3, HIGH);

  max7219_spiTransfer(OP_DISPLAYTEST, 0);

  max7219_spiTransfer(OP_SCANLIMIT, 7);

  max7219_spiTransfer(OP_DECODEMODE, 0);

  max7219_ClearDisplay();

  max7219_SetPowerBrightness(0, false);

}



void max7219_ShowTime(bool sep)

{

  max7219_SetDigit(0, p073_showbuffer[5], false);

  max7219_SetDigit(1, p073_showbuffer[4], false);

  max7219_SetDigit(3, p073_showbuffer[3], false);

  max7219_SetDigit(4, p073_showbuffer[2], false);

  max7219_SetDigit(6, p073_showbuffer[1], false);

  max7219_SetDigit(7, p073_showbuffer[0], false);

  if (sep) {

    max7219_SetDigit(2, 11, false);

    max7219_SetDigit(5, 11, false);

  }

  else {

    max7219_SetDigit(2, 10, false);

    max7219_SetDigit(5, 10, false);

  }

}



void max7219_ShowTemp(void)

{

  max7219_SetDigit(0, 10, false);

  byte dotflags[8] = {false,false,false,false,false,true,false,false};

  for(int i=1;i<8;i++)

    max7219_SetDigit(i, p073_showbuffer[8-i], dotflags[8-i]);

}



void max7219_ShowDate(void)

{

  byte dotflags[8] = {false,true,false,true,false,false,false,false};

  for(int i=0;i<8;i++)

    max7219_SetDigit(i, p073_showbuffer[7-i], dotflags[7-i]);

}



void max7219_ShowBuffer(void)

{

  byte dotflags[8] = {false,false,false,false,false,false,false,false};

  if (p073_dotpos >= 0) dotflags[p073_dotpos] = true;

  for(int i=0;i<8;i++)

    max7219_SetDigit(i, p073_showbuffer[7-i], dotflags[7-i]);

}



uint8_t get_byte_CharTableTM1637(uint8_t index)

{

  return pgm_read_byte(&CharTableTM1637[index]);

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P074_TSL2591.ino"
#ifdef USES_P074
# 27 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P074_TSL2591.ino"
#define PLUGIN_074 

#define PLUGIN_ID_074 74

#define PLUGIN_NAME_074 "Light/Lux - TSL2591 [TESTING]"

#define PLUGIN_VALUENAME1_074 "Lux"

#define PLUGIN_VALUENAME2_074 "Full"

#define PLUGIN_VALUENAME3_074 "Visible"

#define PLUGIN_VALUENAME4_074 "IR"





#include <Adafruit_Sensor.h>

#include "Adafruit_TSL2591.h"



#ifndef CONFIG

#define CONFIG(n) (Settings.TaskDevicePluginConfig[event->TaskIndex][n])

#endif



Adafruit_TSL2591 tsl;

boolean TSL2591_initialized = false;



boolean Plugin_074(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_074;

        Device[deviceCount].Type = DEVICE_TYPE_I2C;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].VType = SENSOR_TYPE_QUAD;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = false;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_074);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_074));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_074));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_074));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_074));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        int optionValues[1] = { TSL2591_ADDR };

        addFormSelectorI2C(F("plugin_074_i2c_addr"), 1, optionValues, TSL2591_ADDR);
# 167 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P074_TSL2591.ino"
        String optionsMode[6] = { F("100ms"), F("200ms"), F("300ms"), F("400ms"), F("500ms"), F("600ms") };

        addFormSelector(F("Integration Time"), F("plugin_074_itime"), 6, optionsMode, NULL, CONFIG(1));
# 185 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P074_TSL2591.ino"
        String optionsGain[4] = {

          F("low gain (1x)"),

          F("medium gain (25x)"),

          F("medium gain (428x)"),

          F("max gain (9876x)") };

        addFormSelector(F("Value Mapping"), F("plugin_074_gain"), 4, optionsGain, NULL, CONFIG(2));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {



        CONFIG(1) = getFormItemInt(F("plugin_074_itime"));

        CONFIG(2) = getFormItemInt(F("plugin_074_gain"));



        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

       tsl = Adafruit_TSL2591(2591);



        if (tsl.begin())

        {

          String log = F("TSL2591: Address: 0x");

          log += String(TSL2591_ADDR,HEX);
# 251 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P074_TSL2591.ino"
          switch (CONFIG(1))

          {

            default:

            case 0:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_100MS);

              break;

            }

            case 1:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_200MS);

              break;

            }

            case 2:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_300MS);

              break;

            }

            case 3:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_400MS);

              break;

            }

            case 4:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_500MS);

              break;

            }

            case 5:

            {

             tsl.setTiming(TSL2591_INTEGRATIONTIME_600MS);

              break;

            }

          }



          log += F(": Integration Time: ");

          log += String((tsl.getTiming() + 1) * 100, DEC);

          log += F(" ms");







      switch (CONFIG(2))

      {

       default:

       case 0:

       {

        tsl.setGain(TSL2591_GAIN_LOW);

        break;

       }

       case 1:

       {

        tsl.setGain(TSL2591_GAIN_MED);

        break;

       }

       case 2:

       {

        tsl.setGain(TSL2591_GAIN_HIGH);

        break;

       }

       case 3:

       {

        tsl.setGain(TSL2591_GAIN_MAX);

        break;

       }

      }
# 389 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P074_TSL2591.ino"
      log += (F(" Gain: "));

          tsl2591Gain_t gain = tsl.getGain();

          switch(gain)

          {

            case TSL2591_GAIN_LOW:

             log += F("1x (Low)");

              break;

            case TSL2591_GAIN_MED:

             log += F("25x (Medium)");

              break;

            case TSL2591_GAIN_HIGH:

             log += F("428x (High)");

              break;

            case TSL2591_GAIN_MAX:

             log += F("9876x (Max)");

              break;

          }



          TSL2591_initialized = true;

          addLog(LOG_LEVEL_INFO,log);



        }

        else

        {

         TSL2591_initialized = false;

         addLog(LOG_LEVEL_ERROR,F("TSL2591: No sensor found ... check your wiring?"));

        }





        success = true;

        break;

      }



    case PLUGIN_READ:

      {

       if (TSL2591_initialized)

       {







     float lux, full, visible, ir;

     visible = tsl.getLuminosity(TSL2591_VISIBLE);

     ir = tsl.getLuminosity(TSL2591_INFRARED);

     full = tsl.getLuminosity(TSL2591_FULLSPECTRUM);

     lux = tsl.calculateLuxf(full, ir);



     UserVar[event->BaseVarIndex + 0] = lux;

     UserVar[event->BaseVarIndex + 1] = full;

     UserVar[event->BaseVarIndex + 2] = visible;

     UserVar[event->BaseVarIndex + 3] = ir;



     String log = F("TSL2591: Lux: ");

     log += String(lux);

     log += F(" Full: ");

     log += String(full);

     log += F(" Visible: ");

     log += String(visible);

     log += F(" IR: ");

     log += String(ir);

     addLog(LOG_LEVEL_INFO,log);

          success = true;

       }

       else {

        addLog(LOG_LEVEL_ERROR,F("TSL2591: Sensor not initialized!?"));

       }

        break;

      }



  }

  return success;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P075_Nextion.ino"
# 29 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P075_Nextion.ino"
#ifdef USES_P075

#include <ESPeasySoftwareSerial.h>
# 45 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P075_Nextion.ino"
#define PLUGIN_075 

#define PLUGIN_ID_075 75

#define PLUGIN_NAME_075 "Display - Nextion [TESTING]"

#define PLUGIN_DEFAULT_NAME "NEXTION"

#define PLUGIN_VALUENAME1_075 "idx"

#define PLUGIN_VALUENAME2_075 "value"
# 65 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P075_Nextion.ino"
#define Nlines 10

#define Lenlines 51





#define RXBUFFSZ 64

#define RXBUFFWARN RXBUFFSZ-16

#define TOUCH_BASE 500





#define B9600 0

#define B38400 1

#define B57600 2

#define B115200 3

#define DEFAULT_BAUD B9600

#define SOFTSERIAL 0

#define UARTSERIAL 1







ESPeasySoftwareSerial *SoftSerial = NULL;

char deviceTemplate[Nlines][Lenlines];

int rxPin = -1;

int txPin = -1;
# 123 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P075_Nextion.ino"
boolean Plugin_075(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;

  static uint8_t BaudCode = 0;

  static boolean HwSerial = SOFTSERIAL;

  static boolean AdvHwSerial = false;

  static boolean IncludeValues = false;

  uint32_t AdvHwBaud = 9600UL;



  switch (function) {



    case PLUGIN_DEVICE_ADD: {

      Device[++deviceCount].Number = PLUGIN_ID_075;

      Device[deviceCount].Type = DEVICE_TYPE_DUAL;

      Device[deviceCount].VType = SENSOR_TYPE_DUAL;

      Device[deviceCount].Ports = 0;

      Device[deviceCount].PullUpOption = false;

      Device[deviceCount].InverseLogicOption = false;

      Device[deviceCount].FormulaOption = false;

      Device[deviceCount].ValueCount = 2;

      Device[deviceCount].SendDataOption = true;

      Device[deviceCount].TimerOption = true;

      Device[deviceCount].TimerOptional = true;

      Device[deviceCount].GlobalSyncOption = true;

      break;

    }





    case PLUGIN_GET_DEVICENAME: {

      string = F(PLUGIN_NAME_075);

      break;

    }





    case PLUGIN_GET_DEVICEVALUENAMES: {

      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0],PSTR(PLUGIN_VALUENAME1_075));

      strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1],PSTR(PLUGIN_VALUENAME2_075));

      break;

    }





    case PLUGIN_GET_DEVICEGPIONAMES: {



      AdvHwSerial = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

      rxPin = Settings.TaskDevicePin1[event->TaskIndex];

      txPin = Settings.TaskDevicePin2[event->TaskIndex];



      event->String1 = F("GPIO SS RX &larr; ");

      event->String2 = F("GPIO SS TX &rarr; ");



      if(AdvHwSerial == true) {

        if ((rxPin == 3 && txPin == 1) || (rxPin == 13 && txPin == 15)) {

            event->String1 = F("GPIO HW RX &larr; ");

            event->String2 = F("GPIO HW TX &rarr; ");

        }

      }

      break;

    }





    case PLUGIN_WEBFORM_LOAD: {

      rxPin = Settings.TaskDevicePin1[event->TaskIndex];

      txPin = Settings.TaskDevicePin2[event->TaskIndex];



      if (!((rxPin == 3 && txPin == 1) || (rxPin == 13 && txPin == 15))) {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = false;

      }



      if (rxPin == 3 && txPin == 1) {

        if(Settings.TaskDevicePluginConfig[event->TaskIndex][0]==false &&

         Settings.TaskDeviceEnabled[event->TaskIndex] == true) {

            Settings.TaskDevicePluginConfig[event->TaskIndex][0]=true;

        }

      }



      if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == false) {

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = B9600;

      }



      if(rxPin <0 || txPin <0) {

        addFormNote(F("Please configure the RX and TX sensor pins before enabling this plugin."));

        addFormSubHeader(F(""));

      }



      addFormSeparator(2);

      addFormSubHeader(F("Enhanced Serial Communication"));

      addFormCheckBox(F("Use Hardware Serial"), F("AdvHwSerial"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);



      byte choice = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

      String options[4];

      options[0] = F("9600");

      options[1] = F("38400");

      options[2] = F("57600");

      options[3] = F("115200");



      addFormSelector(F("Baud Rate"), F("plugin_075_baud"), 4, options, NULL, choice);

      addFormNote(F("Un-check box for Soft Serial communication (low performance mode, 9600 Baud)."));

      addFormNote(F("Hardware Serial is available when the GPIO pins are RX=D7 and TX=D8."));

      addFormNote(F("D8 (GPIO-15) requires a Buffer Circuit (PNP transistor) or ESP boot may fail."));

      addFormNote(F("Do <b>NOT</b> enable the Serial Log file on Tools->Advanced->Serial Port."));
# 337 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P075_Nextion.ino"
      addFormSubHeader(F(""));

      addFormHeader(F("Nextion Command Statements (Optional)"));



      char deviceTemplate[Nlines][Lenlines];

      LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));

      for (byte varNr = 0; varNr < Nlines; varNr++) {

        addFormTextBox(String(F("Line ")) + (varNr + 1), String(F("Plugin_075_template")) + (varNr + 1), deviceTemplate[varNr], Lenlines-1);



      }

      if( Settings.TaskDeviceTimer[event->TaskIndex]==0) {

        if(IncludeValues) {

            addFormNote(F("Interval Timer OFF, Nextion Lines (above) and Values (below) <b>NOT</b> scheduled for updates"));

        }

        else {

            addFormNote(F("Interval Timer OFF, Nextion Lines (above) <b>NOT</b> scheduled for updates"));

        }

      }



      addFormSeparator(2);

      addFormSubHeader(F("Interval Options"));

      addFormCheckBox(F("Resend <b>Values</b> (below) at Interval"), F("IncludeValues"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);



      success = true;

      break;

    }





    case PLUGIN_WEBFORM_SAVE: {



        String argName;



        char deviceTemplate[Nlines][Lenlines];

        for (byte varNr = 0; varNr < Nlines; varNr++)

        {

          String arg = F("Plugin_075_template");

          arg += varNr + 1;

          String tmpString = WebServer.arg(arg);

          strncpy(deviceTemplate[varNr], tmpString.c_str(), sizeof(deviceTemplate[varNr])-1);

            deviceTemplate[varNr][Lenlines-1]=0;

        }

        if(getTaskDeviceName(event->TaskIndex) == "") {

            strcpy(ExtraTaskSettings.TaskDeviceName,PLUGIN_DEFAULT_NAME);

        }

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = isFormItemChecked(F("AdvHwSerial"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_075_baud"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = isFormItemChecked(F("IncludeValues"));

        SaveCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));



        success = true;

        break;

    }





    case PLUGIN_INIT: {



      AdvHwSerial = Settings.TaskDevicePluginConfig[event->TaskIndex][0];

      BaudCode = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

      IncludeValues = Settings.TaskDevicePluginConfig[event->TaskIndex][2];



      if(BaudCode > B115200) BaudCode = B9600;

      const uint32_t BaudArray[4] = {9600UL, 38400UL, 57600UL, 115200UL};

      AdvHwBaud = BaudArray[BaudCode];



      if (Settings.TaskDevicePin1[event->TaskIndex] != -1) {

        rxPin = Settings.TaskDevicePin1[event->TaskIndex];

      }

      if (Settings.TaskDevicePin2[event->TaskIndex] != -1) {

        txPin = Settings.TaskDevicePin2[event->TaskIndex];

      }



      if (SoftSerial != NULL) {

        delete SoftSerial;

        SoftSerial = NULL;

      }



      String log = F("NEXTION075 : serial pin config RX:");

      log += rxPin;

      log += F(", TX:");

      log += txPin;

      if(Settings.TaskDeviceEnabled[event->TaskIndex]==true) {

        log += F(", Plugin Enabled");

      }

      else {

        log += F(", Plugin Disabled");

      }

      addLog(LOG_LEVEL_INFO, log);



      if(Settings.TaskDeviceEnabled[event->TaskIndex] == true) {



        if (AdvHwSerial && rxPin == 13 && txPin == 15) {

            log = F("NEXTION075 : Using swap hardware serial");

            addLog(LOG_LEVEL_INFO, log);

            HwSerial = UARTSERIAL;

            Settings.UseSerial = false;

            Settings.SerialLogLevel = 0;

            Settings.BaudRate = AdvHwBaud;

            Serial.flush();

            Serial.begin(AdvHwBaud);

            Serial.swap();

        }



        else if(AdvHwSerial && rxPin == 3 && txPin == 1) {

            log = F("NEXTION075 : Using USB hardware serial");

            addLog(LOG_LEVEL_INFO, log);

            HwSerial = UARTSERIAL;

            Settings.UseSerial = false;

            Settings.SerialLogLevel = 0;

            Settings.BaudRate = AdvHwBaud;

            Serial.flush();

            Serial.begin(AdvHwBaud);

        }

        else {

            log = F("NEXTION075 : Using software serial");

            addLog(LOG_LEVEL_INFO, log);

            HwSerial = SOFTSERIAL;

            if (SoftSerial == NULL) {

                SoftSerial = new ESPeasySoftwareSerial(rxPin, txPin, false, RXBUFFSZ);

            }

            SoftSerial->begin(9600);

            SoftSerial->flush();

        }

    }

    else {

    }

      success = true;

      break;

    }





    case PLUGIN_READ: {

        char deviceTemplate[Nlines][Lenlines];

        int RssiIndex;

        String newString;

        String tmpString;

        String UcTmpString;



        LoadCustomTaskSettings(event->TaskIndex, (byte*)&deviceTemplate, sizeof(deviceTemplate));





        for (byte x = 0; x < Nlines; x++) {

          tmpString = deviceTemplate[x];

          if (tmpString.length()) {

            UcTmpString = deviceTemplate[x];

            UcTmpString.toUpperCase();

            RssiIndex = UcTmpString.indexOf(F("RSSIBAR"));

            if(RssiIndex >= 0) {

              int barVal;

              newString = tmpString.substring(0, RssiIndex);

              int nbars = WiFi.RSSI();

              if (nbars < -100 || nbars >= 0)

                 barVal=0;

              else if (nbars >= -100 && nbars < -95)

                 barVal=5;

              else if (nbars >= -95 && nbars < -90)

                 barVal=10;

              else if (nbars >= -90 && nbars < -85)

                 barVal=20;

              else if (nbars >= -85 && nbars < -80)

                 barVal=30;

              else if (nbars >= -80 && nbars < -75)

                 barVal=45;

              else if (nbars >= -75 && nbars < -70)

                 barVal=60;

              else if (nbars >= -70 && nbars < -65)

                 barVal=70;

              else if (nbars >= -65 && nbars < -55)

                 barVal=80;

              else if (nbars >= -55 && nbars < -50)

                 barVal=90;

              else if (nbars >= -50)

                 barVal=100;



              newString += String(barVal,DEC);

            }

            else {

              newString = parseTemplate(tmpString, 0);

            }



            sendCommand(newString.c_str(), HwSerial);



            String log = F("NEXTION075 : Cmd Statement Line-");

            log += String(x+1);

            log += F(" Sent: ");

            log += newString;

            addLog(LOG_LEVEL_INFO, log);

          }

        }





        if(IncludeValues) {
# 731 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P075_Nextion.ino"
            success = true;

        }

        else {
# 745 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P075_Nextion.ino"
            success = false;

        }



        break;

    }







    case PLUGIN_WRITE: {



        String tmpString = string;

        int argIndex = tmpString.indexOf(',');

        if (argIndex) tmpString = tmpString.substring(0, argIndex);
# 797 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P075_Nextion.ino"
        if (tmpString.equalsIgnoreCase(getTaskDeviceName(event->TaskIndex)) == true) {

            argIndex = string.indexOf(',');

            tmpString = string.substring(argIndex + 1);

            sendCommand(tmpString.c_str(), HwSerial);



            String log = F("NEXTION075 : WRITE, ");

            log += F("Command is ");

            log += (tmpString.c_str());

            addLog(LOG_LEVEL_INFO, log);



            success = true;

        }

        break;

    }





    case PLUGIN_EXIT: {

        if (SoftSerial) {

            delete SoftSerial;

            SoftSerial=NULL;

        }



        if(HwSerial == UARTSERIAL) {

            HwSerial = SOFTSERIAL;

            Settings.UseSerial = DEFAULT_USE_SERIAL;

            Settings.BaudRate = DEFAULT_SERIAL_BAUD;

            Serial.flush();

            Serial.begin(DEFAULT_SERIAL_BAUD);

        }

        break;

    }





    case PLUGIN_ONCE_A_SECOND: {

        success = true;

        break;

    }





    case PLUGIN_TEN_PER_SECOND: {

      uint16_t i;

      uint8_t c;

      uint8_t charCount;

      String log;

      String Vidx;

      String Nvalue;

      String Svalue;

      String Nswitch;

      char __buffer[RXBUFFSZ+1];



      if(rxPin < 0) {

        String log = F("NEXTION075 : Missing RxD Pin Number, aborted serial receive");

        addLog(LOG_LEVEL_INFO, log);

        break;

      }



      if(HwSerial == UARTSERIAL) {

        charCount = Serial.available();

        if(charCount >= RXBUFFWARN) {

            log = F("NEXTION075 : RxD UART Buffer capacity warning,");

            log += String(charCount);

            log += F(" bytes");

            addLog(LOG_LEVEL_INFO, log);

        }

      }

      else {

        if(SoftSerial == NULL) break;

        charCount = SoftSerial->available();

        if(charCount >= RXBUFFWARN) {

            log = F("NEXTION075 : RxD SoftSerial Buffer capacity warning, ");

            log += String(charCount);

            log += F(" bytes");

            addLog(LOG_LEVEL_INFO, log);

        }

      }



      while (charCount) {

        if(HwSerial == UARTSERIAL) c = Serial.read();

        else c = SoftSerial->read();



        if (c == 0x65) {

          if (charCount < 6) delay((5/(AdvHwBaud/9600))+1);



          if (HwSerial == UARTSERIAL) charCount = Serial.available();

          else charCount = SoftSerial->available();

          if (charCount >= 6) {

            __buffer[0] = c;

            for (i = 1; i < 7; i++) {

                if(HwSerial == UARTSERIAL) __buffer[i] = Serial.read();

                else __buffer[i] = SoftSerial->read();

            }



            __buffer[i] = 0x00;



            if (0xFF == __buffer[4] && 0xFF == __buffer[5] && 0xFF == __buffer[6]) {

              UserVar[event->BaseVarIndex] = (__buffer[1] * 256) + __buffer[2] + TOUCH_BASE;

              UserVar[event->BaseVarIndex + 1] = __buffer[3];

              sendData(event);



              log = F("NEXTION075 : code: ");

              log += __buffer[1];

              log += ",";

              log += __buffer[2];

              log += ",";

              log += __buffer[3];

              addLog(LOG_LEVEL_INFO, log);

            }

          }

        }

        else {

          if (c == '|') {

            __buffer[0] = c;



            if (charCount < 8) delay((9/(AdvHwBaud/9600))+1);

            else delay((3/(AdvHwBaud/9600))+1);

            if (HwSerial == UARTSERIAL) charCount = Serial.available();

            else charCount = SoftSerial->available();



            if(HwSerial == UARTSERIAL) {

                i = 1;

                while (Serial.available() > 0 && i<RXBUFFSZ) {

                  __buffer[i] = Serial.read();

                  if (__buffer[i]==0x0a || __buffer[i]==0x0d) break;

                  i++;

                }

            }

            else {

                i = 1;

                while (SoftSerial->available() > 0 && i<RXBUFFSZ) {

                  __buffer[i] = SoftSerial->read();

                  if (__buffer[i]==0x0a || __buffer[i]==0x0d) break;

                  i++;

                }

            }



            __buffer[i] = 0x00;



            String tmpString = __buffer;

            log = F("NEXTION075 : code: ");

            log += tmpString;

            addLog(LOG_LEVEL_INFO, log);



            int argIndex = tmpString.indexOf(F(",i"));

            int argEnd = tmpString.indexOf(',', argIndex + 1);

            if (argIndex) Vidx = tmpString.substring(argIndex + 2,argEnd);



            boolean GotPipeCmd = false;

            switch (__buffer[1]){

              case 'u':

                GotPipeCmd = true;

                argIndex = argEnd;

                argEnd = tmpString.indexOf(',',argIndex + 1);

                if (argIndex) Nvalue = tmpString.substring(argIndex + 2,argEnd);

                argIndex = argEnd;

                argEnd = tmpString.indexOf(0x0a);

                if (argIndex) Svalue = tmpString.substring(argIndex + 2,argEnd);

                break;

              case 's':

                GotPipeCmd = true;

                argIndex = argEnd;

                argEnd = tmpString.indexOf(0x0a);

                if (argIndex) Nvalue = tmpString.substring(argIndex + 2,argEnd);

                if (Nvalue == F("On")) Svalue='1';

                if (Nvalue == F("Off")) Svalue='0';

                break;

            }



            if (GotPipeCmd) {

                UserVar[event->BaseVarIndex] = Vidx.toFloat();

                UserVar[event->BaseVarIndex+1] = Svalue.toFloat();

                sendData(event);



                log = F("NEXTION075 : Pipe Command Sent: ");

                log += __buffer;

                log += UserVar[event->BaseVarIndex];

            }

            else {

                log = F("NEXTION075 : Unknown Pipe Command, skipped");

            }

            addLog(LOG_LEVEL_INFO, log);

          }

        }

        if(HwSerial == UARTSERIAL) charCount = Serial.available();

        else charCount = SoftSerial->available();

      }



      success = true;

      break;

    }

  }

  return success;

}





void sendCommand(const char *cmd, boolean SerialMode)

{

    if(txPin < 0) {

        String log = F("NEXTION075 : Missing TxD Pin Number, aborted sendCommand");

        addLog(LOG_LEVEL_INFO, log);

    }

    else if(SerialMode == UARTSERIAL) {

        Serial.print(cmd);

        Serial.write(0xff);

        Serial.write(0xff);

        Serial.write(0xff);

    }

    else {

        if(SoftSerial != NULL){

            SoftSerial->print(cmd);

            SoftSerial->write(0xff);

            SoftSerial->write(0xff);

            SoftSerial->write(0xff);

        }

        else {

            String log = F("NEXTION075 : SoftSerial error, aborted sendCommand");

            addLog(LOG_LEVEL_INFO, log);

        }

    }

    return;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P076_HLW8012.ino"
#ifdef USES_P076
# 31 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P076_HLW8012.ino"
#include <HLW8012.h>

HLW8012 *Plugin_076_hlw = NULL;



#define PLUGIN_076 

#define PLUGIN_ID_076 76

#define PLUGIN_076_DEBUG true

#define PLUGIN_NAME_076 "Energy (AC) - HLW8012 [TESTING]"

#define PLUGIN_VALUENAME1_076 "Voltage (V)"

#define PLUGIN_VALUENAME2_076 "Current (A)"

#define PLUGIN_VALUENAME3_076 "Active Power (W)"

#define PLUGIN_VALUENAME4_076 "Power Factor (%)"
# 63 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P076_HLW8012.ino"
#define HLW_CURRENT_MODE HIGH

#define HLW_DELAYREADING 500





#define HLW_CURRENT_RESISTOR 0.001

#define HLW_VOLTAGE_RESISTOR_UP ( 5 * 470000 )

#define HLW_VOLTAGE_RESISTOR_DOWN ( 1000 )





byte StoredTaskIndex;



boolean Plugin_076(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_076;

        Device[deviceCount].Type = DEVICE_TYPE_TRIPLE;

        Device[deviceCount].VType = SENSOR_TYPE_QUAD;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = false;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_076);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_076));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_076));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_076));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_076));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormNote(F("Sonoff POW: 1st(SEL)=GPIO-5, 2nd(CF1)=GPIO-13, 3rd(CF)=GPIO-14"));

        addFormSubHeader(F("Calibration Values"));

        double hlwMultipliers[3];

        LoadCustomTaskSettings(event->TaskIndex, (byte*)&hlwMultipliers, sizeof(hlwMultipliers));

        addFormTextBox(F("Current Multiplier"), F("plugin_076_currmult"), String(hlwMultipliers[0], 2), 25);

        addFormTextBox(F("Voltage Multiplier"), F("plugin_076_voltmult"), String(hlwMultipliers[1], 2), 25);

        addFormTextBox(F("Power Multiplier"), F("plugin_076_powmult"), String(hlwMultipliers[2], 2), 25);

        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        double hlwMultipliers[3];

        String tmpString, arg1;

          arg1 = F("plugin_076_currmult"); tmpString = WebServer.arg(arg1);

          hlwMultipliers[0] = atof(tmpString.c_str());

          arg1 = F("plugin_076_voltmult"); tmpString = WebServer.arg(arg1);

          hlwMultipliers[1] = atof(tmpString.c_str());

          arg1 = F("plugin_076_powmult"); tmpString = WebServer.arg(arg1);

          hlwMultipliers[2] = atof(tmpString.c_str());

        SaveCustomTaskSettings(event->TaskIndex, (byte*)&hlwMultipliers, sizeof(hlwMultipliers));

        if (PLUGIN_076_DEBUG) {

          String log = F("HLW8012: Saved Calibration from Config Page");

          addLog(LOG_LEVEL_INFO, log);

        }

        if (Plugin_076_hlw) {

          Plugin_076_hlw->setCurrentMultiplier(hlwMultipliers[0]);

          Plugin_076_hlw->setVoltageMultiplier(hlwMultipliers[1]);

          Plugin_076_hlw->setPowerMultiplier(hlwMultipliers[2]);

        }

        if (PLUGIN_076_DEBUG) {

          String log = F("HLW8012: Multipliers Reassigned");

          addLog(LOG_LEVEL_INFO, log);

        }

        success = true;

        break;

      }



    case PLUGIN_READ:

      if (Plugin_076_hlw) {

        Plugin_076_hlw->setMode(MODE_CURRENT); delay(HLW_DELAYREADING); double hcurrent = Plugin_076_hlw->getCurrent();

        Plugin_076_hlw->setMode(MODE_VOLTAGE); delay(HLW_DELAYREADING); unsigned int hvoltage = Plugin_076_hlw->getVoltage();

        unsigned int hpower = Plugin_076_hlw->getActivePower();



        unsigned int hpowfact = (int) (100 * Plugin_076_hlw->getPowerFactor());

        if (PLUGIN_076_DEBUG) {

          String log = F("HLW8012: Read values");

          log += F(" - V="); log += hvoltage;

          log += F(" - A="); log += hcurrent;

          log += F(" - W="); log += hpower;

          log += F(" - Pf%="); log += hpowfact;

          addLog(LOG_LEVEL_INFO, log);

        }

        UserVar[event->BaseVarIndex] = hvoltage;

        UserVar[event->BaseVarIndex + 1] = hcurrent;

        UserVar[event->BaseVarIndex + 2] = hpower;

        UserVar[event->BaseVarIndex + 3] = hpowfact;



        success = true;

      }

      break;



    case PLUGIN_INIT:

      {

        if (!Plugin_076_hlw)

        {

          Plugin_076_hlw = new HLW8012;



          Plugin_076_hlw->begin(Settings.TaskDevicePin3[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex], Settings.TaskDevicePin1[event->TaskIndex], HLW_CURRENT_MODE, false, 1000000);

          if (PLUGIN_076_DEBUG) addLog(LOG_LEVEL_INFO, F("HLW8012: Init object done"));

          Plugin_076_hlw->setResistors(HLW_CURRENT_RESISTOR, HLW_VOLTAGE_RESISTOR_UP, HLW_VOLTAGE_RESISTOR_DOWN);

          if (PLUGIN_076_DEBUG) addLog(LOG_LEVEL_INFO, F("HLW8012: Init Basic Resistor Values done"));



          double hlwMultipliers[3];

          LoadCustomTaskSettings(event->TaskIndex, (byte*)&hlwMultipliers, sizeof(hlwMultipliers));

            if (hlwMultipliers[0] == 0) { hlwMultipliers[0] = Plugin_076_hlw->getCurrentMultiplier(); }

            if (hlwMultipliers[1] == 0) { hlwMultipliers[1] = Plugin_076_hlw->getVoltageMultiplier(); }

            if (hlwMultipliers[2] == 0) { hlwMultipliers[2] = Plugin_076_hlw->getPowerMultiplier(); }

          SaveCustomTaskSettings(event->TaskIndex, (byte*)&hlwMultipliers, sizeof(hlwMultipliers));

          if (PLUGIN_076_DEBUG) addLog(LOG_LEVEL_INFO, F("HLW8012: Saved Calibration after INIT"));

          Plugin_076_hlw->setCurrentMultiplier(hlwMultipliers[0]);

          Plugin_076_hlw->setVoltageMultiplier(hlwMultipliers[1]);

          Plugin_076_hlw->setPowerMultiplier(hlwMultipliers[2]);

          if (PLUGIN_076_DEBUG) addLog(LOG_LEVEL_INFO, F("HLW8012: Applied Calibration after INIT"));

          StoredTaskIndex = event->TaskIndex;

        }

        success = true;

        break;

      }



    case PLUGIN_WRITE:

      {

        if (Plugin_076_hlw)

        {

          String tmpString = string;

          int argIndex = tmpString.indexOf(',');

          if (argIndex)

            tmpString = tmpString.substring(0, argIndex);



          if (tmpString.equalsIgnoreCase(F("hlwreset")))

          {

            Plugin_076_hlw->resetMultipliers();

            Plugin076_SaveMultipliers();

            if (PLUGIN_076_DEBUG) addLog(LOG_LEVEL_INFO, F("HLW8012: Reset Multipliers to DEFAULT"));

            success = true;

          }



          if (tmpString.equalsIgnoreCase(F("hlwcalibrate")))

          {

            String tmpStr = string;

            unsigned int CalibVolt = 0;

            double CalibCurr = 0;

            unsigned int CalibAcPwr = 0;

            int comma1 = tmpStr.indexOf(',');

            int comma2 = tmpStr.indexOf(',', comma1+1);

            int comma3 = tmpStr.indexOf(',', comma2+1);

            if (comma1 != 0) {

              if (comma2 == 0) {

                CalibVolt = tmpStr.substring(comma1+1).toInt();

              } else if (comma3 == 0) {

                CalibVolt = tmpStr.substring(comma1+1, comma2).toInt();

                CalibCurr = atof(tmpStr.substring(comma2+1).c_str());

              } else {

                CalibVolt = tmpStr.substring(comma1+1, comma2).toInt();

                CalibCurr = atof(tmpStr.substring(comma2+1, comma3).c_str());

                CalibAcPwr = tmpStr.substring(comma3+1).toInt();

              }

            }

            if (PLUGIN_076_DEBUG) {

              String log = F("HLW8012: Calibration to values");

              log += F(" - Expected-V="); log += CalibVolt;

              log += F(" - Expected-A="); log += CalibCurr;

              log += F(" - Expected-W="); log += CalibAcPwr;

              addLog(LOG_LEVEL_INFO, log);

            }

            if (CalibVolt != 0) { Plugin_076_hlw->expectedVoltage(CalibVolt); }

            if (CalibCurr != 0) { Plugin_076_hlw->expectedCurrent(CalibCurr); }

            if (CalibAcPwr != 0) { Plugin_076_hlw->expectedActivePower(CalibAcPwr); }



            if ((CalibVolt + CalibCurr + CalibAcPwr) != 0) { Plugin076_SaveMultipliers(); }

            success = true;

          }

        }

        break;

      }



  }

  return success;

}



void Plugin076_SaveMultipliers() {

    double hlwMultipliers[3];

    hlwMultipliers[0] = Plugin_076_hlw->getCurrentMultiplier();

    hlwMultipliers[1] = Plugin_076_hlw->getVoltageMultiplier();

    hlwMultipliers[2] = Plugin_076_hlw->getPowerMultiplier();

    SaveCustomTaskSettings(StoredTaskIndex, (byte*)&hlwMultipliers, sizeof(hlwMultipliers));

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P077_CSE7766.ino"
#ifdef USES_P077
# 15 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P077_CSE7766.ino"
#define PLUGIN_077 

#define PLUGIN_ID_077 77

#define PLUGIN_NAME_077 "Energy (AC) - CSE7766 [TESTING]"

#define PLUGIN_VALUENAME1_077 "Voltage"

#define PLUGIN_VALUENAME2_077 "Power"

#define PLUGIN_VALUENAME3_077 "Current"

#define PLUGIN_VALUENAME4_077 "Pulses"



boolean Plugin_077_init = false;



#define CSE_NOT_CALIBRATED 0xAA

#define CSE_PULSES_NOT_INITIALIZED -1

#define CSE_PREF 1000

#define CSE_UREF 100

#define HLW_PREF_PULSE 12530

#define HLW_UREF_PULSE 1950

#define HLW_IREF_PULSE 3500
# 63 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P077_CSE7766.ino"
uint8_t cse_receive_flag = 0;



long voltage_cycle = 0;

long current_cycle = 0;

long power_cycle = 0;

long power_cycle_first = 0;

long cf_pulses = 0;

long cf_pulses_last_time = CSE_PULSES_NOT_INITIALIZED;

long cf_frequency = 0;

uint8_t serial_in_buffer[32];

uint8_t serial_in_byte_counter = 0;

uint8_t serial_in_byte = 0;

float energy_voltage = 0;

float energy_current = 0;

float energy_power = 0;





boolean Plugin_077(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function) {

    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_077;

        Device[deviceCount].VType = SENSOR_TYPE_QUAD;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 4;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].TimerOptional = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_077);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_077));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_077));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[2], PSTR(PLUGIN_VALUENAME3_077));

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[3], PSTR(PLUGIN_VALUENAME4_077));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        addFormNumericBox(F("U Ref"), F("plugin_077_URef"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

        addUnit(F("uSec"));



        addFormNumericBox(F("I Ref"), F("plugin_077_IRef"), Settings.TaskDevicePluginConfig[event->TaskIndex][1]);

        addUnit(F("uSec"));



        addFormNumericBox(F("P Ref"), F("plugin_077_PRef"), Settings.TaskDevicePluginConfig[event->TaskIndex][2]);

        addUnit(F("uSec"));

        addFormNote(F("Use 0 to read values stored on chip / default values"));



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_077_URef"));;

        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_077_IRef"));

        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_077_PRef"));

        success = true;

        break;

      }



    case PLUGIN_INIT:

      {

        Plugin_077_init = true;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][0] == 0) Settings.TaskDevicePluginConfig[event->TaskIndex][0] = HLW_UREF_PULSE;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][1] == 0) Settings.TaskDevicePluginConfig[event->TaskIndex][1] = HLW_IREF_PULSE;

        if (Settings.TaskDevicePluginConfig[event->TaskIndex][2] == 0) Settings.TaskDevicePluginConfig[event->TaskIndex][2] = HLW_PREF_PULSE;



        Settings.UseSerial = true;

        disableSerialLog();

        Settings.BaudRate = 4800;

        Serial.flush();

        Serial.begin(Settings.BaudRate);

        success = true;

        break;

      }
# 301 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P077_CSE7766.ino"
    case PLUGIN_READ:

      {

        addLog(LOG_LEVEL_DEBUG_DEV, F("CSE: plugin read"));
# 319 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P077_CSE7766.ino"
        success = true;

        break;

      }





    case PLUGIN_SERIAL_IN:

      {

        if (Plugin_077_init) {

          if (Serial.available() > 0) {

            serial_in_byte = Serial.read();

            success = true;



            if (cse_receive_flag) {

              serial_in_buffer[serial_in_byte_counter++] = serial_in_byte;

              if (24 == serial_in_byte_counter) {

                addLog(LOG_LEVEL_DEBUG_DEV, F("CSE: packet received"));

                CseReceived(event);

                cse_receive_flag = 0;

                serial_in_byte_counter = 0;



                UserVar[event->BaseVarIndex] = energy_voltage;

                UserVar[event->BaseVarIndex + 1] = energy_power;

                UserVar[event->BaseVarIndex + 2] = energy_current;

                UserVar[event->BaseVarIndex + 3] = cf_pulses;



              }

            } else {

              if (0x5A == serial_in_byte) {

                cse_receive_flag = 1;

                addLog(LOG_LEVEL_DEBUG_DEV, F("CSE: Header received"));

              } else {

                serial_in_byte_counter = 0;

              }

              serial_in_buffer[serial_in_byte_counter++] = serial_in_byte;

            }

            serial_in_byte = 0;
# 403 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P077_CSE7766.ino"
          }

        }

        break;

      }

  }

  return success;

}



void CseReceived(struct EventStruct *event)

{

  uint8_t header = serial_in_buffer[0];

  if ((header & 0xFC) == 0xFC) {

    addLog(LOG_LEVEL_DEBUG, F("CSE: Abnormal hardware"));

    return;

  }





  uint8_t checksum = 0;

  for (byte i = 2; i < 23; i++) checksum += serial_in_buffer[i];

  if (checksum != serial_in_buffer[23]) {

    addLog(LOG_LEVEL_DEBUG, F("CSE: Checksum Failure"));

    return;

  }







  if (HLW_UREF_PULSE == Settings.TaskDevicePluginConfig[event->TaskIndex][0]) {

    long voltage_coefficient = 191200;

    if (CSE_NOT_CALIBRATED != header) {

      voltage_coefficient = serial_in_buffer[2] << 16 | serial_in_buffer[3] << 8 | serial_in_buffer[4];

    }

    Settings.TaskDevicePluginConfig[event->TaskIndex][0] = voltage_coefficient / CSE_UREF;

  }

  if (HLW_IREF_PULSE == Settings.TaskDevicePluginConfig[event->TaskIndex][1]) {

    long current_coefficient = 16140;

    if (CSE_NOT_CALIBRATED != header) {

      current_coefficient = serial_in_buffer[8] << 16 | serial_in_buffer[9] << 8 | serial_in_buffer[10];

    }

    Settings.TaskDevicePluginConfig[event->TaskIndex][1] = current_coefficient;

  }

  if (HLW_PREF_PULSE == Settings.TaskDevicePluginConfig[event->TaskIndex][2]) {

    long power_coefficient = 5364000;

    if (CSE_NOT_CALIBRATED != header) {

      power_coefficient = serial_in_buffer[14] << 16 | serial_in_buffer[15] << 8 | serial_in_buffer[16];

    }

    Settings.TaskDevicePluginConfig[event->TaskIndex][2] = power_coefficient / CSE_PREF;

  }





  uint8_t adjustement = serial_in_buffer[20];

  voltage_cycle = serial_in_buffer[5] << 16 | serial_in_buffer[6] << 8 | serial_in_buffer[7];

  current_cycle = serial_in_buffer[11] << 16 | serial_in_buffer[12] << 8 | serial_in_buffer[13];

  power_cycle = serial_in_buffer[17] << 16 | serial_in_buffer[18] << 8 | serial_in_buffer[19];

  cf_pulses = serial_in_buffer[21] << 8 | serial_in_buffer[22];



  if (loglevelActiveFor(LOG_LEVEL_DEBUG_DEV)) {

    String log = F("CSE: adjustement ");

    log += adjustement;

    addLog(LOG_LEVEL_DEBUG_DEV, log);

    log = F("CSE: voltage_cycle ");

    log += voltage_cycle;

    addLog(LOG_LEVEL_DEBUG_DEV, log);

    log = F("CSE: current_cycle ");

    log += current_cycle;

    addLog(LOG_LEVEL_DEBUG_DEV, log);

    log = F("CSE: power_cycle ");

    log += power_cycle;

    addLog(LOG_LEVEL_DEBUG_DEV, log);

    log = F("CSE: cf_pulses ");

    log += cf_pulses;

    addLog(LOG_LEVEL_DEBUG_DEV, log);

  }







  if (adjustement & 0x40) {

    energy_voltage = (float)(Settings.TaskDevicePluginConfig[event->TaskIndex][0] * CSE_UREF) / (float)voltage_cycle;

  }

  if (adjustement & 0x10) {

    if ((header & 0xF2) == 0xF2) {

      energy_power = 0;

    } else {

      if (0 == power_cycle_first) power_cycle_first = power_cycle;

      if (power_cycle_first != power_cycle) {

        power_cycle_first = -1;

        energy_power = (float)(Settings.TaskDevicePluginConfig[event->TaskIndex][2] * CSE_PREF) / (float)power_cycle;

      } else {

        energy_power = 0;

      }

    }

  } else {

    power_cycle_first = 0;

    energy_power = 0;

  }

  if (adjustement & 0x20) {

    if (0 == energy_power) {

      energy_current = 0;

    } else {

      energy_current = (float)Settings.TaskDevicePluginConfig[event->TaskIndex][1] / (float)current_cycle;

    }

  }
# 621 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P077_CSE7766.ino"
  if (loglevelActiveFor(LOG_LEVEL_DEBUG)) {

    String log = F("CSE voltage: ");

    log += energy_voltage;

    addLog(LOG_LEVEL_DEBUG, log);

    log = F("CSE power: ");

    log += energy_power;

    addLog(LOG_LEVEL_DEBUG, log);

    log = F("CSE current: ");

    log += energy_current;

    addLog(LOG_LEVEL_DEBUG, log);

    log = F("CSE piulses: ");

    log += cf_pulses;

    addLog(LOG_LEVEL_DEBUG, log);

  }

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P078_Eastron.ino"
#ifdef USES_P078
# 25 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P078_Eastron.ino"
#define PLUGIN_078 

#define PLUGIN_ID_078 78

#define PLUGIN_NAME_078 "Energy (AC) - Eastron SDM120C [TESTING]"

#define PLUGIN_VALUENAME1_078 "Voltage"



boolean Plugin_078_init = false;

#include <SDM.h>

ESPeasySoftwareSerial swSerSDM(6, 7);

SDM Plugin_078_SDM(swSerSDM, 9600, NOT_A_PIN);



boolean Plugin_078(byte function, struct EventStruct *event, String& string)

{

  boolean success = false;



  switch (function)

  {



    case PLUGIN_DEVICE_ADD:

      {

        Device[++deviceCount].Number = PLUGIN_ID_078;

        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].VType = SENSOR_TYPE_SINGLE;

        Device[deviceCount].Ports = 0;

        Device[deviceCount].PullUpOption = false;

        Device[deviceCount].InverseLogicOption = false;

        Device[deviceCount].FormulaOption = true;

        Device[deviceCount].ValueCount = 1;

        Device[deviceCount].SendDataOption = true;

        Device[deviceCount].TimerOption = true;

        Device[deviceCount].GlobalSyncOption = true;

        break;

      }



    case PLUGIN_GET_DEVICENAME:

      {

        string = F(PLUGIN_NAME_078);

        break;

      }



    case PLUGIN_GET_DEVICEVALUENAMES:

      {

        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_078));

        break;

      }



    case PLUGIN_WEBFORM_LOAD:

      {

        byte meter_model = Settings.TaskDevicePluginConfig[event->TaskIndex][1];

        byte meter_baudrate = Settings.TaskDevicePluginConfig[event->TaskIndex][2];

        byte query = Settings.TaskDevicePluginConfig[event->TaskIndex][3];



        String options_model[3] = { F("SDM120C"), F("SDM220T"), F("SDM630") };

        addFormSelector(F("Model Type"), F("plugin_078_meter_model"), 3, options_model, NULL, meter_model );



        String options_baudrate[6] = { F("1200"), F("2400"), F("4800"), F("9600"), F("19200"), F("38400") };

        addFormSelector(F("Baud Rate"), F("plugin_078_meter_baudrate"), 6, options_baudrate, NULL, meter_baudrate );



        if (meter_model == 0 && meter_baudrate > 3)

          addFormNote(F("<span style=\"color:red\"> SDM120 only allows up to 9600 baud with default 2400!</span>"));



        if (meter_model == 2 && meter_baudrate == 0)

          addFormNote(F("<span style=\"color:red\"> SDM630 only allows 2400 to 38400 baud with default 9600!</span>"));



        String options_query[10] = { F("Voltage (V)"),

                                     F("Current (A)"),

                                     F("Power (W)"),

                                     F("Active Apparent Power (VA)"),

                                     F("Reactive Apparent Power (VAr)"),

                                     F("Power Factor (cos-phi)"),

                                     F("Frequency (Hz)"),

                                     F("Import Active Energy (Wh)"),

                                     F("Export Active Energy (Wh)"),

                                     F("Total Active Energy (Wh)") };

        addFormSelector(F("Query"), F("plugin_078_query"), 10, options_query, NULL, query );



        success = true;

        break;

      }



    case PLUGIN_WEBFORM_SAVE:

      {

          Settings.TaskDevicePluginConfig[event->TaskIndex][0] = getFormItemInt(F("plugin_078"));

          Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_078_meter_model"));

          Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_078_meter_baudrate"));

          Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("plugin_078_query"));



          Plugin_078_init = false;

          success = true;

          break;

      }



    case PLUGIN_INIT:

      {

        Plugin_078_init = true;







        Plugin_078_SDM.begin();

        success = true;

        break;

      }



    case PLUGIN_READ:

      {



        if (Plugin_078_init)

        {

          float _tempvar = 0;

          String log = F("EASTRON: ");

          switch(Settings.TaskDevicePluginConfig[event->TaskIndex][3])

          {

              case 0:

              {

                  _tempvar = Plugin_078_SDM.readVal(SDM120C_VOLTAGE);

                  log += F("Voltage ");

                  break;

              }

              case 1:

              {

                  _tempvar = Plugin_078_SDM.readVal(SDM120C_CURRENT);

                  log += F("Current ");

                  break;

              }

              case 2:

              {

                  _tempvar = Plugin_078_SDM.readVal(SDM120C_POWER);

                  log += F("Power ");

                  break;

              }

              case 3:

              {

                  _tempvar = Plugin_078_SDM.readVal(SDM120C_ACTIVE_APPARENT_POWER);

                  log += F("Active Apparent Power ");

                  break;

              }

              case 4:

              {

                  _tempvar = Plugin_078_SDM.readVal(SDM120C_REACTIVE_APPARENT_POWER);

                  log += F("Reactive Apparent Power ");

                  break;

              }

              case 5:

              {

                  _tempvar = Plugin_078_SDM.readVal(SDM120C_POWER_FACTOR);

                  log += F("Power Factor ");

                  break;

              }

              case 6:

              {

                  _tempvar = Plugin_078_SDM.readVal(SDM120C_FREQUENCY);

                  log += F("Frequency ");

                  break;

              }

              case 7:

              {

                  _tempvar = Plugin_078_SDM.readVal(SDM120C_IMPORT_ACTIVE_ENERGY);

                  log += F("Import Active Energy ");

                  break;

              }

              case 8:

              {

                  _tempvar = Plugin_078_SDM.readVal(SDM120C_EXPORT_ACTIVE_ENERGY);

                  log += F("Export Active Energy ");

                  break;

              }

              case 9:

              {

                  _tempvar = Plugin_078_SDM.readVal(SDM120C_TOTAL_ACTIVE_ENERGY);

                  log += F("Total Active Energy ");

                  break;

              }

          }



          UserVar[event->BaseVarIndex] = _tempvar;

          log += _tempvar;

          addLog(LOG_LEVEL_INFO, log);



          success = true;

          break;

        }

        break;

      }

  }

  return success;

}



#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P079_Wemos_Motorshield.ino"
#ifdef USES_P079
# 33 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P079_Wemos_Motorshield.ino"
#define PLUGIN_079 

#define PLUGIN_ID_079 79

#define PLUGIN_NAME_079 "Motor - Wemos Motorshield [TESTING]"

#define PLUGIN_VALUENAME1_079 "Wemos Motorshield"





#ifndef __WEMOS_MOTOR_H

#define __WEMOS_MOTOR_H 



#if ARDUINO >= 100

 #include "Arduino.h"

#else

 #include "WProgram.h"

#endif



#include "Wire.h"



#define _MOTOR_A 0

#define _MOTOR_B 1



#define _SHORT_BRAKE 0

#define _CCW 1

#define _CW 2

#define _STOP 3

#define _STANDBY 4



class WemosMotor {

public:

WemosMotor(uint8_t address, uint8_t motor, uint32_t freq);

WemosMotor(uint8_t address, uint8_t motor, uint32_t freq, uint8_t STBY_IO);

void setfreq(uint32_t freq);

void setmotor(uint8_t dir, float pwm_val);

void setmotor(uint8_t dir);



private:

uint8_t _address;

uint8_t _motor;

bool _use_STBY_IO = false;

uint8_t _STBY_IO;

};



#endif





uint8_t Plugin_079_MotorShield_address = 0x30;





boolean Plugin_079(byte function, struct EventStruct *event, String& string)

{

 boolean success = false;







 switch (function) {

 case PLUGIN_DEVICE_ADD: {

  Device[++deviceCount].Number = PLUGIN_ID_079;

  Device[deviceCount].Type = DEVICE_TYPE_I2C;

  Device[deviceCount].VType = SENSOR_TYPE_NONE;

  Device[deviceCount].Ports = 0;

  Device[deviceCount].PullUpOption = false;

  Device[deviceCount].InverseLogicOption = false;

  Device[deviceCount].FormulaOption = false;

  Device[deviceCount].ValueCount = 0;

  Device[deviceCount].SendDataOption = false;

  Device[deviceCount].TimerOption = false;

  break;

 }



 case PLUGIN_GET_DEVICENAME: {

  string = F(PLUGIN_NAME_079);

  break;

 }



 case PLUGIN_GET_DEVICEVALUENAMES: {

  strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0],

    PSTR(PLUGIN_VALUENAME1_079));

  break;

 }



 case PLUGIN_WEBFORM_LOAD: {

    String i2c_addres_string = formatToHex(Settings.TaskDevicePluginConfig[event->TaskIndex][0]);

  addFormTextBox(F("I2C Address (Hex)"), F("plugin_079_adr"), i2c_addres_string, 4);



  success = true;

  break;

 }



 case PLUGIN_WEBFORM_SAVE: {

  String i2c_address = WebServer.arg(F("plugin_079_adr"));

  Settings.TaskDevicePluginConfig[event->TaskIndex][0] = (int)strtol(i2c_address.c_str(), 0, 16);



  success = true;

  break;

 }



 case PLUGIN_INIT: {

  Plugin_079_MotorShield_address = Settings.TaskDevicePluginConfig[event->TaskIndex][0];



  success = true;

  break;

 }



 case PLUGIN_READ: {

  success = false;

  break;

 }



 case PLUGIN_WRITE: {

  String tmpString = string;



  String cmd = parseString(tmpString, 1);
# 263 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P079_Wemos_Motorshield.ino"
  if (cmd.equalsIgnoreCase(F("WemosMotorShieldCMD"))) {

   String paramMotor = parseString(tmpString, 2);

   String paramDirection = parseString(tmpString, 3);

   String paramSpeed = parseString(tmpString, 4);



   WemosMotor WMS(Plugin_079_MotorShield_address, paramMotor.toInt(), 1000);

   addLog(LOG_LEVEL_DEBUG, String(F("WemosMotorShield: Address = ")) + Plugin_079_MotorShield_address + String(F(" Motor = ")) + paramMotor);



   if (paramDirection.equalsIgnoreCase(F("Forward"))) {

    WMS.setmotor(_CW, paramSpeed.toInt());

    addLog(LOG_LEVEL_INFO, String(F("WemosMotor: Motor = ")) + paramMotor + String(F(" Direction = ")) + paramDirection + String(F(" Speed = ")) + paramSpeed);

   }

   if (paramDirection.equalsIgnoreCase(F("Backward"))) {

    WMS.setmotor(_CCW, paramSpeed.toInt());

    addLog(LOG_LEVEL_INFO, String(F("WemosMotor: Motor = ")) + paramMotor + String(F(" Direction = ")) + paramDirection + String(F(" Speed = ")) + paramSpeed);

   }

   if (paramDirection.equalsIgnoreCase(F("Stop"))) {

    WMS.setmotor(_STOP);

    addLog(LOG_LEVEL_INFO, String(F("WemosMotor: Motor = ")) + paramMotor + String(F(" Direction = ")) + paramDirection);

   }



   success = true;

  }



  break;

 }

 }

 return success;

}
# 329 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P079_Wemos_Motorshield.ino"
WemosMotor::WemosMotor(uint8_t address, uint8_t motor, uint32_t freq)

{

 _use_STBY_IO = false;



 if (motor == _MOTOR_A)

  _motor = _MOTOR_A;

 else

  _motor = _MOTOR_B;







 _address = address;



 setfreq(freq);

}





WemosMotor::WemosMotor(uint8_t address, uint8_t motor, uint32_t freq, uint8_t STBY_IO)

{

 _use_STBY_IO = true;

 _STBY_IO = STBY_IO;



 if (motor == _MOTOR_A)

  _motor = _MOTOR_A;

 else

  _motor = _MOTOR_B;







 _address = address;



 setfreq(freq);



 pinMode(_STBY_IO, OUTPUT);

 digitalWrite(_STBY_IO, LOW);

}
# 427 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P079_Wemos_Motorshield.ino"
void WemosMotor::setfreq(uint32_t freq)

{

 Wire.beginTransmission(_address);

 Wire.write(((byte)(freq >> 24)) & (byte)0x0f);

 Wire.write((byte)(freq >> 16));

 Wire.write((byte)(freq >> 8));

 Wire.write((byte)freq);

 Wire.endTransmission();

 yield();

}
# 495 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P079_Wemos_Motorshield.ino"
void WemosMotor::setmotor(uint8_t dir, float pwm_val)

{

 uint16_t _pwm_val;



 if (_use_STBY_IO == true) {

  if (dir == _STANDBY) {

   digitalWrite(_STBY_IO, LOW);

   return;

  }else

   digitalWrite(_STBY_IO, HIGH);

 }



 Wire.beginTransmission(_address);

 Wire.write(_motor | (byte)0x10);

 Wire.write(dir);





 _pwm_val = uint16_t(pwm_val * 100);



 if (_pwm_val > 10000)

  _pwm_val = 10000;



 Wire.write((byte)(_pwm_val >> 8));

 Wire.write((byte)_pwm_val);

 Wire.endTransmission();



 yield();

}



void WemosMotor::setmotor(uint8_t dir)

{

 setmotor(dir, 100);

}







#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
#ifdef USES_P080
# 15 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
#if defined(ESP32)

  #define ESP32noInterrupts() {portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;portENTER_CRITICAL(&mux)

  #define ESP32interrupts() portEXIT_CRITICAL(&mux);}

#endif



#define PLUGIN_080 

#define PLUGIN_ID_080 80

#define PLUGIN_NAME_080 "Input - iButton [TESTING]"

#define PLUGIN_VALUENAME1_080 "iButton"



int8_t Plugin_080_DallasPin;



boolean Plugin_080(byte function, struct EventStruct * event, String& string)

{

    boolean success = false;



    switch (function)

    {

        case PLUGIN_DEVICE_ADD:

        {

            Device[++deviceCount].Number = PLUGIN_ID_080;

            Device[deviceCount].Type = DEVICE_TYPE_SINGLE;

            Device[deviceCount].VType = SENSOR_TYPE_LONG;

            Device[deviceCount].Ports = 0;

            Device[deviceCount].PullUpOption = false;

            Device[deviceCount].InverseLogicOption = false;

            Device[deviceCount].FormulaOption = false;

            Device[deviceCount].ValueCount = 1;

            Device[deviceCount].SendDataOption = true;

            Device[deviceCount].TimerOption = true;

            Device[deviceCount].GlobalSyncOption = true;

            break;

        }



        case PLUGIN_GET_DEVICENAME:

        {

            string = F(PLUGIN_NAME_080);

            break;

        }



        case PLUGIN_GET_DEVICEVALUENAMES:

        {

            strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_080));

            break;

        }



        case PLUGIN_WEBFORM_LOAD:

        {

            uint8_t savedAddress[8];



            Plugin_080_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];



            if (Plugin_080_DallasPin != -1){



              for (byte i = 0; i < 8; i++)

                  savedAddress[i] = ExtraTaskSettings.TaskDevicePluginConfigLong[i];





              addRowLabel(F("Device Address"));

              addSelector_Head(F("plugin_080_dev"), false);

              addSelector_Item("", -1, false, false, F(""));

              uint8_t tmpAddress[8];

              byte count = 0;

              Plugin_080_DS_reset();

              Plugin_080_DS_reset_search();

              while (Plugin_080_DS_search(tmpAddress))

              {

                  String option = "";

                  for (byte j = 0; j < 8; j++)

                  {

                      option += String(tmpAddress[j], HEX);

                      if (j < 7) option += F("-");

                  }

                  bool selected = (memcmp(tmpAddress, savedAddress, 8) == 0) ? true : false;



                  if ( tmpAddress[0] == 0x01) {

                      addSelector_Item(option, count, selected, false, F(""));

                  }





                  count ++;

              }

              addSelector_Foot();

            }

            success = true;

            break;

        }



        case PLUGIN_WEBFORM_SAVE:

        {

            uint8_t addr[8] = {0,0,0,0,0,0,0,0};





            Plugin_080_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];



            if (Plugin_080_DallasPin != -1){

              Plugin_080_DS_scan(getFormItemInt(F("plugin_080_dev")), addr);

              for (byte x = 0; x < 8; x++)

                  ExtraTaskSettings.TaskDevicePluginConfigLong[x] = addr[x];



              Plugin_080_DS_startConvertion(addr);

            }

            success = true;

            break;

        }



        case PLUGIN_WEBFORM_SHOW_CONFIG:

        {

            for (byte x = 0; x < 8; x++)

            {

                if (x != 0)

                    string += "-";



            }

            success = true;

            break;

        }

        case PLUGIN_INIT:

        {

            Plugin_080_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];

            if (Plugin_080_DallasPin != -1){

              uint8_t addr[8];

              Plugin_080_get_addr(addr, event->TaskIndex);

              Plugin_080_DS_startConvertion(addr);

              delay(800);

            }

            success = true;

            break;

        }



        case PLUGIN_TEN_PER_SECOND:

        {

            if (ExtraTaskSettings.TaskDevicePluginConfigLong[0] != 0){

                uint8_t addr[8];

                Plugin_080_get_addr(addr, event->TaskIndex);



                Plugin_080_DallasPin = Settings.TaskDevicePin1[event->TaskIndex];

                String log = F("DS   : iButton: ");



                if (Plugin_080_DS_readiButton(addr))

                {

                    UserVar[event->BaseVarIndex] = 1;

                    log += UserVar[event->BaseVarIndex];

                    success = true;

                }

                else

                {





                    UserVar[event->BaseVarIndex] = 0;

                    log += F("Not Present!");

                }

                Plugin_080_DS_startConvertion(addr);

                addLog(LOG_LEVEL_DEBUG, log);

            }

            break;

        }

    }

    return success;

}



void Plugin_080_get_addr(uint8_t addr[], byte TaskIndex)

{



  LoadTaskSettings(TaskIndex);

  for (byte x = 0; x < 8; x++)

      addr[x] = ExtraTaskSettings.TaskDevicePluginConfigLong[x];

}
# 361 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
byte Plugin_080_DS_scan(byte getDeviceROM, uint8_t* ROM)

{

    byte tmpaddr[8];

    byte devCount = 0;

    Plugin_080_DS_reset();



    Plugin_080_DS_reset_search();

    while (Plugin_080_DS_search(tmpaddr))

    {

        if (getDeviceROM == devCount)

            for (byte i = 0; i < 8; i++)

                ROM[i] = tmpaddr[i];

        devCount++;

    }

    return devCount;

}
# 409 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
void Plugin_080_DS_startConvertion(uint8_t ROM[8])

{

    Plugin_080_DS_reset();

    Plugin_080_DS_write(0x55);

    for (byte i = 0; i < 8; i++)

        Plugin_080_DS_write(ROM[i]);

    Plugin_080_DS_write(0x44);

}
# 437 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
uint8_t Plugin_080_DS_reset()

{

    uint8_t r;

    uint8_t retries = 125;

    #if defined(ESP32)

      ESP32noInterrupts();

    #endif

    pinMode(Plugin_080_DallasPin, INPUT);

    do

    {

        if (--retries == 0)

            return 0;

        delayMicroseconds(2);

    }

    while (!digitalRead(Plugin_080_DallasPin));



    pinMode(Plugin_080_DallasPin, OUTPUT); digitalWrite(Plugin_080_DallasPin, LOW);

    delayMicroseconds(492);

    pinMode(Plugin_080_DallasPin, INPUT);

    delayMicroseconds(40);

    r = !digitalRead(Plugin_080_DallasPin);

    delayMicroseconds(420);

    #if defined(ESP32)

      ESP32interrupts();

    #endif

    return r;

}



#define FALSE 0

#define TRUE 1



unsigned char ROM_NBR[8];

uint8_t LastDiscrep;

uint8_t LastFamilyDiscrep;

uint8_t LastDeviceFlg;
# 517 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
void Plugin_080_DS_reset_search()

{



    LastDiscrep = 0;

    LastDeviceFlg = FALSE;

    LastFamilyDiscrep = 0;

    for (byte i = 0; i < 8; i++)

        ROM_NBR[i] = 0;

}
# 545 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
uint8_t Plugin_080_DS_search(uint8_t * newAddr)

{

    uint8_t id_bit_number;

    uint8_t last_zero, rom_byte_number, search_result;

    uint8_t id_bit, cmp_id_bit;

    unsigned char rom_byte_mask, search_direction;





    id_bit_number = 1;

    last_zero = 0;

    rom_byte_number = 0;

    rom_byte_mask = 1;

    search_result = 0;





    if (!LastDeviceFlg)

    {



        if (!Plugin_080_DS_reset())

        {



            LastDiscrep = 0;

            LastDeviceFlg = FALSE;

            LastFamilyDiscrep = 0;

            return FALSE;

        }





        Plugin_080_DS_write(0xF0);





        do

        {



            id_bit = Plugin_080_DS_read_bit();

            cmp_id_bit = Plugin_080_DS_read_bit();





            if ((id_bit == 1) && (cmp_id_bit == 1))

                break;

            else

            {



                if (id_bit != cmp_id_bit)

                    search_direction = id_bit;

                else

                {





                    if (id_bit_number < LastDiscrep)

                        search_direction = ((ROM_NBR[rom_byte_number] & rom_byte_mask) > 0);

                    else



                        search_direction = (id_bit_number == LastDiscrep);





                    if (search_direction == 0)

                    {

                        last_zero = id_bit_number;





                        if (last_zero < 9)

                            LastFamilyDiscrep = last_zero;

                    }

                }







                if (search_direction == 1)

                    ROM_NBR[rom_byte_number] |= rom_byte_mask;

                else

                    ROM_NBR[rom_byte_number] &= ~rom_byte_mask;





                Plugin_080_DS_write_bit(search_direction);







                id_bit_number++;

                rom_byte_mask <<= 1;





                if (rom_byte_mask == 0)

                {

                    rom_byte_number++;

                    rom_byte_mask = 1;

                }

            }

        }

        while (rom_byte_number < 8);





        if (!(id_bit_number < 65))

        {



            LastDiscrep = last_zero;





            if (LastDiscrep == 0)

                LastDeviceFlg = TRUE;



            search_result = TRUE;

        }

    }





    if (!search_result || !ROM_NBR[0])

    {

        LastDiscrep = 0;

        LastDeviceFlg = FALSE;

        LastFamilyDiscrep = 0;

        search_result = FALSE;

    }



    for (int i = 0; i < 8; i++)

        newAddr[i] = ROM_NBR[i];



    return search_result;

}
# 791 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
uint8_t Plugin_080_DS_read(void)

{

    uint8_t bitMask;

    uint8_t r = 0;



    for (bitMask = 0x01; bitMask; bitMask <<= 1)

        if (Plugin_080_DS_read_bit())

            r |= bitMask;



    return r;

}
# 821 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
void Plugin_080_DS_write(uint8_t ByteToWrite)

{

    uint8_t bitMask;

    for (bitMask = 0x01; bitMask; bitMask <<= 1)

        Plugin_080_DS_write_bit( (bitMask & ByteToWrite) ? 1 : 0);

}
# 841 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
uint8_t Plugin_080_DS_read_bit(void)

{

    uint8_t r;



    #if defined(ESP32)

       ESP32noInterrupts();

    #endif

    pinMode(Plugin_080_DallasPin, OUTPUT);

    digitalWrite(Plugin_080_DallasPin, LOW);

    delayMicroseconds(3);

    pinMode(Plugin_080_DallasPin, INPUT);

    delayMicroseconds(10);

    r = digitalRead(Plugin_080_DallasPin);

    #if defined(ESP32)

       ESP32interrupts();

    #endif

    delayMicroseconds(53);

    return r;

}





boolean Plugin_080_DS_readiButton(byte addr[8])

{







    Plugin_080_DS_reset();

    Plugin_080_DS_write(0x55);

    for (byte i = 0; i < 8; i++)

        Plugin_080_DS_write(addr[i]);



    Plugin_080_DS_write(0xBE);
# 915 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
    byte tmpaddr[8];

    bool found = false;

    Plugin_080_DS_reset();

    String log = F("DS   : iButton searching for address: ");

    for (byte j = 0; j < 8; j++)

    {

      log += String(addr[j], HEX);

      if (j < 7) log += F("-");

    }

    log += F(" found: ");

    Plugin_080_DS_reset_search();

    while (Plugin_080_DS_search(tmpaddr))

    {

       for (byte j = 0; j < 8; j++)

       {

         log += String(tmpaddr[j], HEX);

         if (j < 7) log += F("-");

       }

       log += F(",");

       if (memcmp(addr,tmpaddr,8)==0)

       {

         log += F("Success. Button was found");

         found=true;

       }

    }

    addLog(LOG_LEVEL_INFO, log);

    return found;

}







void Plugin_080_DS_write_bit(uint8_t v)

{

    if (v & 1)

    {

        #if defined(ESP32)

          ESP32noInterrupts();

        #endif

        digitalWrite(Plugin_080_DallasPin, LOW);

        pinMode(Plugin_080_DallasPin, OUTPUT);

        delayMicroseconds(10);

        digitalWrite(Plugin_080_DallasPin, HIGH);

        #if defined(ESP32)

          ESP32interrupts();

        #endif

        delayMicroseconds(55);

    }

    else

    {

        #if defined(ESP32)

          ESP32noInterrupts();

        #endif

        digitalWrite(Plugin_080_DallasPin, LOW);

        pinMode(Plugin_080_DallasPin, OUTPUT);

        delayMicroseconds(65);

        digitalWrite(Plugin_080_DallasPin, HIGH);

        #if defined(ESP32)

           ESP32interrupts();

        #endif

        delayMicroseconds(5);

    }

}
# 1047 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P080_DallasIButton.ino"
boolean Plugin_080_DS_crc8(uint8_t * addr)

{

  uint8_t crc = 0;

  uint8_t len = 8;



    while (len--)

    {

        uint8_t inbyte = *addr++;

        for (uint8_t i = 8; i; i--)

        {

            uint8_t mix = (crc ^ inbyte) & 0x01;

            crc >>= 1;

            if (mix) crc ^= 0x8C;

            inbyte >>= 1;

        }

    }

    return crc == *addr;

}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_P220_Mercury230.ino"
#ifdef USES_P220




#define PLUGIN_220 
#define PLUGIN_ID_220 220
#define PLUGIN_NAME_220 "Mercury 230"
#define PLUGIN_VALUENAME1_220 "Merc_data_json"
#define PLUGIN_VALUENAME2_220 "Merc_stat_json"
#include <ESPeasySoftwareSerial.h>
#define SerialControl 5
#define RS485Transmit HIGH
#define RS485Receive LOW

byte testConnect[] = { 0x00, 0x00 };
byte Access[] = { 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01};
byte Sn[] = { 0x00, 0x08, 0x00 };
byte Freq[] = { 0x00, 0x08, 0x16, 0x40 };
byte Current[] = { 0x00, 0x08, 0x16, 0x21 };
byte Suply[] = { 0x00, 0x08, 0x16, 0x11 };
byte Power[] = { 0x00, 0x08, 0x16, 0x00 };

byte PowerQ[] = { 0x00, 0x08, 0x16, 0x08 };
byte PowerS[] = { 0x00, 0x08, 0x16, 0x04 };

byte CosF[] = { 0x00, 0x08, 0x16, 0x30 };


byte Angle[] = { 0x00, 0x08, 0x16, 0x51 };
byte energyT0[] = { 0x00, 0x05, 0x00, 0x00 };

byte energyT1[] = { 0x00, 0x05, 0x00, 0x01 };
byte energyT2[] = { 0x00, 0x05, 0x00, 0x02 };
byte energyT3[] = { 0x00, 0x05, 0x00, 0x03 };
byte energyT4[] = { 0x00, 0x05, 0x00, 0x04 };

byte energyM1T1[] = { 0x00, 0x05, 0x31 ,0x01 };
byte energyM1T2[] = { 0x00, 0x05 ,0x31, 0x02 };
byte energyM2T1[] = { 0x00, 0x05, 0x32 ,0x01 };
byte energyM2T2[] = { 0x00, 0x05 ,0x32, 0x02 };
byte energyM3T1[] = { 0x00, 0x05, 0x33 ,0x01 };
byte energyM3T2[] = { 0x00, 0x05 ,0x33, 0x02 };
byte energyM4T1[] = { 0x00, 0x05, 0x34 ,0x01 };
byte energyM4T2[] = { 0x00, 0x05 ,0x34, 0x02 };
byte energyM5T1[] = { 0x00, 0x05, 0x35 ,0x01 };
byte energyM5T2[] = { 0x00, 0x05 ,0x35, 0x02 };
byte energyM6T1[] = { 0x00, 0x05, 0x36 ,0x01 };
byte energyM6T2[] = { 0x00, 0x05 ,0x36, 0x02 };
byte energyM7T1[] = { 0x00, 0x05, 0x37 ,0x01 };
byte energyM7T2[] = { 0x00, 0x05 ,0x37, 0x02 };
byte energyM8T1[] = { 0x00, 0x05, 0x38 ,0x01 };
byte energyM8T2[] = { 0x00, 0x05 ,0x38, 0x02 };
byte energyM9T1[] = { 0x00, 0x05, 0x39 ,0x01 };
byte energyM9T2[] = { 0x00, 0x05 ,0x39, 0x02 };
byte energyM10T1[] = { 0x00, 0x05, 0x3A ,0x01 };
byte energyM10T2[] = { 0x00, 0x05 ,0x3A, 0x02 };
byte energyM11T1[] = { 0x00, 0x05, 0x3B ,0x01 };
byte energyM11T2[] = { 0x00, 0x05 ,0x3B, 0x02 };
byte energyM12T1[] = { 0x00, 0x05, 0x3C ,0x01 };
byte energyM12T2[] = { 0x00, 0x05 ,0x3C, 0x02 };

byte response[19];
int byteReceived;
int byteSend;
int netAdr;
int SCAN_YES_NO=0;
int TST_YES_NO=0;
int ACCESS_YES_NO=0;
int ALLOW=0;
int count_stat=0;
int date_day;

ESPeasySoftwareSerial *RS485Serial;

boolean Plugin_220(byte function, struct EventStruct *event, String& string)
{
  boolean success = false;

  switch (function)
  {
    case PLUGIN_DEVICE_ADD:
      {
        Device[++deviceCount].Number = PLUGIN_ID_220;
        Device[deviceCount].Type = DEVICE_TYPE_DUAL;

        Device[deviceCount].Ports = 0;
        Device[deviceCount].PullUpOption = false;
        Device[deviceCount].InverseLogicOption = false;
        Device[deviceCount].FormulaOption = true;
        Device[deviceCount].ValueCount = 0;
        Device[deviceCount].SendDataOption = true;
        Device[deviceCount].TimerOption = true;
        Device[deviceCount].GlobalSyncOption = true;
        break;
      }

    case PLUGIN_GET_DEVICENAME:
      {
        string = F(PLUGIN_NAME_220);
        break;
      }

    case PLUGIN_GET_DEVICEVALUENAMES:
      {
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[0], PSTR(PLUGIN_VALUENAME1_220));
        strcpy_P(ExtraTaskSettings.TaskDeviceValueNames[1], PSTR(PLUGIN_VALUENAME2_220));

      break;
      }

    case PLUGIN_WEBFORM_LOAD:
      {
        addFormCheckBox(F("Read month stat"), F("plugin_220_stat"), Settings.TaskDevicePluginConfig[event->TaskIndex][0]);
        addFormNumericBox(F("Start time to read stat for every month, hour"), F("plugin_220_start_hour"), Settings.TaskDevicePluginConfig[event->TaskIndex][1], 0, 23);
        addFormNumericBox(F("Start time to read stat for every month, min"), F("plugin_220_start_min"), Settings.TaskDevicePluginConfig[event->TaskIndex][2], 0, 59);
       addFormNumericBox(F("End time to read stat for every month, hour"), F("plugin_220_end_hour"), Settings.TaskDevicePluginConfig[event->TaskIndex][3], 0, 23);
        addFormNumericBox(F("End time to read stat for every month, min"), F("plugin_220_end_min"), Settings.TaskDevicePluginConfig[event->TaskIndex][4], 0, 59);


        addFormNumericBox(F("Select MQTT controller to publish data in json format "), F("plugin_220_controller"), Settings.TaskDevicePluginConfig[event->TaskIndex][5], 1, 4);
        addFormNote(F("MQTT topic to publish runtime data is: \"Mercury230/Merc_data_json\""));
        addFormNote(F("MQTT topic to publish history data is: \"Mercury230/Merc_stat_json\""));
        addFormNote(F("Interval (below) must be shorter then period between end and start"));

        success = true;
        break;
      }

        case PLUGIN_WEBFORM_SAVE:
      {
        Settings.TaskDevicePluginConfig[event->TaskIndex][0] = isFormItemChecked(F("plugin_220_stat"));
        Settings.TaskDevicePluginConfig[event->TaskIndex][1] = getFormItemInt(F("plugin_220_start_hour"));
        Settings.TaskDevicePluginConfig[event->TaskIndex][2] = getFormItemInt(F("plugin_220_start_min"));
        Settings.TaskDevicePluginConfig[event->TaskIndex][3] = getFormItemInt(F("plugin_220_end_hour"));
        Settings.TaskDevicePluginConfig[event->TaskIndex][4] = getFormItemInt(F("plugin_220_end_min"));
        Settings.TaskDevicePluginConfig[event->TaskIndex][5] = getFormItemInt(F("plugin_220_controller"));
        success = true;
        break;
      }

      case PLUGIN_INIT:
      {
        RS485Serial = new ESPeasySoftwareSerial(Settings.TaskDevicePin1[event->TaskIndex], Settings.TaskDevicePin2[event->TaskIndex]);
        RS485Serial->begin(9600);
       Serial.begin(9600);
      pinMode(SerialControl, OUTPUT);
      digitalWrite(SerialControl, RS485Receive);
      delay(300);
      success = true;
      break;
      }


    case PLUGIN_READ:
      {
        TST_YES_NO=0;
        ACCESS_YES_NO=0;
        ALLOW=0;
        String getS = "loop_000";
        if(getS.substring(0,5) == "loop_")
          { ALLOW=1;
            SCAN_YES_NO=1;
            netAdr=getS.substring(5,8).toInt();

          }
        if(ALLOW==1 or SCAN_YES_NO==1)
          {
           testConnect[0] = netAdr;
           response[0] = 0;
           send(testConnect, sizeof(testConnect), response);
           if(response[0] == netAdr)
             { TST_YES_NO=1;
             }
            else
             { TST_YES_NO=0;
             }

           if(TST_YES_NO==1)
            {
             delay(100);
             Access[0] = netAdr;
             response[0] = 0;
             send(Access, sizeof(Access), response);
             if(response[0] == netAdr)
              { ACCESS_YES_NO=1;
              }
             else
              { ACCESS_YES_NO=0;
              }
            }


        if(ACCESS_YES_NO==1)
         {
          float* Uv = getCurrent(netAdr,Suply,12);
          float* Ia = getCurrent(netAdr,Current,12);
          float* Pw = getPowerNow(netAdr,15);
          float T1 = getEnergyMT(netAdr,energyT1,19);
          float T2 =getEnergyMT(netAdr,energyT2,19);
          float T3 = getEnergyMT(netAdr,energyT3,19);
          float T4 = getEnergyMT(netAdr,energyT4,19);
          String result1 = String("{");
          result1 += String( "\"Ia1\":" + String(Ia[0]/10) + ",\"Ia2\":"+ String(Ia[1]/10) + ",\"Ia3\":" + String(Ia[2]/10) + ",");
          result1 += String( "\"Uv1\":" + String(Uv[0]) + ",\"Uv2\":"+ String(Uv[1]) + ",\"Uv3\":" + String(Uv[2]) + ",");
          result1 += String( "\"Pw0\":" + String(Pw[0]) + ",\"Pw1\":"+ String(Pw[1]) + ",\"Pw2\":" + String(Pw[2]) + ",\"Pw3\":" + String(Pw[3]) + ",");
          result1 += String( "\"T1\":" + String(T1) + ",\"T2\":"+ String(T2) + ",\"T3\":"+ String(T3)+ ",\"T4\":"+ String(T4));
          result1 += String("}");
          String value = "";
          value = result1;
          String tmppubname = "/Mercury230/Merc_data_json";
          int controller = Settings.TaskDevicePluginConfig[event->TaskIndex][5];
          int Hours = hour();
          int Minutes = minute();
          int date_day = day();
          int start_hour = Settings.TaskDevicePluginConfig[event->TaskIndex][1];
          int start_min = Settings.TaskDevicePluginConfig[event->TaskIndex][2];
          int end_hour = Settings.TaskDevicePluginConfig[event->TaskIndex][3];
          int end_min = Settings.TaskDevicePluginConfig[event->TaskIndex][4];
          bool checked_stat = false;
          checked_stat = Settings.TaskDevicePluginConfig[event->TaskIndex][0];
          if ((checked_stat == true) & (count_stat == 0))
            {
              if ((start_hour <= Hours) & (end_hour >= Hours) & ( start_min <= Minutes) & (end_min >= Minutes) )
                {
                  String log = F("start get stat");
                  addLog(LOG_LEVEL_INFO, log);
                  float M1T1 = getEnergyMT(netAdr,energyM1T1,19);
                  float M1T2 = getEnergyMT(netAdr,energyM1T2,19);
                  float M2T1 = getEnergyMT(netAdr,energyM2T1,19);
                  float M2T2 = getEnergyMT(netAdr,energyM2T2,19);
                  float M3T1 = getEnergyMT(netAdr,energyM3T1,19);
                  float M3T2 = getEnergyMT(netAdr,energyM3T2,19);
                  float M4T1 = getEnergyMT(netAdr,energyM4T1,19);
                  float M4T2 = getEnergyMT(netAdr,energyM4T2,19);
                  float M5T1 = getEnergyMT(netAdr,energyM5T1,19);
                  float M5T2 = getEnergyMT(netAdr,energyM5T2,19);
                  float M6T1 = getEnergyMT(netAdr,energyM6T1,19);
                  float M6T2 = getEnergyMT(netAdr,energyM6T2,19);
                  float M7T1 = getEnergyMT(netAdr,energyM7T1,19);
                  float M7T2 = getEnergyMT(netAdr,energyM7T2,19);
                  float M8T1 = getEnergyMT(netAdr,energyM8T1,19);
                  float M8T2 = getEnergyMT(netAdr,energyM8T2,19);
                  float M9T1 = getEnergyMT(netAdr,energyM9T1,19);
                  float M9T2 = getEnergyMT(netAdr,energyM9T2,19);
                  float M10T1 = getEnergyMT(netAdr,energyM10T1,19);
                  float M10T2 = getEnergyMT(netAdr,energyM10T2,19);
                  float M11T1 = getEnergyMT(netAdr,energyM11T1,19);
                  float M11T2 = getEnergyMT(netAdr,energyM11T2,19);
                  float M12T1 = getEnergyMT(netAdr,energyM12T1,19);
                  float M12T2 = getEnergyMT(netAdr,energyM12T2,19);
                  String result2 = String("{");
                  result2 += String( "\"M1T1\":" + String(M1T1) + ",\"M1T2\":"+ String(M1T2) + ",\"M2T1\":" + String(M2T1) + ",\"M2T2\":" + String(M2T2)+ ",");
                  result2 += String( "\"M3T1\":" + String(M3T1) + ",\"M3T2\":"+ String(M3T2) + ",\"M4T1\":" + String(M4T1) + ",\"M4T2\":" + String(M4T2)+ ",");
                  result2 += String( "\"M5T1\":" + String(M5T1) + ",\"M5T2\":"+ String(M5T2) + ",\"M6T1\":" + String(M6T1) + ",\"M6T2\":" + String(M6T2)+ ",");
                  result2 += String( "\"M7T1\":" + String(M7T1) + ",\"M7T2\":"+ String(M7T2) + ",\"M8T1\":" + String(M8T1) + ",\"M8T2\":" + String(M8T2)+ ",");
                  result2 += String( "\"M9T1\":" + String(M9T1) + ",\"M9T2\":"+ String(M9T2) + ",\"M10T1\":" + String(M10T1) + ",\"M10T2\":" + String(M10T2)+ ",");
                  result2 += String( "\"M11T1\":" + String(M11T1) + ",\"M11T2\":"+ String(M11T2) + ",\"M12T1\":" + String(M12T1) + ",\"M12T2\":" + String(M12T2));
                  result2 += String("}");
                  value=result2;



                  tmppubname = "/Mercury230/Merc_stat_json";
                  count_stat == 1;
                }
             }
          MQTTpublish(controller, tmppubname.c_str(), value.c_str(), Settings.MQTTRetainFlag);
        }
        delay(1000);
        if ((count_stat == 1) & (day() != date_day))
          {count_stat = 0; }
        success = true;
        break;
      }
      }
  }
  return success;
}

String getSerialNumber(int netAdr)
 {
  String s1,s2,s3,s4;
  response[0]=0;
  Sn[0] = netAdr;
  send(Sn, sizeof(Sn),response);
  if((int)response[1] < 10) { s1="0" + String((int)response[1]); } else {s1=String((int)response[1]);}
  if((int)response[2] < 10) { s2="0" + String((int)response[2]); } else {s2=String((int)response[2]);}
  if((int)response[3] < 10) { s3="0" + String((int)response[3]); } else {s3=String((int)response[3]);}
  if((int)response[4] < 10) { s4="0" + String((int)response[4]); } else {s4=String((int)response[4]);}
  String n = s1+s2+s3+s4;
  String log = F("Sernumber ");
  log += n;
  addLog(LOG_LEVEL_INFO, log);
  return String(response[0])+";"+n;
}

float* getPowerNow(int netAdr, int length_resp)
{
  response[0]=0;
  Power[0] = netAdr;
  send(Power, sizeof(Power),response);
  int l = length_resp;






  byte crcb1=response[l-2];
  byte crcb2=response[l-1];
  unsigned int crcm = crc16MODBUS(response, l-2);
  unsigned int crc1m = crcm & 0xFF;
  unsigned int crc2m = (crcm>>8) & 0xFF;
  if ((crcb1 == crc1m) & (crcb2 ==crc2m) )
    {
    }
  else
    {
      String log = F("CRC is error!");
      addLog(LOG_LEVEL_INFO, log);
      return 0;
    }
  long* P = new long[4];
  response[1] &= ~(1<<6);
  response[1] &= ~(1<<7);
  response[4] &= ~(1<<6);
  response[4] &= ~(1<<7);
  response[7] &= ~(1<<6);
  response[7] &= ~(1<<7);
  response[10] &= ~(1<<6);
  response[10] &= ~(1<<7);

  P[0] = ((response[1] << 16)+ (response[3] << 8) + response[2]);
  P[1] = ((response[4] << 16)+ (response[6] << 8) + response[5]);
  P[2] = ((response[7] << 16)+ (response[9] << 8) + response[8]);
  P[3] = ((response[10] << 16)+ (response[12] << 8) + response[11]);
  float* U = new float[4];
  U[0] = ((float)P[0])/100;
  U[1] = ((float)P[1])/100;
  U[2] = ((float)P[2])/100;
  U[3] = ((float)P[3])/100;
  if(response[0] == netAdr) return (U);
    else return 0;
}

float* getCurrent(int netAdr,byte cmdget[], int length_resp)
{
  response[0]=0;
  Current[0] = netAdr;
  long* P = new long[3];
  send(cmdget, sizeof(Current),response);
  int l = length_resp;






  byte crcb1=response[l-2];
  byte crcb2=response[l-1];
  unsigned int crcm = crc16MODBUS(response, l-2);
  unsigned int crc1m = crcm & 0xFF;
  unsigned int crc2m = (crcm>>8) & 0xFF;
  if ((crcb1 == crc1m) & (crcb2 ==crc2m) )
    {
    }
  else
    {
      String log = F("CRC is error!");
      addLog(LOG_LEVEL_INFO, log);
      return 0;
    }

  P[0] = ((response[1] << 16)+ (response[3] << 8) + response[2]);
  P[1] = ((response[4] << 16)+ (response[6] << 8) + response[5]);
  P[2] = ((response[7] << 16)+ (response[9] << 8) + response[8]);
  float* U = new float[3];
  U[0] = ((float)P[0])/100;
  U[1] = ((float)P[1])/100;
  U[2] = ((float)P[2])/100;
      if(response[0] == netAdr) return (U);
    else return 0;
}

float getEnergyMT(int netAdr,byte cmdget[], int length_resp)
{
  response[0]=0;
  send(cmdget, sizeof(cmdget),response);
  int l = length_resp;






  byte crcb1=response[l-2];
  byte crcb2=response[l-1];
  unsigned int crcm = crc16MODBUS(response, l-2);
  unsigned int crc1m = crcm & 0xFF;
  unsigned int crc2m = (crcm>>8) & 0xFF;
  if ((crcb1 == crc1m) & (crcb2 ==crc2m) )
      {
      }
  else
      {
      String log = F("CRC is error!");
      addLog(LOG_LEVEL_INFO, log);
      return 0;
      }

  long P0 = ((response[2] << 24)+(response[1] << 16)+ (response[4] << 8) + response[3]);
  float U0 = ((float)P0)/1000;
  return U0;
}


void send(byte *cmd, int s, byte *response) {
  unsigned int crc = crc16MODBUS(cmd, s);
  unsigned int crc1 = crc & 0xFF;
  unsigned int crc2 = (crc>>8) & 0xFF;
  delay(10);
  digitalWrite(SerialControl, RS485Transmit);
       for(int i=0; i<s; i++)
       {
              RS485Serial->write(cmd[i]);
       }
  RS485Serial->write(crc1);
  RS485Serial->write(crc2);
  byte i = 0;
  digitalWrite(SerialControl, RS485Receive);
  delay(200);
         if (RS485Serial->available())
           {
             while (RS485Serial->available())
               {
                byteReceived= RS485Serial->read();
                delay(10);
                response[i++] = byteReceived;
                }
           }


  delay(20);
}

unsigned int crc16MODBUS(byte *s, int count) {
  unsigned int crcTable[] = {
        0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
        0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
        0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
        0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
        0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
        0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
        0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
        0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
        0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
        0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
        0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
        0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
        0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
        0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
        0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
        0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
        0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
        0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
        0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
        0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
        0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
        0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
        0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
        0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
        0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
        0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
        0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
        0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
        0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
        0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
        0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
        0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
    };

    unsigned int crc = 0xFFFF;

    for(int i = 0; i < count; i++) {
        crc = ((crc >> 8) ^ crcTable[(crc ^ s[i]) & 0xFF]);
    }

    return crc;
}

#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_Pxxx_PluginTemplate.ino"
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_Reporting.ino"




#ifdef FEATURE_REPORTING





#include <ArduinoJson.h>





#define REPORT_HOST "espeasy.datux.nl"

#define FEATURE_REPORTING 



void ReportStatus()

{

  String log;

  String host=F(REPORT_HOST);



  log=F("REP  : Reporting status to ");

  log+=host;

  addLog(LOG_LEVEL_INFO, log);





  WiFiClient client;

  if (client.connect(host.c_str(), 80) != 1)

  {

    addLog(LOG_LEVEL_ERROR, F("REP  : connection failed"));

    return;

  }



  StaticJsonBuffer<256> jsonBuffer;

  JsonObject& root = jsonBuffer.createObject();



  root[F("chipId")] = ESP.getChipId();

  root[F("flashId")] = ESP.getFlashChipId();

  root[F("uptime")] = wdcounter /2;







  String body;

  root.printTo(body);



  String payload = F("POST /report.php HTTP/1.1\r\n");

  payload += F("Host: ");

  payload += host;

  payload += F("\r\n");

  payload += F("Connection: close\r\n");

  payload += F("Content-Length: ");

  payload += String(body.length());

  payload += F("\r\n\r\n");

  payload += body;



  Serial.println(payload);

  client.print(payload);







  addLog(LOG_LEVEL_INFO, F("REP  : report uploaded"));



}
# 187 "C:/Users/admin/Documents/GitHub/ESPEasy/src/_Reporting.ino"
#endif
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/__CPlugin.ino"
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/__CPlugin.ino"
static const char ADDCPLUGIN_ERROR[] PROGMEM = "System: Error - To much C-Plugins";
# 37 "C:/Users/admin/Documents/GitHub/ESPEasy/src/__CPlugin.ino"
#define ADDCPLUGIN(NNN) if (x < CPLUGIN_MAX) { CPlugin_id[x] = CPLUGIN_ID_ ##NNN; CPlugin_ptr[x++] = &CPlugin_ ##NNN; } else addLog(LOG_LEVEL_ERROR, FPSTR(ADDCPLUGIN_ERROR));





void CPluginInit(void)

{

  byte x;





  for (x = 0; x < CPLUGIN_MAX; x++)

  {

    CPlugin_ptr[x] = 0;

    CPlugin_id[x] = 0;

  }



  x = 0;



#ifdef CPLUGIN_001

  ADDCPLUGIN(001)

#endif



#ifdef CPLUGIN_002

  ADDCPLUGIN(002)

#endif



#ifdef CPLUGIN_003

  ADDCPLUGIN(003)

#endif



#ifdef CPLUGIN_004

  ADDCPLUGIN(004)

#endif



#ifdef CPLUGIN_005

  ADDCPLUGIN(005)

#endif



#ifdef CPLUGIN_006

  ADDCPLUGIN(006)

#endif



#ifdef CPLUGIN_007

  ADDCPLUGIN(007)

#endif



#ifdef CPLUGIN_008

  ADDCPLUGIN(008)

#endif



#ifdef CPLUGIN_009

  ADDCPLUGIN(009)

#endif



#ifdef CPLUGIN_010

  ADDCPLUGIN(010)

#endif



#ifdef CPLUGIN_011

  ADDCPLUGIN(011)

#endif



#ifdef CPLUGIN_012

  ADDCPLUGIN(012)

#endif



#ifdef CPLUGIN_013

  ADDCPLUGIN(013)

#endif



#ifdef CPLUGIN_014

  ADDCPLUGIN(014)

#endif



#ifdef CPLUGIN_015

  ADDCPLUGIN(015)

#endif



#ifdef CPLUGIN_016

  ADDCPLUGIN(016)

#endif



#ifdef CPLUGIN_017

  ADDCPLUGIN(017)

#endif



#ifdef CPLUGIN_018

  ADDCPLUGIN(018)

#endif



#ifdef CPLUGIN_019

  ADDCPLUGIN(019)

#endif



#ifdef CPLUGIN_020

  ADDCPLUGIN(020)

#endif



#ifdef CPLUGIN_021

  ADDCPLUGIN(021)

#endif



#ifdef CPLUGIN_022

  ADDCPLUGIN(022)

#endif



#ifdef CPLUGIN_023

  ADDCPLUGIN(023)

#endif



#ifdef CPLUGIN_024

  ADDCPLUGIN(024)

#endif



#ifdef CPLUGIN_025

  ADDCPLUGIN(025)

#endif



  CPluginCall(CPLUGIN_PROTOCOL_ADD, 0);

  CPluginCall(CPLUGIN_INIT, 0);

}



byte CPluginCall(byte Function, struct EventStruct *event)

{

  int x;

  struct EventStruct TempEvent;



 if (event == 0)

    event=&TempEvent;



  switch (Function)

  {



    case CPLUGIN_PROTOCOL_ADD:

      for (x = 0; x < CPLUGIN_MAX; x++) {

        if (CPlugin_id[x] != 0) {

          const unsigned int next_ProtocolIndex = protocolCount + 2;

          if (next_ProtocolIndex > Protocol.size()) {



            unsigned int newSize = Protocol.size();

            newSize = newSize + 8 - (newSize % 8);

            Protocol.resize(newSize);

          }

          checkRAM(F("CPluginCallADD"),x);

          CPlugin_ptr[x](Function, event, dummyString);

        }

      }

      return true;

      break;





    case CPLUGIN_INIT:

    case CPLUGIN_UDP_IN:

      for (byte x=0; x < CONTROLLER_MAX; x++)

        if (Settings.Protocol[x] != 0 && Settings.ControllerEnabled[x]) {

          event->ProtocolIndex = getProtocolIndex(Settings.Protocol[x]);

          CPlugin_ptr[event->ProtocolIndex](Function, event, dummyString);

        }

      return true;

      break;

  }



  return false;

}





bool anyControllerEnabled() {

  for (byte i=0; i < CONTROLLER_MAX; i++) {

    if (Settings.Protocol[i] != 0 && Settings.ControllerEnabled[i]) {

      return true;

    }

  }

  return false;

}





byte findFirstEnabledControllerWithId(byte cpluginid) {

  for (byte i=0; i < CONTROLLER_MAX; i++) {

    if (Settings.Protocol[i] == cpluginid && Settings.ControllerEnabled[i]) {

      return i;

    }

  }

  return CONTROLLER_MAX;

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/__NPlugin.ino"
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/__NPlugin.ino"
static const char ADDNPLUGIN_ERROR[] PROGMEM = "System: Error - To much N-Plugins";
# 39 "C:/Users/admin/Documents/GitHub/ESPEasy/src/__NPlugin.ino"
#define ADDNPLUGIN(NNN) if (x < NPLUGIN_MAX) { NPlugin_id[x] = NPLUGIN_ID_ ##NNN; NPlugin_ptr[x++] = &NPlugin_ ##NNN; } else addLog(LOG_LEVEL_ERROR, FPSTR(ADDNPLUGIN_ERROR));





void NPluginInit(void)

{

  byte x;





  for (x = 0; x < NPLUGIN_MAX; x++)

  {

    NPlugin_ptr[x] = 0;

    NPlugin_id[x] = 0;

  }



  x = 0;



#ifdef NPLUGIN_001

  ADDNPLUGIN(001)

#endif



#ifdef NPLUGIN_002

  ADDNPLUGIN(002)

#endif



#ifdef NPLUGIN_003

  ADDNPLUGIN(003)

#endif



#ifdef NPLUGIN_004

  ADDNPLUGIN(004)

#endif



#ifdef NPLUGIN_005

  ADDNPLUGIN(005)

#endif



#ifdef NPLUGIN_006

  ADDNPLUGIN(006)

#endif



#ifdef NPLUGIN_007

  ADDNPLUGIN(007)

#endif



#ifdef NPLUGIN_008

  ADDNPLUGIN(008)

#endif



#ifdef NPLUGIN_009

  ADDNPLUGIN(009)

#endif



#ifdef NPLUGIN_010

  ADDNPLUGIN(010)

#endif



#ifdef NPLUGIN_011

  ADDNPLUGIN(011)

#endif



#ifdef NPLUGIN_012

  ADDNPLUGIN(012)

#endif



#ifdef NPLUGIN_013

  ADDNPLUGIN(013)

#endif



#ifdef NPLUGIN_014

  ADDNPLUGIN(014)

#endif



#ifdef NPLUGIN_015

  ADDNPLUGIN(015)

#endif



#ifdef NPLUGIN_016

  ADDNPLUGIN(016)

#endif



#ifdef NPLUGIN_017

  ADDNPLUGIN(017)

#endif



#ifdef NPLUGIN_018

  ADDNPLUGIN(018)

#endif



#ifdef NPLUGIN_019

  ADDNPLUGIN(019)

#endif



#ifdef NPLUGIN_020

  ADDNPLUGIN(020)

#endif



#ifdef NPLUGIN_021

  ADDNPLUGIN(021)

#endif



#ifdef NPLUGIN_022

  ADDNPLUGIN(022)

#endif



#ifdef NPLUGIN_023

  ADDNPLUGIN(023)

#endif



#ifdef NPLUGIN_024

  ADDNPLUGIN(024)

#endif



#ifdef NPLUGIN_025

  ADDNPLUGIN(025)

#endif



  NPluginCall(NPLUGIN_PROTOCOL_ADD, 0);

}



byte NPluginCall(byte Function, struct EventStruct *event)

{

  int x;

  struct EventStruct TempEvent;



 if (event == 0)

    event=&TempEvent;



  switch (Function)

  {



    case NPLUGIN_PROTOCOL_ADD:

      for (x = 0; x < NPLUGIN_MAX; x++)

        if (NPlugin_id[x] != 0)

          NPlugin_ptr[x](Function, event, dummyString);

      return true;

      break;

  }



  return false;

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/__Plugin.ino"
# 11 "C:/Users/admin/Documents/GitHub/ESPEasy/src/__Plugin.ino"
static const char ADDPLUGIN_ERROR[] PROGMEM = "System: Error - To much Plugins";
# 37 "C:/Users/admin/Documents/GitHub/ESPEasy/src/__Plugin.ino"
#define ADDPLUGIN(NNN) if (x < PLUGIN_MAX) { Plugin_id[x] = PLUGIN_ID_ ##NNN; Plugin_ptr[x++] = &Plugin_ ##NNN; } else addLog(LOG_LEVEL_ERROR, FPSTR(ADDPLUGIN_ERROR));





void PluginInit(void)

{

  byte x;





  for (x = 0; x < PLUGIN_MAX; x++)

  {

    Plugin_ptr[x] = 0;

    Plugin_id[x] = 0;

  }



  for (x = 0; x < TASKS_MAX; x++)

  {

    Task_id_to_Plugin_id[x] = -1;

  }



  x = 0;



#ifdef PLUGIN_001

  ADDPLUGIN(001)

#endif



#ifdef PLUGIN_002

  ADDPLUGIN(002)

#endif



#ifdef PLUGIN_003

  ADDPLUGIN(003)

#endif



#ifdef PLUGIN_004

  ADDPLUGIN(004)

#endif



#ifdef PLUGIN_005

  ADDPLUGIN(005)

#endif



#ifdef PLUGIN_006

  ADDPLUGIN(006)

#endif



#ifdef PLUGIN_007

  ADDPLUGIN(007)

#endif



#ifdef PLUGIN_008

  ADDPLUGIN(008)

#endif



#ifdef PLUGIN_009

  ADDPLUGIN(009)

#endif



#ifdef PLUGIN_010

  ADDPLUGIN(010)

#endif



#ifdef PLUGIN_011

  ADDPLUGIN(011)

#endif



#ifdef PLUGIN_012

  ADDPLUGIN(012)

#endif



#ifdef PLUGIN_013

  ADDPLUGIN(013)

#endif



#ifdef PLUGIN_014

  ADDPLUGIN(014)

#endif



#ifdef PLUGIN_015

  ADDPLUGIN(015)

#endif



#ifdef PLUGIN_016

  ADDPLUGIN(016)

#endif



#ifdef PLUGIN_017

  ADDPLUGIN(017)

#endif



#ifdef PLUGIN_018

  ADDPLUGIN(018)

#endif



#ifdef PLUGIN_019

  ADDPLUGIN(019)

#endif



#ifdef PLUGIN_020

  ADDPLUGIN(020)

#endif



#ifdef PLUGIN_021

  ADDPLUGIN(021)

#endif



#ifdef PLUGIN_022

  ADDPLUGIN(022)

#endif



#ifdef PLUGIN_023

  ADDPLUGIN(023)

#endif



#ifdef PLUGIN_024

  ADDPLUGIN(024)

#endif



#ifdef PLUGIN_025

  ADDPLUGIN(025)

#endif



#ifdef PLUGIN_026

  ADDPLUGIN(026)

#endif



#ifdef PLUGIN_027

  ADDPLUGIN(027)

#endif



#ifdef PLUGIN_028

  ADDPLUGIN(028)

#endif



#ifdef PLUGIN_029

  ADDPLUGIN(029)

#endif



#ifdef PLUGIN_030

  ADDPLUGIN(030)

#endif



#ifdef PLUGIN_031

  ADDPLUGIN(031)

#endif



#ifdef PLUGIN_032

  ADDPLUGIN(032)

#endif



#ifdef PLUGIN_033

  ADDPLUGIN(033)

#endif



#ifdef PLUGIN_034

  ADDPLUGIN(034)

#endif



#ifdef PLUGIN_035

  ADDPLUGIN(035)

#endif



#ifdef PLUGIN_036

  ADDPLUGIN(036)

#endif



#ifdef PLUGIN_037

  ADDPLUGIN(037)

#endif



#ifdef PLUGIN_038

  ADDPLUGIN(038)

#endif



#ifdef PLUGIN_039

  ADDPLUGIN(039)

#endif



#ifdef PLUGIN_040

  ADDPLUGIN(040)

#endif



#ifdef PLUGIN_041

  ADDPLUGIN(041)

#endif



#ifdef PLUGIN_042

  ADDPLUGIN(042)

#endif



#ifdef PLUGIN_043

  ADDPLUGIN(043)

#endif



#ifdef PLUGIN_044

  ADDPLUGIN(044)

#endif



#ifdef PLUGIN_045

  ADDPLUGIN(045)

#endif



#ifdef PLUGIN_046

  ADDPLUGIN(046)

#endif



#ifdef PLUGIN_047

  ADDPLUGIN(047)

#endif



#ifdef PLUGIN_048

  ADDPLUGIN(048)

#endif



#ifdef PLUGIN_049

  ADDPLUGIN(049)

#endif



#ifdef PLUGIN_050

  ADDPLUGIN(050)

#endif



#ifdef PLUGIN_051

  ADDPLUGIN(051)

#endif



#ifdef PLUGIN_052

  ADDPLUGIN(052)

#endif



#ifdef PLUGIN_053

  ADDPLUGIN(053)

#endif



#ifdef PLUGIN_054

  ADDPLUGIN(054)

#endif



#ifdef PLUGIN_055

  ADDPLUGIN(055)

#endif



#ifdef PLUGIN_056

  ADDPLUGIN(056)

#endif



#ifdef PLUGIN_057

  ADDPLUGIN(057)

#endif



#ifdef PLUGIN_058

  ADDPLUGIN(058)

#endif



#ifdef PLUGIN_059

  ADDPLUGIN(059)

#endif



#ifdef PLUGIN_060

  ADDPLUGIN(060)

#endif



#ifdef PLUGIN_061

  ADDPLUGIN(061)

#endif



#ifdef PLUGIN_062

  ADDPLUGIN(062)

#endif



#ifdef PLUGIN_063

  ADDPLUGIN(063)

#endif



#ifdef PLUGIN_064

  ADDPLUGIN(064)

#endif



#ifdef PLUGIN_065

  ADDPLUGIN(065)

#endif



#ifdef PLUGIN_066

  ADDPLUGIN(066)

#endif



#ifdef PLUGIN_067

  ADDPLUGIN(067)

#endif



#ifdef PLUGIN_068

  ADDPLUGIN(068)

#endif



#ifdef PLUGIN_069

  ADDPLUGIN(069)

#endif



#ifdef PLUGIN_070

  ADDPLUGIN(070)

#endif



#ifdef PLUGIN_071

  ADDPLUGIN(071)

#endif



#ifdef PLUGIN_072

  ADDPLUGIN(072)

#endif



#ifdef PLUGIN_073

  ADDPLUGIN(073)

#endif



#ifdef PLUGIN_074

  ADDPLUGIN(074)

#endif



#ifdef PLUGIN_075

  ADDPLUGIN(075)

#endif



#ifdef PLUGIN_076

  ADDPLUGIN(076)

#endif



#ifdef PLUGIN_077

  ADDPLUGIN(077)

#endif



#ifdef PLUGIN_078

  ADDPLUGIN(078)

#endif



#ifdef PLUGIN_079

  ADDPLUGIN(079)

#endif



#ifdef PLUGIN_080

  ADDPLUGIN(080)

#endif



#ifdef PLUGIN_081

  ADDPLUGIN(081)

#endif



#ifdef PLUGIN_082

  ADDPLUGIN(082)

#endif



#ifdef PLUGIN_083

  ADDPLUGIN(083)

#endif



#ifdef PLUGIN_084

  ADDPLUGIN(084)

#endif



#ifdef PLUGIN_085

  ADDPLUGIN(085)

#endif



#ifdef PLUGIN_086

  ADDPLUGIN(086)

#endif



#ifdef PLUGIN_087

  ADDPLUGIN(087)

#endif



#ifdef PLUGIN_088

  ADDPLUGIN(088)

#endif



#ifdef PLUGIN_089

  ADDPLUGIN(089)

#endif



#ifdef PLUGIN_090

  ADDPLUGIN(090)

#endif



#ifdef PLUGIN_091

  ADDPLUGIN(091)

#endif



#ifdef PLUGIN_092

  ADDPLUGIN(092)

#endif



#ifdef PLUGIN_093

  ADDPLUGIN(093)

#endif



#ifdef PLUGIN_094

  ADDPLUGIN(094)

#endif



#ifdef PLUGIN_095

  ADDPLUGIN(095)

#endif



#ifdef PLUGIN_096

  ADDPLUGIN(096)

#endif



#ifdef PLUGIN_097

  ADDPLUGIN(097)

#endif



#ifdef PLUGIN_098

  ADDPLUGIN(098)

#endif



#ifdef PLUGIN_099

  ADDPLUGIN(099)

#endif



#ifdef PLUGIN_100

  ADDPLUGIN(100)

#endif



#ifdef PLUGIN_101

  ADDPLUGIN(101)

#endif



#ifdef PLUGIN_102

  ADDPLUGIN(102)

#endif



#ifdef PLUGIN_103

  ADDPLUGIN(103)

#endif



#ifdef PLUGIN_104

  ADDPLUGIN(104)

#endif



#ifdef PLUGIN_105

  ADDPLUGIN(105)

#endif



#ifdef PLUGIN_106

  ADDPLUGIN(106)

#endif



#ifdef PLUGIN_107

  ADDPLUGIN(107)

#endif



#ifdef PLUGIN_108

  ADDPLUGIN(108)

#endif



#ifdef PLUGIN_109

  ADDPLUGIN(109)

#endif



#ifdef PLUGIN_110

  ADDPLUGIN(110)

#endif



#ifdef PLUGIN_111

  ADDPLUGIN(111)

#endif



#ifdef PLUGIN_112

  ADDPLUGIN(112)

#endif



#ifdef PLUGIN_113

  ADDPLUGIN(113)

#endif



#ifdef PLUGIN_114

  ADDPLUGIN(114)

#endif



#ifdef PLUGIN_115

  ADDPLUGIN(115)

#endif



#ifdef PLUGIN_116

  ADDPLUGIN(116)

#endif



#ifdef PLUGIN_117

  ADDPLUGIN(117)

#endif



#ifdef PLUGIN_118

  ADDPLUGIN(118)

#endif



#ifdef PLUGIN_119

  ADDPLUGIN(119)

#endif



#ifdef PLUGIN_120

  ADDPLUGIN(120)

#endif



#ifdef PLUGIN_121

  ADDPLUGIN(121)

#endif



#ifdef PLUGIN_122

  ADDPLUGIN(122)

#endif



#ifdef PLUGIN_123

  ADDPLUGIN(123)

#endif



#ifdef PLUGIN_124

  ADDPLUGIN(124)

#endif



#ifdef PLUGIN_125

  ADDPLUGIN(125)

#endif



#ifdef PLUGIN_126

  ADDPLUGIN(126)

#endif



#ifdef PLUGIN_127

  ADDPLUGIN(127)

#endif



#ifdef PLUGIN_128

  ADDPLUGIN(128)

#endif



#ifdef PLUGIN_129

  ADDPLUGIN(129)

#endif



#ifdef PLUGIN_130

  ADDPLUGIN(130)

#endif



#ifdef PLUGIN_131

  ADDPLUGIN(131)

#endif



#ifdef PLUGIN_132

  ADDPLUGIN(132)

#endif



#ifdef PLUGIN_133

  ADDPLUGIN(133)

#endif



#ifdef PLUGIN_134

  ADDPLUGIN(134)

#endif



#ifdef PLUGIN_135

  ADDPLUGIN(135)

#endif



#ifdef PLUGIN_136

  ADDPLUGIN(136)

#endif



#ifdef PLUGIN_137

  ADDPLUGIN(137)

#endif



#ifdef PLUGIN_138

  ADDPLUGIN(138)

#endif



#ifdef PLUGIN_139

  ADDPLUGIN(139)

#endif



#ifdef PLUGIN_140

  ADDPLUGIN(140)

#endif



#ifdef PLUGIN_141

  ADDPLUGIN(141)

#endif



#ifdef PLUGIN_142

  ADDPLUGIN(142)

#endif



#ifdef PLUGIN_143

  ADDPLUGIN(143)

#endif



#ifdef PLUGIN_144

  ADDPLUGIN(144)

#endif



#ifdef PLUGIN_145

  ADDPLUGIN(145)

#endif



#ifdef PLUGIN_146

  ADDPLUGIN(146)

#endif



#ifdef PLUGIN_147

  ADDPLUGIN(147)

#endif



#ifdef PLUGIN_148

  ADDPLUGIN(148)

#endif



#ifdef PLUGIN_149

  ADDPLUGIN(149)

#endif



#ifdef PLUGIN_150

  ADDPLUGIN(150)

#endif



#ifdef PLUGIN_151

  ADDPLUGIN(151)

#endif



#ifdef PLUGIN_152

  ADDPLUGIN(152)

#endif



#ifdef PLUGIN_153

  ADDPLUGIN(153)

#endif



#ifdef PLUGIN_154

  ADDPLUGIN(154)

#endif



#ifdef PLUGIN_155

  ADDPLUGIN(155)

#endif



#ifdef PLUGIN_156

  ADDPLUGIN(156)

#endif



#ifdef PLUGIN_157

  ADDPLUGIN(157)

#endif



#ifdef PLUGIN_158

  ADDPLUGIN(158)

#endif



#ifdef PLUGIN_159

  ADDPLUGIN(159)

#endif



#ifdef PLUGIN_160

  ADDPLUGIN(160)

#endif



#ifdef PLUGIN_161

  ADDPLUGIN(161)

#endif



#ifdef PLUGIN_162

  ADDPLUGIN(162)

#endif



#ifdef PLUGIN_163

  ADDPLUGIN(163)

#endif



#ifdef PLUGIN_164

  ADDPLUGIN(164)

#endif



#ifdef PLUGIN_165

  ADDPLUGIN(165)

#endif



#ifdef PLUGIN_166

  ADDPLUGIN(166)

#endif



#ifdef PLUGIN_167

  ADDPLUGIN(167)

#endif



#ifdef PLUGIN_168

  ADDPLUGIN(168)

#endif



#ifdef PLUGIN_169

  ADDPLUGIN(169)

#endif



#ifdef PLUGIN_170

  ADDPLUGIN(170)

#endif



#ifdef PLUGIN_171

  ADDPLUGIN(171)

#endif



#ifdef PLUGIN_172

  ADDPLUGIN(172)

#endif



#ifdef PLUGIN_173

  ADDPLUGIN(173)

#endif



#ifdef PLUGIN_174

  ADDPLUGIN(174)

#endif



#ifdef PLUGIN_175

  ADDPLUGIN(175)

#endif



#ifdef PLUGIN_176

  ADDPLUGIN(176)

#endif



#ifdef PLUGIN_177

  ADDPLUGIN(177)

#endif



#ifdef PLUGIN_178

  ADDPLUGIN(178)

#endif



#ifdef PLUGIN_179

  ADDPLUGIN(179)

#endif



#ifdef PLUGIN_180

  ADDPLUGIN(180)

#endif



#ifdef PLUGIN_181

  ADDPLUGIN(181)

#endif



#ifdef PLUGIN_182

  ADDPLUGIN(182)

#endif



#ifdef PLUGIN_183

  ADDPLUGIN(183)

#endif



#ifdef PLUGIN_184

  ADDPLUGIN(184)

#endif



#ifdef PLUGIN_185

  ADDPLUGIN(185)

#endif



#ifdef PLUGIN_186

  ADDPLUGIN(186)

#endif



#ifdef PLUGIN_187

  ADDPLUGIN(187)

#endif



#ifdef PLUGIN_188

  ADDPLUGIN(188)

#endif



#ifdef PLUGIN_189

  ADDPLUGIN(189)

#endif



#ifdef PLUGIN_190

  ADDPLUGIN(190)

#endif



#ifdef PLUGIN_191

  ADDPLUGIN(191)

#endif



#ifdef PLUGIN_192

  ADDPLUGIN(192)

#endif



#ifdef PLUGIN_193

  ADDPLUGIN(193)

#endif



#ifdef PLUGIN_194

  ADDPLUGIN(194)

#endif



#ifdef PLUGIN_195

  ADDPLUGIN(195)

#endif



#ifdef PLUGIN_196

  ADDPLUGIN(196)

#endif



#ifdef PLUGIN_197

  ADDPLUGIN(197)

#endif



#ifdef PLUGIN_198

  ADDPLUGIN(198)

#endif



#ifdef PLUGIN_199

  ADDPLUGIN(199)

#endif



#ifdef PLUGIN_200

  ADDPLUGIN(200)

#endif



#ifdef PLUGIN_201

  ADDPLUGIN(201)

#endif



#ifdef PLUGIN_202

  ADDPLUGIN(202)

#endif



#ifdef PLUGIN_203

  ADDPLUGIN(203)

#endif



#ifdef PLUGIN_204

  ADDPLUGIN(204)

#endif



#ifdef PLUGIN_205

  ADDPLUGIN(205)

#endif



#ifdef PLUGIN_206

  ADDPLUGIN(206)

#endif



#ifdef PLUGIN_207

  ADDPLUGIN(207)

#endif



#ifdef PLUGIN_208

  ADDPLUGIN(208)

#endif



#ifdef PLUGIN_209

  ADDPLUGIN(209)

#endif



#ifdef PLUGIN_210

  ADDPLUGIN(210)

#endif



#ifdef PLUGIN_211

  ADDPLUGIN(211)

#endif



#ifdef PLUGIN_212

  ADDPLUGIN(212)

#endif



#ifdef PLUGIN_213

  ADDPLUGIN(213)

#endif



#ifdef PLUGIN_214

  ADDPLUGIN(214)

#endif



#ifdef PLUGIN_215

  ADDPLUGIN(215)

#endif



#ifdef PLUGIN_216

  ADDPLUGIN(216)

#endif



#ifdef PLUGIN_217

  ADDPLUGIN(217)

#endif



#ifdef PLUGIN_218

  ADDPLUGIN(218)

#endif



#ifdef PLUGIN_219

  ADDPLUGIN(219)

#endif



#ifdef PLUGIN_220

  ADDPLUGIN(220)

#endif



#ifdef PLUGIN_221

  ADDPLUGIN(221)

#endif



#ifdef PLUGIN_222

  ADDPLUGIN(222)

#endif



#ifdef PLUGIN_223

  ADDPLUGIN(223)

#endif



#ifdef PLUGIN_224

  ADDPLUGIN(224)

#endif



#ifdef PLUGIN_225

  ADDPLUGIN(225)

#endif



#ifdef PLUGIN_226

  ADDPLUGIN(226)

#endif



#ifdef PLUGIN_227

  ADDPLUGIN(227)

#endif



#ifdef PLUGIN_228

  ADDPLUGIN(228)

#endif



#ifdef PLUGIN_229

  ADDPLUGIN(229)

#endif



#ifdef PLUGIN_230

  ADDPLUGIN(230)

#endif



#ifdef PLUGIN_231

  ADDPLUGIN(231)

#endif



#ifdef PLUGIN_232

  ADDPLUGIN(232)

#endif



#ifdef PLUGIN_233

  ADDPLUGIN(233)

#endif



#ifdef PLUGIN_234

  ADDPLUGIN(234)

#endif



#ifdef PLUGIN_235

  ADDPLUGIN(235)

#endif



#ifdef PLUGIN_236

  ADDPLUGIN(236)

#endif



#ifdef PLUGIN_237

  ADDPLUGIN(237)

#endif



#ifdef PLUGIN_238

  ADDPLUGIN(238)

#endif



#ifdef PLUGIN_239

  ADDPLUGIN(239)

#endif



#ifdef PLUGIN_240

  ADDPLUGIN(240)

#endif



#ifdef PLUGIN_241

  ADDPLUGIN(241)

#endif



#ifdef PLUGIN_242

  ADDPLUGIN(242)

#endif



#ifdef PLUGIN_243

  ADDPLUGIN(243)

#endif



#ifdef PLUGIN_244

  ADDPLUGIN(244)

#endif



#ifdef PLUGIN_245

  ADDPLUGIN(245)

#endif



#ifdef PLUGIN_246

  ADDPLUGIN(246)

#endif



#ifdef PLUGIN_247

  ADDPLUGIN(247)

#endif



#ifdef PLUGIN_248

  ADDPLUGIN(248)

#endif



#ifdef PLUGIN_249

  ADDPLUGIN(249)

#endif



#ifdef PLUGIN_250

  ADDPLUGIN(250)

#endif



#ifdef PLUGIN_251

  ADDPLUGIN(251)

#endif



#ifdef PLUGIN_252

  ADDPLUGIN(252)

#endif



#ifdef PLUGIN_253

  ADDPLUGIN(253)

#endif



#ifdef PLUGIN_254

  ADDPLUGIN(254)

#endif



#ifdef PLUGIN_255

  ADDPLUGIN(255)

#endif



  PluginCall(PLUGIN_DEVICE_ADD, 0, dummyString);

  PluginCall(PLUGIN_INIT_ALL, 0, dummyString);



}



int getPluginId(byte taskId) {

  if (taskId < TASKS_MAX) {

    int retry = 1;

    while (retry >= 0) {

      int plugin = Task_id_to_Plugin_id[taskId];

      if (plugin >= 0 && plugin < PLUGIN_MAX) {

        if (Plugin_id[plugin] == Settings.TaskDeviceNumber[taskId])

          return plugin;

      }

      updateTaskPluginCache();

      --retry;

    }

  }

  return -1;

}



void updateTaskPluginCache() {

  ++countFindPluginId;

  Task_id_to_Plugin_id.resize(TASKS_MAX);

  for (byte y = 0; y < TASKS_MAX; ++y) {

    Task_id_to_Plugin_id[y] = -1;

    bool foundPlugin = false;

    for (byte x = 0; x < PLUGIN_MAX && !foundPlugin; ++x) {

      if (Plugin_id[x] != 0 && Plugin_id[x] == Settings.TaskDeviceNumber[y]) {

        foundPlugin = true;

        Task_id_to_Plugin_id[y] = x;

      }

    }

  }

}
# 2199 "C:/Users/admin/Documents/GitHub/ESPEasy/src/__Plugin.ino"
byte PluginCall(byte Function, struct EventStruct *event, String& str)

{

  struct EventStruct TempEvent;



  if (event == 0)

    event = &TempEvent;

  else

    TempEvent = (*event);



  switch (Function)

  {



    case PLUGIN_DEVICE_ADD:

    case PLUGIN_UNCONDITIONAL_POLL:

      for (byte x = 0; x < PLUGIN_MAX; x++) {

        if (Plugin_id[x] != 0){

          if (Function == PLUGIN_DEVICE_ADD) {

            const unsigned int next_DeviceIndex = deviceCount + 2;

            if (next_DeviceIndex > Device.size()) {



              unsigned int newSize = Device.size();

              newSize = newSize + 16 - (newSize % 16);

              Device.resize(newSize);

            }

          }

          START_TIMER;

          Plugin_ptr[x](Function, event, str);

          STOP_TIMER_TASK(x,Function);

        }

      }

      return true;

      break;





    case PLUGIN_WRITE:

    case PLUGIN_REQUEST:

      {

        for (byte y = 0; y < TASKS_MAX; y++)

        {

          if (Settings.TaskDeviceEnabled[y] && Settings.TaskDeviceNumber[y] != 0)

          {

            if (Settings.TaskDeviceDataFeed[y] == 0)

            {

              const int x = getPluginId(y);

              if (x >= 0) {

                byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[y]);

                TempEvent.TaskIndex = y;

                TempEvent.BaseVarIndex = y * VARS_PER_TASK;

                TempEvent.sensorType = Device[DeviceIndex].VType;

                checkRAM(F("PluginCall_s"),x);

                START_TIMER;

                bool retval = (Plugin_ptr[x](Function, &TempEvent, str));

                STOP_TIMER_TASK(x,Function);

                if (retval) return true;

              }

            }

          }

        }



        for (byte x = 0; x < PLUGIN_MAX; x++)

          if (Plugin_id[x] != 0)

            if (Plugin_ptr[x](Function, event, str))

              return true;

      }

      break;





    case PLUGIN_SERIAL_IN:

    case PLUGIN_UDP_IN:

      {

        for (byte y = 0; y < TASKS_MAX; y++)

        {

          if (Settings.TaskDeviceEnabled[y] && Settings.TaskDeviceNumber[y] != 0)

          {

            const int x = getPluginId(y);

            if (x >= 0) {

              byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[y]);

              TempEvent.TaskIndex = y;

              TempEvent.BaseVarIndex = y * VARS_PER_TASK;



              TempEvent.sensorType = Device[DeviceIndex].VType;

              START_TIMER;

              bool retval = (Plugin_ptr[x](Function, &TempEvent, str));

              STOP_TIMER_TASK(x,Function);

              if (retval){

                checkRAM(F("PluginCallUDP"),x);

                return true;

              }

            }

          }

        }

        return false;

        break;

      }





    case PLUGIN_ONCE_A_SECOND:

    case PLUGIN_TEN_PER_SECOND:

    case PLUGIN_FIFTY_PER_SECOND:

    case PLUGIN_INIT_ALL:

    case PLUGIN_CLOCK_IN:

    case PLUGIN_EVENT_OUT:

      {

        if (Function == PLUGIN_INIT_ALL)

          Function = PLUGIN_INIT;

        for (byte y = 0; y < TASKS_MAX; y++)

        {

          if (Settings.TaskDeviceEnabled[y] && Settings.TaskDeviceNumber[y] != 0)

          {

            if (Settings.TaskDeviceDataFeed[y] == 0)

            {

              const int x = getPluginId(y);

              if (x >= 0) {

                byte DeviceIndex = getDeviceIndex(Settings.TaskDeviceNumber[y]);

                TempEvent.TaskIndex = y;

                TempEvent.BaseVarIndex = y * VARS_PER_TASK;



                TempEvent.sensorType = Device[DeviceIndex].VType;

                TempEvent.OriginTaskIndex = event->TaskIndex;

                checkRAM(F("PluginCall_s"),x);

                if (Function == PLUGIN_INIT) {



                  schedule_task_device_timer_at_init(TempEvent.TaskIndex);

                }

                START_TIMER;

                Plugin_ptr[x](Function, &TempEvent, str);

                STOP_TIMER_TASK(x,Function);

              }

            }

          }

        }

        return true;

        break;

      }





    case PLUGIN_INIT:

    case PLUGIN_EXIT:

    case PLUGIN_WEBFORM_LOAD:

    case PLUGIN_WEBFORM_SAVE:

    case PLUGIN_WEBFORM_SHOW_VALUES:

    case PLUGIN_WEBFORM_SHOW_CONFIG:

    case PLUGIN_GET_DEVICEVALUENAMES:

    case PLUGIN_GET_DEVICEGPIONAMES:

    case PLUGIN_READ:

    case PLUGIN_SET_CONFIG:

    case PLUGIN_GET_CONFIG:

    {

      const int x = getPluginId(event->TaskIndex);

      if (x >= 0) {

        if (Plugin_id[x] != 0 ) {

          if (Function == PLUGIN_INIT) {



            schedule_task_device_timer_at_init(event->TaskIndex);

          }

          if (Function != PLUGIN_GET_DEVICEVALUENAMES) {



            LoadTaskSettings(event->TaskIndex);

          }



          event->BaseVarIndex = event->TaskIndex * VARS_PER_TASK;

          checkRAM(F("PluginCall_init"),x);

          START_TIMER;

          bool retval = Plugin_ptr[x](Function, event, str);

          if (Function == PLUGIN_GET_DEVICEVALUENAMES) {

            ExtraTaskSettings.TaskIndex = event->TaskIndex;

          }

          STOP_TIMER_TASK(x,Function);

          return retval;

        }

      }

      return false;

      break;

    }



  }

  return false;

}
# 1 "C:/Users/admin/Documents/GitHub/ESPEasy/src/__ReleaseNotes.ino"